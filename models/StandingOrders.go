// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// StandingOrder is an object representing the database table.
type StandingOrder struct {
	StandingOrderID                        int               `boil:"standing_order_id" json:"standing_order_id" toml:"standing_order_id" yaml:"standing_order_id"`
	DebtorAccountID                        int               `boil:"debtor_account_id" json:"debtor_account_id" toml:"debtor_account_id" yaml:"debtor_account_id"`
	BankID                                 int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	StandingOrderAccountRefID              string            `boil:"standing_order_account_ref_id" json:"standing_order_account_ref_id" toml:"standing_order_account_ref_id" yaml:"standing_order_account_ref_id"`
	StandingOrderIDRef                     string            `boil:"standing_order_id_ref" json:"standing_order_id_ref" toml:"standing_order_id_ref" yaml:"standing_order_id_ref"`
	Frequency                              string            `boil:"frequency" json:"frequency" toml:"frequency" yaml:"frequency"`
	Reference                              string            `boil:"reference" json:"reference" toml:"reference" yaml:"reference"`
	FirstPaymentDateTime                   null.Time         `boil:"first_payment_date_time" json:"first_payment_date_time,omitempty" toml:"first_payment_date_time" yaml:"first_payment_date_time,omitempty"`
	FirstPaymentAmount                     types.NullDecimal `boil:"first_payment_amount" json:"first_payment_amount,omitempty" toml:"first_payment_amount" yaml:"first_payment_amount,omitempty"`
	FirstPaymentCurrency                   null.String       `boil:"first_payment_currency" json:"first_payment_currency,omitempty" toml:"first_payment_currency" yaml:"first_payment_currency,omitempty"`
	NextPaymentDateTime                    null.Time         `boil:"next_payment_date_time" json:"next_payment_date_time,omitempty" toml:"next_payment_date_time" yaml:"next_payment_date_time,omitempty"`
	NextPaymentAmount                      types.NullDecimal `boil:"next_payment_amount" json:"next_payment_amount,omitempty" toml:"next_payment_amount" yaml:"next_payment_amount,omitempty"`
	NextPaymentCurrency                    null.String       `boil:"next_payment_currency" json:"next_payment_currency,omitempty" toml:"next_payment_currency" yaml:"next_payment_currency,omitempty"`
	FinalPaymentDateTime                   null.Time         `boil:"final_payment_date_time" json:"final_payment_date_time,omitempty" toml:"final_payment_date_time" yaml:"final_payment_date_time,omitempty"`
	FinalPaymentAmount                     types.NullDecimal `boil:"final_payment_amount" json:"final_payment_amount,omitempty" toml:"final_payment_amount" yaml:"final_payment_amount,omitempty"`
	FinalPaymentCurrency                   null.String       `boil:"final_payment_currency" json:"final_payment_currency,omitempty" toml:"final_payment_currency" yaml:"final_payment_currency,omitempty"`
	CreditorBankCode                       null.String       `boil:"creditor_bank_code" json:"creditor_bank_code,omitempty" toml:"creditor_bank_code" yaml:"creditor_bank_code,omitempty"`
	CreditorBankName                       null.String       `boil:"creditor_bank_name" json:"creditor_bank_name,omitempty" toml:"creditor_bank_name" yaml:"creditor_bank_name,omitempty"`
	ServicerSchemeName                     null.String       `boil:"servicer_scheme_name" json:"servicer_scheme_name,omitempty" toml:"servicer_scheme_name" yaml:"servicer_scheme_name,omitempty"`
	ServicerIdentification                 null.String       `boil:"servicer_identification" json:"servicer_identification,omitempty" toml:"servicer_identification" yaml:"servicer_identification,omitempty"`
	CreditorAccountSchemeName              string            `boil:"creditor_account_scheme_name" json:"creditor_account_scheme_name" toml:"creditor_account_scheme_name" yaml:"creditor_account_scheme_name"`
	CreditorAccountIdentification          string            `boil:"creditor_account_identification" json:"creditor_account_identification" toml:"creditor_account_identification" yaml:"creditor_account_identification"`
	CreditorAccountName                    string            `boil:"creditor_account_name" json:"creditor_account_name" toml:"creditor_account_name" yaml:"creditor_account_name"`
	CreditorAccountSecondaryIdentification string            `boil:"creditor_account_secondary_identification" json:"creditor_account_secondary_identification" toml:"creditor_account_secondary_identification" yaml:"creditor_account_secondary_identification"`
	CreditorAccountID                      null.Int          `boil:"creditor_account_id" json:"creditor_account_id,omitempty" toml:"creditor_account_id" yaml:"creditor_account_id,omitempty"`
	MakerDate                              time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                            null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                                int               `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                              null.Int          `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                             null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate                           null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *standingOrderR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L standingOrderL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var StandingOrderColumns = struct {
	StandingOrderID                        string
	DebtorAccountID                        string
	BankID                                 string
	StandingOrderAccountRefID              string
	StandingOrderIDRef                     string
	Frequency                              string
	Reference                              string
	FirstPaymentDateTime                   string
	FirstPaymentAmount                     string
	FirstPaymentCurrency                   string
	NextPaymentDateTime                    string
	NextPaymentAmount                      string
	NextPaymentCurrency                    string
	FinalPaymentDateTime                   string
	FinalPaymentAmount                     string
	FinalPaymentCurrency                   string
	CreditorBankCode                       string
	CreditorBankName                       string
	ServicerSchemeName                     string
	ServicerIdentification                 string
	CreditorAccountSchemeName              string
	CreditorAccountIdentification          string
	CreditorAccountName                    string
	CreditorAccountSecondaryIdentification string
	CreditorAccountID                      string
	MakerDate                              string
	CheckerDate                            string
	MakerID                                string
	CheckerID                              string
	ModifiedBy                             string
	ModifiedDate                           string
}{
	StandingOrderID:                        "standing_order_id",
	DebtorAccountID:                        "debtor_account_id",
	BankID:                                 "bank_id",
	StandingOrderAccountRefID:              "standing_order_account_ref_id",
	StandingOrderIDRef:                     "standing_order_id_ref",
	Frequency:                              "frequency",
	Reference:                              "reference",
	FirstPaymentDateTime:                   "first_payment_date_time",
	FirstPaymentAmount:                     "first_payment_amount",
	FirstPaymentCurrency:                   "first_payment_currency",
	NextPaymentDateTime:                    "next_payment_date_time",
	NextPaymentAmount:                      "next_payment_amount",
	NextPaymentCurrency:                    "next_payment_currency",
	FinalPaymentDateTime:                   "final_payment_date_time",
	FinalPaymentAmount:                     "final_payment_amount",
	FinalPaymentCurrency:                   "final_payment_currency",
	CreditorBankCode:                       "creditor_bank_code",
	CreditorBankName:                       "creditor_bank_name",
	ServicerSchemeName:                     "servicer_scheme_name",
	ServicerIdentification:                 "servicer_identification",
	CreditorAccountSchemeName:              "creditor_account_scheme_name",
	CreditorAccountIdentification:          "creditor_account_identification",
	CreditorAccountName:                    "creditor_account_name",
	CreditorAccountSecondaryIdentification: "creditor_account_secondary_identification",
	CreditorAccountID:                      "creditor_account_id",
	MakerDate:                              "maker_date",
	CheckerDate:                            "checker_date",
	MakerID:                                "maker_id",
	CheckerID:                              "checker_id",
	ModifiedBy:                             "modified_by",
	ModifiedDate:                           "modified_date",
}

// Generated where

var StandingOrderWhere = struct {
	StandingOrderID                        whereHelperint
	DebtorAccountID                        whereHelperint
	BankID                                 whereHelperint
	StandingOrderAccountRefID              whereHelperstring
	StandingOrderIDRef                     whereHelperstring
	Frequency                              whereHelperstring
	Reference                              whereHelperstring
	FirstPaymentDateTime                   whereHelpernull_Time
	FirstPaymentAmount                     whereHelpertypes_NullDecimal
	FirstPaymentCurrency                   whereHelpernull_String
	NextPaymentDateTime                    whereHelpernull_Time
	NextPaymentAmount                      whereHelpertypes_NullDecimal
	NextPaymentCurrency                    whereHelpernull_String
	FinalPaymentDateTime                   whereHelpernull_Time
	FinalPaymentAmount                     whereHelpertypes_NullDecimal
	FinalPaymentCurrency                   whereHelpernull_String
	CreditorBankCode                       whereHelpernull_String
	CreditorBankName                       whereHelpernull_String
	ServicerSchemeName                     whereHelpernull_String
	ServicerIdentification                 whereHelpernull_String
	CreditorAccountSchemeName              whereHelperstring
	CreditorAccountIdentification          whereHelperstring
	CreditorAccountName                    whereHelperstring
	CreditorAccountSecondaryIdentification whereHelperstring
	CreditorAccountID                      whereHelpernull_Int
	MakerDate                              whereHelpertime_Time
	CheckerDate                            whereHelpernull_Time
	MakerID                                whereHelperint
	CheckerID                              whereHelpernull_Int
	ModifiedBy                             whereHelpernull_String
	ModifiedDate                           whereHelpernull_Time
}{
	StandingOrderID:                        whereHelperint{field: `standing_order_id`},
	DebtorAccountID:                        whereHelperint{field: `debtor_account_id`},
	BankID:                                 whereHelperint{field: `bank_id`},
	StandingOrderAccountRefID:              whereHelperstring{field: `standing_order_account_ref_id`},
	StandingOrderIDRef:                     whereHelperstring{field: `standing_order_id_ref`},
	Frequency:                              whereHelperstring{field: `frequency`},
	Reference:                              whereHelperstring{field: `reference`},
	FirstPaymentDateTime:                   whereHelpernull_Time{field: `first_payment_date_time`},
	FirstPaymentAmount:                     whereHelpertypes_NullDecimal{field: `first_payment_amount`},
	FirstPaymentCurrency:                   whereHelpernull_String{field: `first_payment_currency`},
	NextPaymentDateTime:                    whereHelpernull_Time{field: `next_payment_date_time`},
	NextPaymentAmount:                      whereHelpertypes_NullDecimal{field: `next_payment_amount`},
	NextPaymentCurrency:                    whereHelpernull_String{field: `next_payment_currency`},
	FinalPaymentDateTime:                   whereHelpernull_Time{field: `final_payment_date_time`},
	FinalPaymentAmount:                     whereHelpertypes_NullDecimal{field: `final_payment_amount`},
	FinalPaymentCurrency:                   whereHelpernull_String{field: `final_payment_currency`},
	CreditorBankCode:                       whereHelpernull_String{field: `creditor_bank_code`},
	CreditorBankName:                       whereHelpernull_String{field: `creditor_bank_name`},
	ServicerSchemeName:                     whereHelpernull_String{field: `servicer_scheme_name`},
	ServicerIdentification:                 whereHelpernull_String{field: `servicer_identification`},
	CreditorAccountSchemeName:              whereHelperstring{field: `creditor_account_scheme_name`},
	CreditorAccountIdentification:          whereHelperstring{field: `creditor_account_identification`},
	CreditorAccountName:                    whereHelperstring{field: `creditor_account_name`},
	CreditorAccountSecondaryIdentification: whereHelperstring{field: `creditor_account_secondary_identification`},
	CreditorAccountID:                      whereHelpernull_Int{field: `creditor_account_id`},
	MakerDate:                              whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                            whereHelpernull_Time{field: `checker_date`},
	MakerID:                                whereHelperint{field: `maker_id`},
	CheckerID:                              whereHelpernull_Int{field: `checker_id`},
	ModifiedBy:                             whereHelpernull_String{field: `modified_by`},
	ModifiedDate:                           whereHelpernull_Time{field: `modified_date`},
}

// StandingOrderRels is where relationship names are stored.
var StandingOrderRels = struct {
	Bank string
}{
	Bank: "Bank",
}

// standingOrderR is where relationships are stored.
type standingOrderR struct {
	Bank *Bank
}

// NewStruct creates a new relationship struct
func (*standingOrderR) NewStruct() *standingOrderR {
	return &standingOrderR{}
}

// standingOrderL is where Load methods for each relationship are stored.
type standingOrderL struct{}

var (
	standingOrderColumns               = []string{"standing_order_id", "debtor_account_id", "bank_id", "standing_order_account_ref_id", "standing_order_id_ref", "frequency", "reference", "first_payment_date_time", "first_payment_amount", "first_payment_currency", "next_payment_date_time", "next_payment_amount", "next_payment_currency", "final_payment_date_time", "final_payment_amount", "final_payment_currency", "creditor_bank_code", "creditor_bank_name", "servicer_scheme_name", "servicer_identification", "creditor_account_scheme_name", "creditor_account_identification", "creditor_account_name", "creditor_account_secondary_identification", "creditor_account_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	standingOrderColumnsWithoutDefault = []string{"standing_order_id", "debtor_account_id", "bank_id", "standing_order_account_ref_id", "standing_order_id_ref", "frequency", "reference", "first_payment_date_time", "first_payment_amount", "first_payment_currency", "next_payment_date_time", "next_payment_amount", "next_payment_currency", "final_payment_date_time", "final_payment_amount", "final_payment_currency", "creditor_bank_code", "creditor_bank_name", "servicer_scheme_name", "servicer_identification", "creditor_account_scheme_name", "creditor_account_identification", "creditor_account_name", "creditor_account_secondary_identification", "creditor_account_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	standingOrderColumnsWithDefault    = []string{}
	standingOrderPrimaryKeyColumns     = []string{"standing_order_id"}
)

type (
	// StandingOrderSlice is an alias for a slice of pointers to StandingOrder.
	// This should generally be used opposed to []StandingOrder.
	StandingOrderSlice []*StandingOrder
	// StandingOrderHook is the signature for custom StandingOrder hook methods
	StandingOrderHook func(context.Context, boil.ContextExecutor, *StandingOrder) error

	standingOrderQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	standingOrderType                 = reflect.TypeOf(&StandingOrder{})
	standingOrderMapping              = queries.MakeStructMapping(standingOrderType)
	standingOrderPrimaryKeyMapping, _ = queries.BindMapping(standingOrderType, standingOrderMapping, standingOrderPrimaryKeyColumns)
	standingOrderInsertCacheMut       sync.RWMutex
	standingOrderInsertCache          = make(map[string]insertCache)
	standingOrderUpdateCacheMut       sync.RWMutex
	standingOrderUpdateCache          = make(map[string]updateCache)
	standingOrderUpsertCacheMut       sync.RWMutex
	standingOrderUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var standingOrderBeforeInsertHooks []StandingOrderHook
var standingOrderBeforeUpdateHooks []StandingOrderHook
var standingOrderBeforeDeleteHooks []StandingOrderHook
var standingOrderBeforeUpsertHooks []StandingOrderHook

var standingOrderAfterInsertHooks []StandingOrderHook
var standingOrderAfterSelectHooks []StandingOrderHook
var standingOrderAfterUpdateHooks []StandingOrderHook
var standingOrderAfterDeleteHooks []StandingOrderHook
var standingOrderAfterUpsertHooks []StandingOrderHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *StandingOrder) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *StandingOrder) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *StandingOrder) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *StandingOrder) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *StandingOrder) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *StandingOrder) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *StandingOrder) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *StandingOrder) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *StandingOrder) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range standingOrderAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddStandingOrderHook registers your hook function for all future operations.
func AddStandingOrderHook(hookPoint boil.HookPoint, standingOrderHook StandingOrderHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		standingOrderBeforeInsertHooks = append(standingOrderBeforeInsertHooks, standingOrderHook)
	case boil.BeforeUpdateHook:
		standingOrderBeforeUpdateHooks = append(standingOrderBeforeUpdateHooks, standingOrderHook)
	case boil.BeforeDeleteHook:
		standingOrderBeforeDeleteHooks = append(standingOrderBeforeDeleteHooks, standingOrderHook)
	case boil.BeforeUpsertHook:
		standingOrderBeforeUpsertHooks = append(standingOrderBeforeUpsertHooks, standingOrderHook)
	case boil.AfterInsertHook:
		standingOrderAfterInsertHooks = append(standingOrderAfterInsertHooks, standingOrderHook)
	case boil.AfterSelectHook:
		standingOrderAfterSelectHooks = append(standingOrderAfterSelectHooks, standingOrderHook)
	case boil.AfterUpdateHook:
		standingOrderAfterUpdateHooks = append(standingOrderAfterUpdateHooks, standingOrderHook)
	case boil.AfterDeleteHook:
		standingOrderAfterDeleteHooks = append(standingOrderAfterDeleteHooks, standingOrderHook)
	case boil.AfterUpsertHook:
		standingOrderAfterUpsertHooks = append(standingOrderAfterUpsertHooks, standingOrderHook)
	}
}

// One returns a single standingOrder record from the query.
func (q standingOrderQuery) One(ctx context.Context, exec boil.ContextExecutor) (*StandingOrder, error) {
	o := &StandingOrder{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for StandingOrders")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all StandingOrder records from the query.
func (q standingOrderQuery) All(ctx context.Context, exec boil.ContextExecutor) (StandingOrderSlice, error) {
	var o []*StandingOrder

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to StandingOrder slice")
	}

	if len(standingOrderAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all StandingOrder records in the query.
func (q standingOrderQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count StandingOrders rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q standingOrderQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if StandingOrders exists")
	}

	return count > 0, nil
}

// Bank pointed to by the foreign key.
func (o *StandingOrder) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (standingOrderL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStandingOrder interface{}, mods queries.Applicator) error {
	var slice []*StandingOrder
	var object *StandingOrder

	if singular {
		object = maybeStandingOrder.(*StandingOrder)
	} else {
		slice = *maybeStandingOrder.(*[]*StandingOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &standingOrderR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &standingOrderR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(standingOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankStandingOrders = append(foreign.R.BankStandingOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankStandingOrders = append(foreign.R.BankStandingOrders, local)
				break
			}
		}
	}

	return nil
}

// SetBank of the standingOrder to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankStandingOrders.
func (o *StandingOrder) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `StandingOrders` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, standingOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.StandingOrderID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &standingOrderR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankStandingOrders: StandingOrderSlice{o},
		}
	} else {
		related.R.BankStandingOrders = append(related.R.BankStandingOrders, o)
	}

	return nil
}

// StandingOrders retrieves all the records using an executor.
func StandingOrders(mods ...qm.QueryMod) standingOrderQuery {
	mods = append(mods, qm.From("`StandingOrders`"))
	return standingOrderQuery{NewQuery(mods...)}
}

// FindStandingOrder retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindStandingOrder(ctx context.Context, exec boil.ContextExecutor, standingOrderID int, selectCols ...string) (*StandingOrder, error) {
	standingOrderObj := &StandingOrder{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `StandingOrders` where `standing_order_id`=?", sel,
	)

	q := queries.Raw(query, standingOrderID)

	err := q.Bind(ctx, exec, standingOrderObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from StandingOrders")
	}

	return standingOrderObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *StandingOrder) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no StandingOrders provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(standingOrderColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	standingOrderInsertCacheMut.RLock()
	cache, cached := standingOrderInsertCache[key]
	standingOrderInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			standingOrderColumns,
			standingOrderColumnsWithDefault,
			standingOrderColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(standingOrderType, standingOrderMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(standingOrderType, standingOrderMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `StandingOrders` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `StandingOrders` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `StandingOrders` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, standingOrderPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into StandingOrders")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.StandingOrderID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for StandingOrders")
	}

CacheNoHooks:
	if !cached {
		standingOrderInsertCacheMut.Lock()
		standingOrderInsertCache[key] = cache
		standingOrderInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the StandingOrder.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *StandingOrder) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	standingOrderUpdateCacheMut.RLock()
	cache, cached := standingOrderUpdateCache[key]
	standingOrderUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			standingOrderColumns,
			standingOrderPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update StandingOrders, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `StandingOrders` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, standingOrderPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(standingOrderType, standingOrderMapping, append(wl, standingOrderPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update StandingOrders row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for StandingOrders")
	}

	if !cached {
		standingOrderUpdateCacheMut.Lock()
		standingOrderUpdateCache[key] = cache
		standingOrderUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q standingOrderQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for StandingOrders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for StandingOrders")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o StandingOrderSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), standingOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `StandingOrders` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, standingOrderPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in standingOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all standingOrder")
	}
	return rowsAff, nil
}

var mySQLStandingOrderUniqueColumns = []string{
	"standing_order_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *StandingOrder) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no StandingOrders provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(standingOrderColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLStandingOrderUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	standingOrderUpsertCacheMut.RLock()
	cache, cached := standingOrderUpsertCache[key]
	standingOrderUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			standingOrderColumns,
			standingOrderColumnsWithDefault,
			standingOrderColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			standingOrderColumns,
			standingOrderPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert StandingOrders, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "StandingOrders", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `StandingOrders` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(standingOrderType, standingOrderMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(standingOrderType, standingOrderMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for StandingOrders")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(standingOrderType, standingOrderMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for StandingOrders")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for StandingOrders")
	}

CacheNoHooks:
	if !cached {
		standingOrderUpsertCacheMut.Lock()
		standingOrderUpsertCache[key] = cache
		standingOrderUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single StandingOrder record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *StandingOrder) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no StandingOrder provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), standingOrderPrimaryKeyMapping)
	sql := "DELETE FROM `StandingOrders` WHERE `standing_order_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from StandingOrders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for StandingOrders")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q standingOrderQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no standingOrderQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from StandingOrders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for StandingOrders")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o StandingOrderSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no StandingOrder slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(standingOrderBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), standingOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `StandingOrders` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, standingOrderPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from standingOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for StandingOrders")
	}

	if len(standingOrderAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *StandingOrder) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindStandingOrder(ctx, exec, o.StandingOrderID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *StandingOrderSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := StandingOrderSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), standingOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `StandingOrders`.* FROM `StandingOrders` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, standingOrderPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in StandingOrderSlice")
	}

	*o = slice

	return nil
}

// StandingOrderExists checks if the StandingOrder row exists.
func StandingOrderExists(ctx context.Context, exec boil.ContextExecutor, standingOrderID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `StandingOrders` where `standing_order_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, standingOrderID)
	}

	row := exec.QueryRowContext(ctx, sql, standingOrderID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if StandingOrders exists")
	}

	return exists, nil
}
