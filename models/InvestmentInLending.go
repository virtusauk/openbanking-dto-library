// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// InvestmentInLending is an object representing the database table.
type InvestmentInLending struct {
	InvestmentLendingID int               `boil:"investment_lending_id" json:"investment_lending_id" toml:"investment_lending_id" yaml:"investment_lending_id"`
	PortfolioID         int               `boil:"portfolio_id" json:"portfolio_id" toml:"portfolio_id" yaml:"portfolio_id"`
	LoanID              int               `boil:"loan_id" json:"loan_id" toml:"loan_id" yaml:"loan_id"`
	AmountLended        types.Decimal     `boil:"amount_lended" json:"amount_lended" toml:"amount_lended" yaml:"amount_lended"`
	LoanRisk            types.Decimal     `boil:"loan_risk" json:"loan_risk" toml:"loan_risk" yaml:"loan_risk"`
	AmountReceived      types.NullDecimal `boil:"amount_received" json:"amount_received,omitempty" toml:"amount_received" yaml:"amount_received,omitempty"`
	LendedDate          time.Time         `boil:"lended_date" json:"lended_date" toml:"lended_date" yaml:"lended_date"`
	MaturityDate        time.Time         `boil:"maturity_date" json:"maturity_date" toml:"maturity_date" yaml:"maturity_date"`
	ReturnOnInvestment  types.NullDecimal `boil:"return_on_investment" json:"return_on_investment,omitempty" toml:"return_on_investment" yaml:"return_on_investment,omitempty"`
	PartyID             null.Int          `boil:"party_id" json:"party_id,omitempty" toml:"party_id" yaml:"party_id,omitempty"`
	BankID              int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	MakerDate           time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate         null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID             string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID           null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy          null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate        null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *investmentInLendingR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L investmentInLendingL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var InvestmentInLendingColumns = struct {
	InvestmentLendingID string
	PortfolioID         string
	LoanID              string
	AmountLended        string
	LoanRisk            string
	AmountReceived      string
	LendedDate          string
	MaturityDate        string
	ReturnOnInvestment  string
	PartyID             string
	BankID              string
	MakerDate           string
	CheckerDate         string
	MakerID             string
	CheckerID           string
	ModifiedBy          string
	ModifiedDate        string
}{
	InvestmentLendingID: "investment_lending_id",
	PortfolioID:         "portfolio_id",
	LoanID:              "loan_id",
	AmountLended:        "amount_lended",
	LoanRisk:            "loan_risk",
	AmountReceived:      "amount_received",
	LendedDate:          "lended_date",
	MaturityDate:        "maturity_date",
	ReturnOnInvestment:  "return_on_investment",
	PartyID:             "party_id",
	BankID:              "bank_id",
	MakerDate:           "maker_date",
	CheckerDate:         "checker_date",
	MakerID:             "maker_id",
	CheckerID:           "checker_id",
	ModifiedBy:          "modified_by",
	ModifiedDate:        "modified_date",
}

// Generated where

var InvestmentInLendingWhere = struct {
	InvestmentLendingID whereHelperint
	PortfolioID         whereHelperint
	LoanID              whereHelperint
	AmountLended        whereHelpertypes_Decimal
	LoanRisk            whereHelpertypes_Decimal
	AmountReceived      whereHelpertypes_NullDecimal
	LendedDate          whereHelpertime_Time
	MaturityDate        whereHelpertime_Time
	ReturnOnInvestment  whereHelpertypes_NullDecimal
	PartyID             whereHelpernull_Int
	BankID              whereHelperint
	MakerDate           whereHelpertime_Time
	CheckerDate         whereHelpernull_Time
	MakerID             whereHelperstring
	CheckerID           whereHelpernull_String
	ModifiedBy          whereHelpernull_String
	ModifiedDate        whereHelpernull_Time
}{
	InvestmentLendingID: whereHelperint{field: `investment_lending_id`},
	PortfolioID:         whereHelperint{field: `portfolio_id`},
	LoanID:              whereHelperint{field: `loan_id`},
	AmountLended:        whereHelpertypes_Decimal{field: `amount_lended`},
	LoanRisk:            whereHelpertypes_Decimal{field: `loan_risk`},
	AmountReceived:      whereHelpertypes_NullDecimal{field: `amount_received`},
	LendedDate:          whereHelpertime_Time{field: `lended_date`},
	MaturityDate:        whereHelpertime_Time{field: `maturity_date`},
	ReturnOnInvestment:  whereHelpertypes_NullDecimal{field: `return_on_investment`},
	PartyID:             whereHelpernull_Int{field: `party_id`},
	BankID:              whereHelperint{field: `bank_id`},
	MakerDate:           whereHelpertime_Time{field: `maker_date`},
	CheckerDate:         whereHelpernull_Time{field: `checker_date`},
	MakerID:             whereHelperstring{field: `maker_id`},
	CheckerID:           whereHelpernull_String{field: `checker_id`},
	ModifiedBy:          whereHelpernull_String{field: `modified_by`},
	ModifiedDate:        whereHelpernull_Time{field: `modified_date`},
}

// InvestmentInLendingRels is where relationship names are stored.
var InvestmentInLendingRels = struct {
	Loan string
}{
	Loan: "Loan",
}

// investmentInLendingR is where relationships are stored.
type investmentInLendingR struct {
	Loan *Loan
}

// NewStruct creates a new relationship struct
func (*investmentInLendingR) NewStruct() *investmentInLendingR {
	return &investmentInLendingR{}
}

// investmentInLendingL is where Load methods for each relationship are stored.
type investmentInLendingL struct{}

var (
	investmentInLendingColumns               = []string{"investment_lending_id", "portfolio_id", "loan_id", "amount_lended", "loan_risk", "amount_received", "lended_date", "maturity_date", "return_on_investment", "party_id", "bank_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	investmentInLendingColumnsWithoutDefault = []string{"portfolio_id", "loan_id", "amount_lended", "loan_risk", "amount_received", "lended_date", "maturity_date", "return_on_investment", "party_id", "bank_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	investmentInLendingColumnsWithDefault    = []string{"investment_lending_id"}
	investmentInLendingPrimaryKeyColumns     = []string{"investment_lending_id"}
)

type (
	// InvestmentInLendingSlice is an alias for a slice of pointers to InvestmentInLending.
	// This should generally be used opposed to []InvestmentInLending.
	InvestmentInLendingSlice []*InvestmentInLending
	// InvestmentInLendingHook is the signature for custom InvestmentInLending hook methods
	InvestmentInLendingHook func(context.Context, boil.ContextExecutor, *InvestmentInLending) error

	investmentInLendingQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	investmentInLendingType                 = reflect.TypeOf(&InvestmentInLending{})
	investmentInLendingMapping              = queries.MakeStructMapping(investmentInLendingType)
	investmentInLendingPrimaryKeyMapping, _ = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, investmentInLendingPrimaryKeyColumns)
	investmentInLendingInsertCacheMut       sync.RWMutex
	investmentInLendingInsertCache          = make(map[string]insertCache)
	investmentInLendingUpdateCacheMut       sync.RWMutex
	investmentInLendingUpdateCache          = make(map[string]updateCache)
	investmentInLendingUpsertCacheMut       sync.RWMutex
	investmentInLendingUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var investmentInLendingBeforeInsertHooks []InvestmentInLendingHook
var investmentInLendingBeforeUpdateHooks []InvestmentInLendingHook
var investmentInLendingBeforeDeleteHooks []InvestmentInLendingHook
var investmentInLendingBeforeUpsertHooks []InvestmentInLendingHook

var investmentInLendingAfterInsertHooks []InvestmentInLendingHook
var investmentInLendingAfterSelectHooks []InvestmentInLendingHook
var investmentInLendingAfterUpdateHooks []InvestmentInLendingHook
var investmentInLendingAfterDeleteHooks []InvestmentInLendingHook
var investmentInLendingAfterUpsertHooks []InvestmentInLendingHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *InvestmentInLending) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *InvestmentInLending) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *InvestmentInLending) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *InvestmentInLending) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *InvestmentInLending) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *InvestmentInLending) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *InvestmentInLending) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *InvestmentInLending) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *InvestmentInLending) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range investmentInLendingAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddInvestmentInLendingHook registers your hook function for all future operations.
func AddInvestmentInLendingHook(hookPoint boil.HookPoint, investmentInLendingHook InvestmentInLendingHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		investmentInLendingBeforeInsertHooks = append(investmentInLendingBeforeInsertHooks, investmentInLendingHook)
	case boil.BeforeUpdateHook:
		investmentInLendingBeforeUpdateHooks = append(investmentInLendingBeforeUpdateHooks, investmentInLendingHook)
	case boil.BeforeDeleteHook:
		investmentInLendingBeforeDeleteHooks = append(investmentInLendingBeforeDeleteHooks, investmentInLendingHook)
	case boil.BeforeUpsertHook:
		investmentInLendingBeforeUpsertHooks = append(investmentInLendingBeforeUpsertHooks, investmentInLendingHook)
	case boil.AfterInsertHook:
		investmentInLendingAfterInsertHooks = append(investmentInLendingAfterInsertHooks, investmentInLendingHook)
	case boil.AfterSelectHook:
		investmentInLendingAfterSelectHooks = append(investmentInLendingAfterSelectHooks, investmentInLendingHook)
	case boil.AfterUpdateHook:
		investmentInLendingAfterUpdateHooks = append(investmentInLendingAfterUpdateHooks, investmentInLendingHook)
	case boil.AfterDeleteHook:
		investmentInLendingAfterDeleteHooks = append(investmentInLendingAfterDeleteHooks, investmentInLendingHook)
	case boil.AfterUpsertHook:
		investmentInLendingAfterUpsertHooks = append(investmentInLendingAfterUpsertHooks, investmentInLendingHook)
	}
}

// One returns a single investmentInLending record from the query.
func (q investmentInLendingQuery) One(ctx context.Context, exec boil.ContextExecutor) (*InvestmentInLending, error) {
	o := &InvestmentInLending{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for InvestmentInLending")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all InvestmentInLending records from the query.
func (q investmentInLendingQuery) All(ctx context.Context, exec boil.ContextExecutor) (InvestmentInLendingSlice, error) {
	var o []*InvestmentInLending

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to InvestmentInLending slice")
	}

	if len(investmentInLendingAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all InvestmentInLending records in the query.
func (q investmentInLendingQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count InvestmentInLending rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q investmentInLendingQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if InvestmentInLending exists")
	}

	return count > 0, nil
}

// Loan pointed to by the foreign key.
func (o *InvestmentInLending) Loan(mods ...qm.QueryMod) loanQuery {
	queryMods := []qm.QueryMod{
		qm.Where("loan_id=?", o.LoanID),
	}

	queryMods = append(queryMods, mods...)

	query := Loans(queryMods...)
	queries.SetFrom(query.Query, "`Loan`")

	return query
}

// LoadLoan allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (investmentInLendingL) LoadLoan(ctx context.Context, e boil.ContextExecutor, singular bool, maybeInvestmentInLending interface{}, mods queries.Applicator) error {
	var slice []*InvestmentInLending
	var object *InvestmentInLending

	if singular {
		object = maybeInvestmentInLending.(*InvestmentInLending)
	} else {
		slice = *maybeInvestmentInLending.(*[]*InvestmentInLending)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &investmentInLendingR{}
		}
		args = append(args, object.LoanID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &investmentInLendingR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Loan`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Loan")
	}

	var resultSlice []*Loan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Loan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Loan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Loan")
	}

	if len(investmentInLendingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Loan = foreign
		if foreign.R == nil {
			foreign.R = &loanR{}
		}
		foreign.R.LoanInvestmentInLendings = append(foreign.R.LoanInvestmentInLendings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.LoanID == foreign.LoanID {
				local.R.Loan = foreign
				if foreign.R == nil {
					foreign.R = &loanR{}
				}
				foreign.R.LoanInvestmentInLendings = append(foreign.R.LoanInvestmentInLendings, local)
				break
			}
		}
	}

	return nil
}

// SetLoan of the investmentInLending to the related item.
// Sets o.R.Loan to related.
// Adds o to related.R.LoanInvestmentInLendings.
func (o *InvestmentInLending) SetLoan(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Loan) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `InvestmentInLending` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
		strmangle.WhereClause("`", "`", 0, investmentInLendingPrimaryKeyColumns),
	)
	values := []interface{}{related.LoanID, o.InvestmentLendingID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.LoanID = related.LoanID
	if o.R == nil {
		o.R = &investmentInLendingR{
			Loan: related,
		}
	} else {
		o.R.Loan = related
	}

	if related.R == nil {
		related.R = &loanR{
			LoanInvestmentInLendings: InvestmentInLendingSlice{o},
		}
	} else {
		related.R.LoanInvestmentInLendings = append(related.R.LoanInvestmentInLendings, o)
	}

	return nil
}

// InvestmentInLendings retrieves all the records using an executor.
func InvestmentInLendings(mods ...qm.QueryMod) investmentInLendingQuery {
	mods = append(mods, qm.From("`InvestmentInLending`"))
	return investmentInLendingQuery{NewQuery(mods...)}
}

// FindInvestmentInLending retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindInvestmentInLending(ctx context.Context, exec boil.ContextExecutor, investmentLendingID int, selectCols ...string) (*InvestmentInLending, error) {
	investmentInLendingObj := &InvestmentInLending{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `InvestmentInLending` where `investment_lending_id`=?", sel,
	)

	q := queries.Raw(query, investmentLendingID)

	err := q.Bind(ctx, exec, investmentInLendingObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from InvestmentInLending")
	}

	return investmentInLendingObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *InvestmentInLending) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no InvestmentInLending provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(investmentInLendingColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	investmentInLendingInsertCacheMut.RLock()
	cache, cached := investmentInLendingInsertCache[key]
	investmentInLendingInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			investmentInLendingColumns,
			investmentInLendingColumnsWithDefault,
			investmentInLendingColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `InvestmentInLending` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `InvestmentInLending` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `InvestmentInLending` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, investmentInLendingPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into InvestmentInLending")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.InvestmentLendingID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == investmentInLendingMapping["InvestmentLendingID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.InvestmentLendingID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for InvestmentInLending")
	}

CacheNoHooks:
	if !cached {
		investmentInLendingInsertCacheMut.Lock()
		investmentInLendingInsertCache[key] = cache
		investmentInLendingInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the InvestmentInLending.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *InvestmentInLending) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	investmentInLendingUpdateCacheMut.RLock()
	cache, cached := investmentInLendingUpdateCache[key]
	investmentInLendingUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			investmentInLendingColumns,
			investmentInLendingPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update InvestmentInLending, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `InvestmentInLending` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, investmentInLendingPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, append(wl, investmentInLendingPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update InvestmentInLending row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for InvestmentInLending")
	}

	if !cached {
		investmentInLendingUpdateCacheMut.Lock()
		investmentInLendingUpdateCache[key] = cache
		investmentInLendingUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q investmentInLendingQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for InvestmentInLending")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for InvestmentInLending")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o InvestmentInLendingSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), investmentInLendingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `InvestmentInLending` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, investmentInLendingPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in investmentInLending slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all investmentInLending")
	}
	return rowsAff, nil
}

var mySQLInvestmentInLendingUniqueColumns = []string{
	"investment_lending_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *InvestmentInLending) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no InvestmentInLending provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(investmentInLendingColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLInvestmentInLendingUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	investmentInLendingUpsertCacheMut.RLock()
	cache, cached := investmentInLendingUpsertCache[key]
	investmentInLendingUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			investmentInLendingColumns,
			investmentInLendingColumnsWithDefault,
			investmentInLendingColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			investmentInLendingColumns,
			investmentInLendingPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert InvestmentInLending, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "InvestmentInLending", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `InvestmentInLending` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for InvestmentInLending")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.InvestmentLendingID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == investmentInLendingMapping["investment_lending_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(investmentInLendingType, investmentInLendingMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for InvestmentInLending")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for InvestmentInLending")
	}

CacheNoHooks:
	if !cached {
		investmentInLendingUpsertCacheMut.Lock()
		investmentInLendingUpsertCache[key] = cache
		investmentInLendingUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single InvestmentInLending record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *InvestmentInLending) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no InvestmentInLending provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), investmentInLendingPrimaryKeyMapping)
	sql := "DELETE FROM `InvestmentInLending` WHERE `investment_lending_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from InvestmentInLending")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for InvestmentInLending")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q investmentInLendingQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no investmentInLendingQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from InvestmentInLending")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for InvestmentInLending")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o InvestmentInLendingSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no InvestmentInLending slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(investmentInLendingBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), investmentInLendingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `InvestmentInLending` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, investmentInLendingPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from investmentInLending slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for InvestmentInLending")
	}

	if len(investmentInLendingAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *InvestmentInLending) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindInvestmentInLending(ctx, exec, o.InvestmentLendingID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *InvestmentInLendingSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := InvestmentInLendingSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), investmentInLendingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `InvestmentInLending`.* FROM `InvestmentInLending` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, investmentInLendingPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in InvestmentInLendingSlice")
	}

	*o = slice

	return nil
}

// InvestmentInLendingExists checks if the InvestmentInLending row exists.
func InvestmentInLendingExists(ctx context.Context, exec boil.ContextExecutor, investmentLendingID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `InvestmentInLending` where `investment_lending_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, investmentLendingID)
	}

	row := exec.QueryRowContext(ctx, sql, investmentLendingID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if InvestmentInLending exists")
	}

	return exists, nil
}
