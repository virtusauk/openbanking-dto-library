// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Payment is an object representing the database table.
type Payment struct {
	PaymentID                             int               `boil:"payment_id" json:"payment_id" toml:"payment_id" yaml:"payment_id"`
	ValueDate                             time.Time         `boil:"value_date" json:"value_date" toml:"value_date" yaml:"value_date"`
	PaymentRefID                          string            `boil:"payment_ref_id" json:"payment_ref_id" toml:"payment_ref_id" yaml:"payment_ref_id"`
	PaymentSubmissionID                   null.String       `boil:"payment_submission_id" json:"payment_submission_id,omitempty" toml:"payment_submission_id" yaml:"payment_submission_id,omitempty"`
	SchemePaymentID                       null.String       `boil:"scheme_payment_id" json:"scheme_payment_id,omitempty" toml:"scheme_payment_id" yaml:"scheme_payment_id,omitempty"`
	InstructionIdentification             string            `boil:"instruction_identification" json:"instruction_identification" toml:"instruction_identification" yaml:"instruction_identification"`
	EndToEndIdentification                string            `boil:"end_to_end_identification" json:"end_to_end_identification" toml:"end_to_end_identification" yaml:"end_to_end_identification"`
	TransactionAmount                     types.Decimal     `boil:"transaction_amount" json:"transaction_amount" toml:"transaction_amount" yaml:"transaction_amount"`
	TransactionCurrency                   string            `boil:"transaction_currency" json:"transaction_currency" toml:"transaction_currency" yaml:"transaction_currency"`
	FromBankID                            null.Int          `boil:"from_bank_id" json:"from_bank_id,omitempty" toml:"from_bank_id" yaml:"from_bank_id,omitempty"`
	DebtorBank                            string            `boil:"debtor_bank" json:"debtor_bank" toml:"debtor_bank" yaml:"debtor_bank"`
	FromPartyID                           null.Int          `boil:"from_party_id" json:"from_party_id,omitempty" toml:"from_party_id" yaml:"from_party_id,omitempty"`
	DebtorAgentSchemeName                 null.String       `boil:"debtor_agent_scheme_name" json:"debtor_agent_scheme_name,omitempty" toml:"debtor_agent_scheme_name" yaml:"debtor_agent_scheme_name,omitempty"`
	DebtorAgentIdentification             null.String       `boil:"debtor_agent_identification" json:"debtor_agent_identification,omitempty" toml:"debtor_agent_identification" yaml:"debtor_agent_identification,omitempty"`
	DebtorAccountSchemename               string            `boil:"debtor_account_schemename" json:"debtor_account_schemename" toml:"debtor_account_schemename" yaml:"debtor_account_schemename"`
	DebtorAccountIdentification           string            `boil:"debtor_account_identification" json:"debtor_account_identification" toml:"debtor_account_identification" yaml:"debtor_account_identification"`
	DebtorAccountSecondaryIdentification  string            `boil:"debtor_account_secondary_identification" json:"debtor_account_secondary_identification" toml:"debtor_account_secondary_identification" yaml:"debtor_account_secondary_identification"`
	DebtorAccountName                     string            `boil:"debtor_account_name" json:"debtor_account_name" toml:"debtor_account_name" yaml:"debtor_account_name"`
	CreditorBank                          string            `boil:"creditor_bank" json:"creditor_bank" toml:"creditor_bank" yaml:"creditor_bank"`
	ToPartyID                             null.Int          `boil:"to_party_id" json:"to_party_id,omitempty" toml:"to_party_id" yaml:"to_party_id,omitempty"`
	ToBankID                              null.Int          `boil:"to_bank_id" json:"to_bank_id,omitempty" toml:"to_bank_id" yaml:"to_bank_id,omitempty"`
	CreditorAgentSchemename               null.String       `boil:"creditor_agent_schemename" json:"creditor_agent_schemename,omitempty" toml:"creditor_agent_schemename" yaml:"creditor_agent_schemename,omitempty"`
	CreditorAgentIdentification           null.String       `boil:"creditor_agent_identification" json:"creditor_agent_identification,omitempty" toml:"creditor_agent_identification" yaml:"creditor_agent_identification,omitempty"`
	CreditorAccountSchemename             string            `boil:"creditor_account_schemename" json:"creditor_account_schemename" toml:"creditor_account_schemename" yaml:"creditor_account_schemename"`
	CreditorAccountIdentification         string            `boil:"creditor_account_identification" json:"creditor_account_identification" toml:"creditor_account_identification" yaml:"creditor_account_identification"`
	CreditorAccountName                   string            `boil:"creditor_account_name" json:"creditor_account_name" toml:"creditor_account_name" yaml:"creditor_account_name"`
	CreditorSecondaryIdentification       string            `boil:"creditor_secondary_identification" json:"creditor_secondary_identification" toml:"creditor_secondary_identification" yaml:"creditor_secondary_identification"`
	RemittanceReference                   null.String       `boil:"remittance_reference" json:"remittance_reference,omitempty" toml:"remittance_reference" yaml:"remittance_reference,omitempty"`
	RemittanceUnstructuredReference       null.String       `boil:"remittance_unstructured_reference" json:"remittance_unstructured_reference,omitempty" toml:"remittance_unstructured_reference" yaml:"remittance_unstructured_reference,omitempty"`
	RiskPaymentContextCode                null.String       `boil:"risk_payment_context_code" json:"risk_payment_context_code,omitempty" toml:"risk_payment_context_code" yaml:"risk_payment_context_code,omitempty"`
	RiskMerchantCategoryCode              null.String       `boil:"risk_merchant_category_code" json:"risk_merchant_category_code,omitempty" toml:"risk_merchant_category_code" yaml:"risk_merchant_category_code,omitempty"`
	RiskMerchantCustomerIdentification    null.String       `boil:"risk_merchant_customer_identification" json:"risk_merchant_customer_identification,omitempty" toml:"risk_merchant_customer_identification" yaml:"risk_merchant_customer_identification,omitempty"`
	RiskDeliveryAddressLine1              null.String       `boil:"risk_delivery_address_line1" json:"risk_delivery_address_line1,omitempty" toml:"risk_delivery_address_line1" yaml:"risk_delivery_address_line1,omitempty"`
	RiskDeliveryAddressLine2              null.String       `boil:"risk_delivery_address_line2" json:"risk_delivery_address_line2,omitempty" toml:"risk_delivery_address_line2" yaml:"risk_delivery_address_line2,omitempty"`
	RiskDeliveryAddressStreetName         null.String       `boil:"risk_delivery_address_streetName" json:"risk_delivery_address_streetName,omitempty" toml:"risk_delivery_address_streetName" yaml:"risk_delivery_address_streetName,omitempty"`
	RiskDeliveryAddressBuildingNumber     null.String       `boil:"risk_delivery_address_building_number" json:"risk_delivery_address_building_number,omitempty" toml:"risk_delivery_address_building_number" yaml:"risk_delivery_address_building_number,omitempty"`
	RiskDeliveryAddressPostcode           null.String       `boil:"risk_delivery_address_postcode" json:"risk_delivery_address_postcode,omitempty" toml:"risk_delivery_address_postcode" yaml:"risk_delivery_address_postcode,omitempty"`
	RiskDeliveryAddressTownname           null.String       `boil:"risk_delivery_address_townname" json:"risk_delivery_address_townname,omitempty" toml:"risk_delivery_address_townname" yaml:"risk_delivery_address_townname,omitempty"`
	RiskDeliveryAddressCountySubdivision  null.String       `boil:"risk_delivery_address_county_subdivision" json:"risk_delivery_address_county_subdivision,omitempty" toml:"risk_delivery_address_county_subdivision" yaml:"risk_delivery_address_county_subdivision,omitempty"`
	RiskDeliveryAddressCountry            null.String       `boil:"risk_delivery_address_country" json:"risk_delivery_address_country,omitempty" toml:"risk_delivery_address_country" yaml:"risk_delivery_address_country,omitempty"`
	InternalStatus                        string            `boil:"internal_status" json:"internal_status" toml:"internal_status" yaml:"internal_status"`
	InternalStatusErrorCode               null.String       `boil:"internal_status_error_code" json:"internal_status_error_code,omitempty" toml:"internal_status_error_code" yaml:"internal_status_error_code,omitempty"`
	PaymentStatus                         string            `boil:"payment_status" json:"payment_status" toml:"payment_status" yaml:"payment_status"`
	PaymentSetupStatus                    null.String       `boil:"payment_setup_status" json:"payment_setup_status,omitempty" toml:"payment_setup_status" yaml:"payment_setup_status,omitempty"`
	PaymentSubmissionStatus               null.String       `boil:"payment_submission_status" json:"payment_submission_status,omitempty" toml:"payment_submission_status" yaml:"payment_submission_status,omitempty"`
	GatewayID                             null.Int          `boil:"gateway_id" json:"gateway_id,omitempty" toml:"gateway_id" yaml:"gateway_id,omitempty"`
	PaymentPeriod                         null.Int          `boil:"payment_period" json:"payment_period,omitempty" toml:"payment_period" yaml:"payment_period,omitempty"`
	PaymentNotes                          null.String       `boil:"payment_notes" json:"payment_notes,omitempty" toml:"payment_notes" yaml:"payment_notes,omitempty"`
	PaymentMethod                         null.String       `boil:"payment_method" json:"payment_method,omitempty" toml:"payment_method" yaml:"payment_method,omitempty"`
	PaymentMode                           null.String       `boil:"payment_mode" json:"payment_mode,omitempty" toml:"payment_mode" yaml:"payment_mode,omitempty"`
	PaymentMethodCode                     null.Int          `boil:"payment_method_code" json:"payment_method_code,omitempty" toml:"payment_method_code" yaml:"payment_method_code,omitempty"`
	PaymentType                           null.String       `boil:"payment_type" json:"payment_type,omitempty" toml:"payment_type" yaml:"payment_type,omitempty"`
	TransferType                          null.String       `boil:"transfer_type" json:"transfer_type,omitempty" toml:"transfer_type" yaml:"transfer_type,omitempty"`
	TransferMode                          null.String       `boil:"transfer_mode" json:"transfer_mode,omitempty" toml:"transfer_mode" yaml:"transfer_mode,omitempty"`
	CreationDateTime                      null.Time         `boil:"creation_date_time" json:"creation_date_time,omitempty" toml:"creation_date_time" yaml:"creation_date_time,omitempty"`
	AuthorizationStatus                   null.String       `boil:"authorization_status" json:"authorization_status,omitempty" toml:"authorization_status" yaml:"authorization_status,omitempty"`
	AuthorizationDecision                 null.String       `boil:"authorization_decision" json:"authorization_decision,omitempty" toml:"authorization_decision" yaml:"authorization_decision,omitempty"`
	AuthorizationNumber                   null.String       `boil:"authorization_number" json:"authorization_number,omitempty" toml:"authorization_number" yaml:"authorization_number,omitempty"`
	AuthorizationResponse                 null.String       `boil:"authorization_response" json:"authorization_response,omitempty" toml:"authorization_response" yaml:"authorization_response,omitempty"`
	SecondaryIdentification               null.String       `boil:"secondary_identification" json:"secondary_identification,omitempty" toml:"secondary_identification" yaml:"secondary_identification,omitempty"`
	OrderNumber                           null.String       `boil:"order_number" json:"order_number,omitempty" toml:"order_number" yaml:"order_number,omitempty"`
	OrderDateTime                         null.Time         `boil:"order_date_time" json:"order_date_time,omitempty" toml:"order_date_time" yaml:"order_date_time,omitempty"`
	OrderDescription                      null.String       `boil:"order_description" json:"order_description,omitempty" toml:"order_description" yaml:"order_description,omitempty"`
	OrderUnitCount                        null.Int          `boil:"order_unit_count" json:"order_unit_count,omitempty" toml:"order_unit_count" yaml:"order_unit_count,omitempty"`
	OrderCurrency                         null.String       `boil:"order_currency" json:"order_currency,omitempty" toml:"order_currency" yaml:"order_currency,omitempty"`
	OrderCurrencyExponent                 types.NullDecimal `boil:"order_currency_exponent" json:"order_currency_exponent,omitempty" toml:"order_currency_exponent" yaml:"order_currency_exponent,omitempty"`
	OrderCommissionPercentage             types.NullDecimal `boil:"order_commission_percentage" json:"order_commission_percentage,omitempty" toml:"order_commission_percentage" yaml:"order_commission_percentage,omitempty"`
	OrderDiscountPercentage               types.NullDecimal `boil:"order_discount_percentage" json:"order_discount_percentage,omitempty" toml:"order_discount_percentage" yaml:"order_discount_percentage,omitempty"`
	OrderVatPercentage                    types.NullDecimal `boil:"order_vat_percentage" json:"order_vat_percentage,omitempty" toml:"order_vat_percentage" yaml:"order_vat_percentage,omitempty"`
	OrderGrossAmount                      types.NullDecimal `boil:"order_gross_amount" json:"order_gross_amount,omitempty" toml:"order_gross_amount" yaml:"order_gross_amount,omitempty"`
	OrderNetAmount                        types.NullDecimal `boil:"order_net_amount" json:"order_net_amount,omitempty" toml:"order_net_amount" yaml:"order_net_amount,omitempty"`
	OrderVatAmount                        types.NullDecimal `boil:"order_vat_amount" json:"order_vat_amount,omitempty" toml:"order_vat_amount" yaml:"order_vat_amount,omitempty"`
	OrderHomeCurrency                     null.String       `boil:"order_home_currency" json:"order_home_currency,omitempty" toml:"order_home_currency" yaml:"order_home_currency,omitempty"`
	OrderHomeCurrencyExponent             types.NullDecimal `boil:"order_home_currency_exponent" json:"order_home_currency_exponent,omitempty" toml:"order_home_currency_exponent" yaml:"order_home_currency_exponent,omitempty"`
	OrderHomeCurrencyOrderAmount          types.NullDecimal `boil:"order_home_currency_order_amount" json:"order_home_currency_order_amount,omitempty" toml:"order_home_currency_order_amount" yaml:"order_home_currency_order_amount,omitempty"`
	OrderExchangeRate                     types.NullDecimal `boil:"order_exchange_rate" json:"order_exchange_rate,omitempty" toml:"order_exchange_rate" yaml:"order_exchange_rate,omitempty"`
	OrderRecurringPayment                 types.NullDecimal `boil:"order_recurring_payment" json:"order_recurring_payment,omitempty" toml:"order_recurring_payment" yaml:"order_recurring_payment,omitempty"`
	OrderRecurringFrequency               null.Int          `boil:"order_recurring_frequency" json:"order_recurring_frequency,omitempty" toml:"order_recurring_frequency" yaml:"order_recurring_frequency,omitempty"`
	OrderInstallments                     null.Int          `boil:"order_installments" json:"order_installments,omitempty" toml:"order_installments" yaml:"order_installments,omitempty"`
	OrderRecurringExpiry                  null.Time         `boil:"order_recurring_expiry" json:"order_recurring_expiry,omitempty" toml:"order_recurring_expiry" yaml:"order_recurring_expiry,omitempty"`
	OrderRecurringPaymentSubscriptionName null.String       `boil:"order_recurring_payment_subscription_name" json:"order_recurring_payment_subscription_name,omitempty" toml:"order_recurring_payment_subscription_name" yaml:"order_recurring_payment_subscription_name,omitempty"`
	OrderRecurringPaymentSubscriptionCode null.String       `boil:"order_recurring_payment_subscription_code" json:"order_recurring_payment_subscription_code,omitempty" toml:"order_recurring_payment_subscription_code" yaml:"order_recurring_payment_subscription_code,omitempty"`
	MakerDate                             time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                           time.Time         `boil:"checker_date" json:"checker_date" toml:"checker_date" yaml:"checker_date"`
	MakerID                               string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                             null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                            null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate                          null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *paymentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L paymentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PaymentColumns = struct {
	PaymentID                             string
	ValueDate                             string
	PaymentRefID                          string
	PaymentSubmissionID                   string
	SchemePaymentID                       string
	InstructionIdentification             string
	EndToEndIdentification                string
	TransactionAmount                     string
	TransactionCurrency                   string
	FromBankID                            string
	DebtorBank                            string
	FromPartyID                           string
	DebtorAgentSchemeName                 string
	DebtorAgentIdentification             string
	DebtorAccountSchemename               string
	DebtorAccountIdentification           string
	DebtorAccountSecondaryIdentification  string
	DebtorAccountName                     string
	CreditorBank                          string
	ToPartyID                             string
	ToBankID                              string
	CreditorAgentSchemename               string
	CreditorAgentIdentification           string
	CreditorAccountSchemename             string
	CreditorAccountIdentification         string
	CreditorAccountName                   string
	CreditorSecondaryIdentification       string
	RemittanceReference                   string
	RemittanceUnstructuredReference       string
	RiskPaymentContextCode                string
	RiskMerchantCategoryCode              string
	RiskMerchantCustomerIdentification    string
	RiskDeliveryAddressLine1              string
	RiskDeliveryAddressLine2              string
	RiskDeliveryAddressStreetName         string
	RiskDeliveryAddressBuildingNumber     string
	RiskDeliveryAddressPostcode           string
	RiskDeliveryAddressTownname           string
	RiskDeliveryAddressCountySubdivision  string
	RiskDeliveryAddressCountry            string
	InternalStatus                        string
	InternalStatusErrorCode               string
	PaymentStatus                         string
	PaymentSetupStatus                    string
	PaymentSubmissionStatus               string
	GatewayID                             string
	PaymentPeriod                         string
	PaymentNotes                          string
	PaymentMethod                         string
	PaymentMode                           string
	PaymentMethodCode                     string
	PaymentType                           string
	TransferType                          string
	TransferMode                          string
	CreationDateTime                      string
	AuthorizationStatus                   string
	AuthorizationDecision                 string
	AuthorizationNumber                   string
	AuthorizationResponse                 string
	SecondaryIdentification               string
	OrderNumber                           string
	OrderDateTime                         string
	OrderDescription                      string
	OrderUnitCount                        string
	OrderCurrency                         string
	OrderCurrencyExponent                 string
	OrderCommissionPercentage             string
	OrderDiscountPercentage               string
	OrderVatPercentage                    string
	OrderGrossAmount                      string
	OrderNetAmount                        string
	OrderVatAmount                        string
	OrderHomeCurrency                     string
	OrderHomeCurrencyExponent             string
	OrderHomeCurrencyOrderAmount          string
	OrderExchangeRate                     string
	OrderRecurringPayment                 string
	OrderRecurringFrequency               string
	OrderInstallments                     string
	OrderRecurringExpiry                  string
	OrderRecurringPaymentSubscriptionName string
	OrderRecurringPaymentSubscriptionCode string
	MakerDate                             string
	CheckerDate                           string
	MakerID                               string
	CheckerID                             string
	ModifiedBy                            string
	ModifiedDate                          string
}{
	PaymentID:                             "payment_id",
	ValueDate:                             "value_date",
	PaymentRefID:                          "payment_ref_id",
	PaymentSubmissionID:                   "payment_submission_id",
	SchemePaymentID:                       "scheme_payment_id",
	InstructionIdentification:             "instruction_identification",
	EndToEndIdentification:                "end_to_end_identification",
	TransactionAmount:                     "transaction_amount",
	TransactionCurrency:                   "transaction_currency",
	FromBankID:                            "from_bank_id",
	DebtorBank:                            "debtor_bank",
	FromPartyID:                           "from_party_id",
	DebtorAgentSchemeName:                 "debtor_agent_scheme_name",
	DebtorAgentIdentification:             "debtor_agent_identification",
	DebtorAccountSchemename:               "debtor_account_schemename",
	DebtorAccountIdentification:           "debtor_account_identification",
	DebtorAccountSecondaryIdentification:  "debtor_account_secondary_identification",
	DebtorAccountName:                     "debtor_account_name",
	CreditorBank:                          "creditor_bank",
	ToPartyID:                             "to_party_id",
	ToBankID:                              "to_bank_id",
	CreditorAgentSchemename:               "creditor_agent_schemename",
	CreditorAgentIdentification:           "creditor_agent_identification",
	CreditorAccountSchemename:             "creditor_account_schemename",
	CreditorAccountIdentification:         "creditor_account_identification",
	CreditorAccountName:                   "creditor_account_name",
	CreditorSecondaryIdentification:       "creditor_secondary_identification",
	RemittanceReference:                   "remittance_reference",
	RemittanceUnstructuredReference:       "remittance_unstructured_reference",
	RiskPaymentContextCode:                "risk_payment_context_code",
	RiskMerchantCategoryCode:              "risk_merchant_category_code",
	RiskMerchantCustomerIdentification:    "risk_merchant_customer_identification",
	RiskDeliveryAddressLine1:              "risk_delivery_address_line1",
	RiskDeliveryAddressLine2:              "risk_delivery_address_line2",
	RiskDeliveryAddressStreetName:         "risk_delivery_address_streetName",
	RiskDeliveryAddressBuildingNumber:     "risk_delivery_address_building_number",
	RiskDeliveryAddressPostcode:           "risk_delivery_address_postcode",
	RiskDeliveryAddressTownname:           "risk_delivery_address_townname",
	RiskDeliveryAddressCountySubdivision:  "risk_delivery_address_county_subdivision",
	RiskDeliveryAddressCountry:            "risk_delivery_address_country",
	InternalStatus:                        "internal_status",
	InternalStatusErrorCode:               "internal_status_error_code",
	PaymentStatus:                         "payment_status",
	PaymentSetupStatus:                    "payment_setup_status",
	PaymentSubmissionStatus:               "payment_submission_status",
	GatewayID:                             "gateway_id",
	PaymentPeriod:                         "payment_period",
	PaymentNotes:                          "payment_notes",
	PaymentMethod:                         "payment_method",
	PaymentMode:                           "payment_mode",
	PaymentMethodCode:                     "payment_method_code",
	PaymentType:                           "payment_type",
	TransferType:                          "transfer_type",
	TransferMode:                          "transfer_mode",
	CreationDateTime:                      "creation_date_time",
	AuthorizationStatus:                   "authorization_status",
	AuthorizationDecision:                 "authorization_decision",
	AuthorizationNumber:                   "authorization_number",
	AuthorizationResponse:                 "authorization_response",
	SecondaryIdentification:               "secondary_identification",
	OrderNumber:                           "order_number",
	OrderDateTime:                         "order_date_time",
	OrderDescription:                      "order_description",
	OrderUnitCount:                        "order_unit_count",
	OrderCurrency:                         "order_currency",
	OrderCurrencyExponent:                 "order_currency_exponent",
	OrderCommissionPercentage:             "order_commission_percentage",
	OrderDiscountPercentage:               "order_discount_percentage",
	OrderVatPercentage:                    "order_vat_percentage",
	OrderGrossAmount:                      "order_gross_amount",
	OrderNetAmount:                        "order_net_amount",
	OrderVatAmount:                        "order_vat_amount",
	OrderHomeCurrency:                     "order_home_currency",
	OrderHomeCurrencyExponent:             "order_home_currency_exponent",
	OrderHomeCurrencyOrderAmount:          "order_home_currency_order_amount",
	OrderExchangeRate:                     "order_exchange_rate",
	OrderRecurringPayment:                 "order_recurring_payment",
	OrderRecurringFrequency:               "order_recurring_frequency",
	OrderInstallments:                     "order_installments",
	OrderRecurringExpiry:                  "order_recurring_expiry",
	OrderRecurringPaymentSubscriptionName: "order_recurring_payment_subscription_name",
	OrderRecurringPaymentSubscriptionCode: "order_recurring_payment_subscription_code",
	MakerDate:                             "maker_date",
	CheckerDate:                           "checker_date",
	MakerID:                               "maker_id",
	CheckerID:                             "checker_id",
	ModifiedBy:                            "modified_by",
	ModifiedDate:                          "modified_date",
}

// Generated where

var PaymentWhere = struct {
	PaymentID                             whereHelperint
	ValueDate                             whereHelpertime_Time
	PaymentRefID                          whereHelperstring
	PaymentSubmissionID                   whereHelpernull_String
	SchemePaymentID                       whereHelpernull_String
	InstructionIdentification             whereHelperstring
	EndToEndIdentification                whereHelperstring
	TransactionAmount                     whereHelpertypes_Decimal
	TransactionCurrency                   whereHelperstring
	FromBankID                            whereHelpernull_Int
	DebtorBank                            whereHelperstring
	FromPartyID                           whereHelpernull_Int
	DebtorAgentSchemeName                 whereHelpernull_String
	DebtorAgentIdentification             whereHelpernull_String
	DebtorAccountSchemename               whereHelperstring
	DebtorAccountIdentification           whereHelperstring
	DebtorAccountSecondaryIdentification  whereHelperstring
	DebtorAccountName                     whereHelperstring
	CreditorBank                          whereHelperstring
	ToPartyID                             whereHelpernull_Int
	ToBankID                              whereHelpernull_Int
	CreditorAgentSchemename               whereHelpernull_String
	CreditorAgentIdentification           whereHelpernull_String
	CreditorAccountSchemename             whereHelperstring
	CreditorAccountIdentification         whereHelperstring
	CreditorAccountName                   whereHelperstring
	CreditorSecondaryIdentification       whereHelperstring
	RemittanceReference                   whereHelpernull_String
	RemittanceUnstructuredReference       whereHelpernull_String
	RiskPaymentContextCode                whereHelpernull_String
	RiskMerchantCategoryCode              whereHelpernull_String
	RiskMerchantCustomerIdentification    whereHelpernull_String
	RiskDeliveryAddressLine1              whereHelpernull_String
	RiskDeliveryAddressLine2              whereHelpernull_String
	RiskDeliveryAddressStreetName         whereHelpernull_String
	RiskDeliveryAddressBuildingNumber     whereHelpernull_String
	RiskDeliveryAddressPostcode           whereHelpernull_String
	RiskDeliveryAddressTownname           whereHelpernull_String
	RiskDeliveryAddressCountySubdivision  whereHelpernull_String
	RiskDeliveryAddressCountry            whereHelpernull_String
	InternalStatus                        whereHelperstring
	InternalStatusErrorCode               whereHelpernull_String
	PaymentStatus                         whereHelperstring
	PaymentSetupStatus                    whereHelpernull_String
	PaymentSubmissionStatus               whereHelpernull_String
	GatewayID                             whereHelpernull_Int
	PaymentPeriod                         whereHelpernull_Int
	PaymentNotes                          whereHelpernull_String
	PaymentMethod                         whereHelpernull_String
	PaymentMode                           whereHelpernull_String
	PaymentMethodCode                     whereHelpernull_Int
	PaymentType                           whereHelpernull_String
	TransferType                          whereHelpernull_String
	TransferMode                          whereHelpernull_String
	CreationDateTime                      whereHelpernull_Time
	AuthorizationStatus                   whereHelpernull_String
	AuthorizationDecision                 whereHelpernull_String
	AuthorizationNumber                   whereHelpernull_String
	AuthorizationResponse                 whereHelpernull_String
	SecondaryIdentification               whereHelpernull_String
	OrderNumber                           whereHelpernull_String
	OrderDateTime                         whereHelpernull_Time
	OrderDescription                      whereHelpernull_String
	OrderUnitCount                        whereHelpernull_Int
	OrderCurrency                         whereHelpernull_String
	OrderCurrencyExponent                 whereHelpertypes_NullDecimal
	OrderCommissionPercentage             whereHelpertypes_NullDecimal
	OrderDiscountPercentage               whereHelpertypes_NullDecimal
	OrderVatPercentage                    whereHelpertypes_NullDecimal
	OrderGrossAmount                      whereHelpertypes_NullDecimal
	OrderNetAmount                        whereHelpertypes_NullDecimal
	OrderVatAmount                        whereHelpertypes_NullDecimal
	OrderHomeCurrency                     whereHelpernull_String
	OrderHomeCurrencyExponent             whereHelpertypes_NullDecimal
	OrderHomeCurrencyOrderAmount          whereHelpertypes_NullDecimal
	OrderExchangeRate                     whereHelpertypes_NullDecimal
	OrderRecurringPayment                 whereHelpertypes_NullDecimal
	OrderRecurringFrequency               whereHelpernull_Int
	OrderInstallments                     whereHelpernull_Int
	OrderRecurringExpiry                  whereHelpernull_Time
	OrderRecurringPaymentSubscriptionName whereHelpernull_String
	OrderRecurringPaymentSubscriptionCode whereHelpernull_String
	MakerDate                             whereHelpertime_Time
	CheckerDate                           whereHelpertime_Time
	MakerID                               whereHelperstring
	CheckerID                             whereHelpernull_String
	ModifiedBy                            whereHelpernull_String
	ModifiedDate                          whereHelpernull_Time
}{
	PaymentID:                             whereHelperint{field: `payment_id`},
	ValueDate:                             whereHelpertime_Time{field: `value_date`},
	PaymentRefID:                          whereHelperstring{field: `payment_ref_id`},
	PaymentSubmissionID:                   whereHelpernull_String{field: `payment_submission_id`},
	SchemePaymentID:                       whereHelpernull_String{field: `scheme_payment_id`},
	InstructionIdentification:             whereHelperstring{field: `instruction_identification`},
	EndToEndIdentification:                whereHelperstring{field: `end_to_end_identification`},
	TransactionAmount:                     whereHelpertypes_Decimal{field: `transaction_amount`},
	TransactionCurrency:                   whereHelperstring{field: `transaction_currency`},
	FromBankID:                            whereHelpernull_Int{field: `from_bank_id`},
	DebtorBank:                            whereHelperstring{field: `debtor_bank`},
	FromPartyID:                           whereHelpernull_Int{field: `from_party_id`},
	DebtorAgentSchemeName:                 whereHelpernull_String{field: `debtor_agent_scheme_name`},
	DebtorAgentIdentification:             whereHelpernull_String{field: `debtor_agent_identification`},
	DebtorAccountSchemename:               whereHelperstring{field: `debtor_account_schemename`},
	DebtorAccountIdentification:           whereHelperstring{field: `debtor_account_identification`},
	DebtorAccountSecondaryIdentification:  whereHelperstring{field: `debtor_account_secondary_identification`},
	DebtorAccountName:                     whereHelperstring{field: `debtor_account_name`},
	CreditorBank:                          whereHelperstring{field: `creditor_bank`},
	ToPartyID:                             whereHelpernull_Int{field: `to_party_id`},
	ToBankID:                              whereHelpernull_Int{field: `to_bank_id`},
	CreditorAgentSchemename:               whereHelpernull_String{field: `creditor_agent_schemename`},
	CreditorAgentIdentification:           whereHelpernull_String{field: `creditor_agent_identification`},
	CreditorAccountSchemename:             whereHelperstring{field: `creditor_account_schemename`},
	CreditorAccountIdentification:         whereHelperstring{field: `creditor_account_identification`},
	CreditorAccountName:                   whereHelperstring{field: `creditor_account_name`},
	CreditorSecondaryIdentification:       whereHelperstring{field: `creditor_secondary_identification`},
	RemittanceReference:                   whereHelpernull_String{field: `remittance_reference`},
	RemittanceUnstructuredReference:       whereHelpernull_String{field: `remittance_unstructured_reference`},
	RiskPaymentContextCode:                whereHelpernull_String{field: `risk_payment_context_code`},
	RiskMerchantCategoryCode:              whereHelpernull_String{field: `risk_merchant_category_code`},
	RiskMerchantCustomerIdentification:    whereHelpernull_String{field: `risk_merchant_customer_identification`},
	RiskDeliveryAddressLine1:              whereHelpernull_String{field: `risk_delivery_address_line1`},
	RiskDeliveryAddressLine2:              whereHelpernull_String{field: `risk_delivery_address_line2`},
	RiskDeliveryAddressStreetName:         whereHelpernull_String{field: `risk_delivery_address_streetName`},
	RiskDeliveryAddressBuildingNumber:     whereHelpernull_String{field: `risk_delivery_address_building_number`},
	RiskDeliveryAddressPostcode:           whereHelpernull_String{field: `risk_delivery_address_postcode`},
	RiskDeliveryAddressTownname:           whereHelpernull_String{field: `risk_delivery_address_townname`},
	RiskDeliveryAddressCountySubdivision:  whereHelpernull_String{field: `risk_delivery_address_county_subdivision`},
	RiskDeliveryAddressCountry:            whereHelpernull_String{field: `risk_delivery_address_country`},
	InternalStatus:                        whereHelperstring{field: `internal_status`},
	InternalStatusErrorCode:               whereHelpernull_String{field: `internal_status_error_code`},
	PaymentStatus:                         whereHelperstring{field: `payment_status`},
	PaymentSetupStatus:                    whereHelpernull_String{field: `payment_setup_status`},
	PaymentSubmissionStatus:               whereHelpernull_String{field: `payment_submission_status`},
	GatewayID:                             whereHelpernull_Int{field: `gateway_id`},
	PaymentPeriod:                         whereHelpernull_Int{field: `payment_period`},
	PaymentNotes:                          whereHelpernull_String{field: `payment_notes`},
	PaymentMethod:                         whereHelpernull_String{field: `payment_method`},
	PaymentMode:                           whereHelpernull_String{field: `payment_mode`},
	PaymentMethodCode:                     whereHelpernull_Int{field: `payment_method_code`},
	PaymentType:                           whereHelpernull_String{field: `payment_type`},
	TransferType:                          whereHelpernull_String{field: `transfer_type`},
	TransferMode:                          whereHelpernull_String{field: `transfer_mode`},
	CreationDateTime:                      whereHelpernull_Time{field: `creation_date_time`},
	AuthorizationStatus:                   whereHelpernull_String{field: `authorization_status`},
	AuthorizationDecision:                 whereHelpernull_String{field: `authorization_decision`},
	AuthorizationNumber:                   whereHelpernull_String{field: `authorization_number`},
	AuthorizationResponse:                 whereHelpernull_String{field: `authorization_response`},
	SecondaryIdentification:               whereHelpernull_String{field: `secondary_identification`},
	OrderNumber:                           whereHelpernull_String{field: `order_number`},
	OrderDateTime:                         whereHelpernull_Time{field: `order_date_time`},
	OrderDescription:                      whereHelpernull_String{field: `order_description`},
	OrderUnitCount:                        whereHelpernull_Int{field: `order_unit_count`},
	OrderCurrency:                         whereHelpernull_String{field: `order_currency`},
	OrderCurrencyExponent:                 whereHelpertypes_NullDecimal{field: `order_currency_exponent`},
	OrderCommissionPercentage:             whereHelpertypes_NullDecimal{field: `order_commission_percentage`},
	OrderDiscountPercentage:               whereHelpertypes_NullDecimal{field: `order_discount_percentage`},
	OrderVatPercentage:                    whereHelpertypes_NullDecimal{field: `order_vat_percentage`},
	OrderGrossAmount:                      whereHelpertypes_NullDecimal{field: `order_gross_amount`},
	OrderNetAmount:                        whereHelpertypes_NullDecimal{field: `order_net_amount`},
	OrderVatAmount:                        whereHelpertypes_NullDecimal{field: `order_vat_amount`},
	OrderHomeCurrency:                     whereHelpernull_String{field: `order_home_currency`},
	OrderHomeCurrencyExponent:             whereHelpertypes_NullDecimal{field: `order_home_currency_exponent`},
	OrderHomeCurrencyOrderAmount:          whereHelpertypes_NullDecimal{field: `order_home_currency_order_amount`},
	OrderExchangeRate:                     whereHelpertypes_NullDecimal{field: `order_exchange_rate`},
	OrderRecurringPayment:                 whereHelpertypes_NullDecimal{field: `order_recurring_payment`},
	OrderRecurringFrequency:               whereHelpernull_Int{field: `order_recurring_frequency`},
	OrderInstallments:                     whereHelpernull_Int{field: `order_installments`},
	OrderRecurringExpiry:                  whereHelpernull_Time{field: `order_recurring_expiry`},
	OrderRecurringPaymentSubscriptionName: whereHelpernull_String{field: `order_recurring_payment_subscription_name`},
	OrderRecurringPaymentSubscriptionCode: whereHelpernull_String{field: `order_recurring_payment_subscription_code`},
	MakerDate:                             whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                           whereHelpertime_Time{field: `checker_date`},
	MakerID:                               whereHelperstring{field: `maker_id`},
	CheckerID:                             whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                            whereHelpernull_String{field: `modified_by`},
	ModifiedDate:                          whereHelpernull_Time{field: `modified_date`},
}

// PaymentRels is where relationship names are stored.
var PaymentRels = struct {
	PaymentMethodCode      string
	PaymentPaymentAches    string
	PaymentPaymentBills    string
	PaymentPaymentCheques  string
	PaymentPaymentFxTrades string
	PaymentPaymentGateways string
	PaymentPaymentLoans    string
	PaymentPaymentMessages string
	PaymentPaymentRtps     string
	PaymentPaymentWires    string
}{
	PaymentMethodCode:      "PaymentMethodCode",
	PaymentPaymentAches:    "PaymentPaymentAches",
	PaymentPaymentBills:    "PaymentPaymentBills",
	PaymentPaymentCheques:  "PaymentPaymentCheques",
	PaymentPaymentFxTrades: "PaymentPaymentFxTrades",
	PaymentPaymentGateways: "PaymentPaymentGateways",
	PaymentPaymentLoans:    "PaymentPaymentLoans",
	PaymentPaymentMessages: "PaymentPaymentMessages",
	PaymentPaymentRtps:     "PaymentPaymentRtps",
	PaymentPaymentWires:    "PaymentPaymentWires",
}

// paymentR is where relationships are stored.
type paymentR struct {
	PaymentMethodCode      *PaymentMethod
	PaymentPaymentAches    PaymentAchSlice
	PaymentPaymentBills    PaymentBillSlice
	PaymentPaymentCheques  PaymentChequeSlice
	PaymentPaymentFxTrades PaymentFxTradeSlice
	PaymentPaymentGateways PaymentGatewaySlice
	PaymentPaymentLoans    PaymentLoanSlice
	PaymentPaymentMessages PaymentMessageSlice
	PaymentPaymentRtps     PaymentRtpSlice
	PaymentPaymentWires    PaymentWireSlice
}

// NewStruct creates a new relationship struct
func (*paymentR) NewStruct() *paymentR {
	return &paymentR{}
}

// paymentL is where Load methods for each relationship are stored.
type paymentL struct{}

var (
	paymentColumns               = []string{"payment_id", "value_date", "payment_ref_id", "payment_submission_id", "scheme_payment_id", "instruction_identification", "end_to_end_identification", "transaction_amount", "transaction_currency", "from_bank_id", "debtor_bank", "from_party_id", "debtor_agent_scheme_name", "debtor_agent_identification", "debtor_account_schemename", "debtor_account_identification", "debtor_account_secondary_identification", "debtor_account_name", "creditor_bank", "to_party_id", "to_bank_id", "creditor_agent_schemename", "creditor_agent_identification", "creditor_account_schemename", "creditor_account_identification", "creditor_account_name", "creditor_secondary_identification", "remittance_reference", "remittance_unstructured_reference", "risk_payment_context_code", "risk_merchant_category_code", "risk_merchant_customer_identification", "risk_delivery_address_line1", "risk_delivery_address_line2", "risk_delivery_address_streetName", "risk_delivery_address_building_number", "risk_delivery_address_postcode", "risk_delivery_address_townname", "risk_delivery_address_county_subdivision", "risk_delivery_address_country", "internal_status", "internal_status_error_code", "payment_status", "payment_setup_status", "payment_submission_status", "gateway_id", "payment_period", "payment_notes", "payment_method", "payment_mode", "payment_method_code", "payment_type", "transfer_type", "transfer_mode", "creation_date_time", "authorization_status", "authorization_decision", "authorization_number", "authorization_response", "secondary_identification", "order_number", "order_date_time", "order_description", "order_unit_count", "order_currency", "order_currency_exponent", "order_commission_percentage", "order_discount_percentage", "order_vat_percentage", "order_gross_amount", "order_net_amount", "order_vat_amount", "order_home_currency", "order_home_currency_exponent", "order_home_currency_order_amount", "order_exchange_rate", "order_recurring_payment", "order_recurring_frequency", "order_installments", "order_recurring_expiry", "order_recurring_payment_subscription_name", "order_recurring_payment_subscription_code", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentColumnsWithoutDefault = []string{"value_date", "payment_ref_id", "payment_submission_id", "scheme_payment_id", "instruction_identification", "end_to_end_identification", "transaction_amount", "transaction_currency", "from_bank_id", "debtor_bank", "from_party_id", "debtor_agent_scheme_name", "debtor_agent_identification", "debtor_account_schemename", "debtor_account_identification", "debtor_account_secondary_identification", "debtor_account_name", "creditor_bank", "to_party_id", "to_bank_id", "creditor_agent_schemename", "creditor_agent_identification", "creditor_account_schemename", "creditor_account_identification", "creditor_account_name", "creditor_secondary_identification", "remittance_reference", "remittance_unstructured_reference", "risk_payment_context_code", "risk_merchant_category_code", "risk_merchant_customer_identification", "risk_delivery_address_line1", "risk_delivery_address_line2", "risk_delivery_address_streetName", "risk_delivery_address_building_number", "risk_delivery_address_postcode", "risk_delivery_address_townname", "risk_delivery_address_county_subdivision", "risk_delivery_address_country", "internal_status", "internal_status_error_code", "payment_status", "payment_setup_status", "payment_submission_status", "gateway_id", "payment_period", "payment_notes", "payment_method", "payment_mode", "payment_method_code", "payment_type", "transfer_type", "transfer_mode", "creation_date_time", "authorization_status", "authorization_decision", "authorization_number", "authorization_response", "secondary_identification", "order_number", "order_date_time", "order_description", "order_unit_count", "order_currency", "order_currency_exponent", "order_commission_percentage", "order_discount_percentage", "order_vat_percentage", "order_gross_amount", "order_net_amount", "order_vat_amount", "order_home_currency", "order_home_currency_exponent", "order_home_currency_order_amount", "order_exchange_rate", "order_recurring_payment", "order_recurring_frequency", "order_installments", "order_recurring_expiry", "order_recurring_payment_subscription_name", "order_recurring_payment_subscription_code", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentColumnsWithDefault    = []string{"payment_id"}
	paymentPrimaryKeyColumns     = []string{"payment_id"}
)

type (
	// PaymentSlice is an alias for a slice of pointers to Payment.
	// This should generally be used opposed to []Payment.
	PaymentSlice []*Payment
	// PaymentHook is the signature for custom Payment hook methods
	PaymentHook func(context.Context, boil.ContextExecutor, *Payment) error

	paymentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	paymentType                 = reflect.TypeOf(&Payment{})
	paymentMapping              = queries.MakeStructMapping(paymentType)
	paymentPrimaryKeyMapping, _ = queries.BindMapping(paymentType, paymentMapping, paymentPrimaryKeyColumns)
	paymentInsertCacheMut       sync.RWMutex
	paymentInsertCache          = make(map[string]insertCache)
	paymentUpdateCacheMut       sync.RWMutex
	paymentUpdateCache          = make(map[string]updateCache)
	paymentUpsertCacheMut       sync.RWMutex
	paymentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var paymentBeforeInsertHooks []PaymentHook
var paymentBeforeUpdateHooks []PaymentHook
var paymentBeforeDeleteHooks []PaymentHook
var paymentBeforeUpsertHooks []PaymentHook

var paymentAfterInsertHooks []PaymentHook
var paymentAfterSelectHooks []PaymentHook
var paymentAfterUpdateHooks []PaymentHook
var paymentAfterDeleteHooks []PaymentHook
var paymentAfterUpsertHooks []PaymentHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Payment) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Payment) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Payment) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Payment) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Payment) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Payment) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Payment) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Payment) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Payment) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPaymentHook registers your hook function for all future operations.
func AddPaymentHook(hookPoint boil.HookPoint, paymentHook PaymentHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		paymentBeforeInsertHooks = append(paymentBeforeInsertHooks, paymentHook)
	case boil.BeforeUpdateHook:
		paymentBeforeUpdateHooks = append(paymentBeforeUpdateHooks, paymentHook)
	case boil.BeforeDeleteHook:
		paymentBeforeDeleteHooks = append(paymentBeforeDeleteHooks, paymentHook)
	case boil.BeforeUpsertHook:
		paymentBeforeUpsertHooks = append(paymentBeforeUpsertHooks, paymentHook)
	case boil.AfterInsertHook:
		paymentAfterInsertHooks = append(paymentAfterInsertHooks, paymentHook)
	case boil.AfterSelectHook:
		paymentAfterSelectHooks = append(paymentAfterSelectHooks, paymentHook)
	case boil.AfterUpdateHook:
		paymentAfterUpdateHooks = append(paymentAfterUpdateHooks, paymentHook)
	case boil.AfterDeleteHook:
		paymentAfterDeleteHooks = append(paymentAfterDeleteHooks, paymentHook)
	case boil.AfterUpsertHook:
		paymentAfterUpsertHooks = append(paymentAfterUpsertHooks, paymentHook)
	}
}

// One returns a single payment record from the query.
func (q paymentQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Payment, error) {
	o := &Payment{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Payment")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Payment records from the query.
func (q paymentQuery) All(ctx context.Context, exec boil.ContextExecutor) (PaymentSlice, error) {
	var o []*Payment

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Payment slice")
	}

	if len(paymentAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Payment records in the query.
func (q paymentQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Payment rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q paymentQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Payment exists")
	}

	return count > 0, nil
}

// PaymentMethodCode pointed to by the foreign key.
func (o *Payment) PaymentMethodCode1(mods ...qm.QueryMod) paymentMethodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_method_code=?", o.PaymentMethodCode),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentMethods(queryMods...)
	queries.SetFrom(query.Query, "`PaymentMethod`")

	return query
}

// PaymentPaymentAches retrieves all the PaymentAch's PaymentAches with an executor via payment_id column.
func (o *Payment) PaymentPaymentAches(mods ...qm.QueryMod) paymentAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentAch`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentAches(queryMods...)
	queries.SetFrom(query.Query, "`PaymentAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentAch`.*"})
	}

	return query
}

// PaymentPaymentBills retrieves all the PaymentBill's PaymentBills with an executor via payment_id column.
func (o *Payment) PaymentPaymentBills(mods ...qm.QueryMod) paymentBillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentBill`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentBills(queryMods...)
	queries.SetFrom(query.Query, "`PaymentBill`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentBill`.*"})
	}

	return query
}

// PaymentPaymentCheques retrieves all the PaymentCheque's PaymentCheques with an executor via payment_id column.
func (o *Payment) PaymentPaymentCheques(mods ...qm.QueryMod) paymentChequeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentCheque`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentCheques(queryMods...)
	queries.SetFrom(query.Query, "`PaymentCheque`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentCheque`.*"})
	}

	return query
}

// PaymentPaymentFxTrades retrieves all the PaymentFxTrade's PaymentFxTrades with an executor via payment_id column.
func (o *Payment) PaymentPaymentFxTrades(mods ...qm.QueryMod) paymentFxTradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentFxTrade`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentFxTrades(queryMods...)
	queries.SetFrom(query.Query, "`PaymentFxTrade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentFxTrade`.*"})
	}

	return query
}

// PaymentPaymentGateways retrieves all the PaymentGateway's PaymentGateways with an executor via payment_id column.
func (o *Payment) PaymentPaymentGateways(mods ...qm.QueryMod) paymentGatewayQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentGateway`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentGateways(queryMods...)
	queries.SetFrom(query.Query, "`PaymentGateway`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentGateway`.*"})
	}

	return query
}

// PaymentPaymentLoans retrieves all the PaymentLoan's PaymentLoans with an executor via payment_id column.
func (o *Payment) PaymentPaymentLoans(mods ...qm.QueryMod) paymentLoanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentLoan`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentLoans(queryMods...)
	queries.SetFrom(query.Query, "`PaymentLoan`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentLoan`.*"})
	}

	return query
}

// PaymentPaymentMessages retrieves all the PaymentMessage's PaymentMessages with an executor via payment_id column.
func (o *Payment) PaymentPaymentMessages(mods ...qm.QueryMod) paymentMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentMessage`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentMessages(queryMods...)
	queries.SetFrom(query.Query, "`PaymentMessage`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentMessage`.*"})
	}

	return query
}

// PaymentPaymentRtps retrieves all the PaymentRtp's PaymentRtps with an executor via payment_id column.
func (o *Payment) PaymentPaymentRtps(mods ...qm.QueryMod) paymentRtpQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentRtp`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentRtps(queryMods...)
	queries.SetFrom(query.Query, "`PaymentRtp`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentRtp`.*"})
	}

	return query
}

// PaymentPaymentWires retrieves all the PaymentWire's PaymentWires with an executor via payment_id column.
func (o *Payment) PaymentPaymentWires(mods ...qm.QueryMod) paymentWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentWire`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentWires(queryMods...)
	queries.SetFrom(query.Query, "`PaymentWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentWire`.*"})
	}

	return query
}

// LoadPaymentMethodCode allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (paymentL) LoadPaymentMethodCode(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		if !queries.IsNil(object.PaymentMethodCode) {
			args = append(args, object.PaymentMethodCode)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentMethodCode) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PaymentMethodCode) {
				args = append(args, obj.PaymentMethodCode)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentMethod`), qm.WhereIn(`payment_method_code in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentMethod")
	}

	var resultSlice []*PaymentMethod
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentMethod")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for PaymentMethod")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentMethod")
	}

	if len(paymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentMethodCode = foreign
		if foreign.R == nil {
			foreign.R = &paymentMethodR{}
		}
		foreign.R.PaymentMethodCodePayments = append(foreign.R.PaymentMethodCodePayments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PaymentMethodCode, foreign.PaymentMethodCode) {
				local.R.PaymentMethodCode = foreign
				if foreign.R == nil {
					foreign.R = &paymentMethodR{}
				}
				foreign.R.PaymentMethodCodePayments = append(foreign.R.PaymentMethodCodePayments, local)
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentAch`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentAch")
	}

	var resultSlice []*PaymentAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentAch")
	}

	if len(paymentAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAchR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentAches = append(local.R.PaymentPaymentAches, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAchR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentBills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentBills(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentBill`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentBill")
	}

	var resultSlice []*PaymentBill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentBill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentBill")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentBill")
	}

	if len(paymentBillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentBills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentBillR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentBills = append(local.R.PaymentPaymentBills, foreign)
				if foreign.R == nil {
					foreign.R = &paymentBillR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentCheques allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentCheques(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentCheque`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentCheque")
	}

	var resultSlice []*PaymentCheque
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentCheque")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentCheque")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentCheque")
	}

	if len(paymentChequeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentCheques = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentChequeR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentCheques = append(local.R.PaymentPaymentCheques, foreign)
				if foreign.R == nil {
					foreign.R = &paymentChequeR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentFxTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentFxTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentFxTrade`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentFxTrade")
	}

	var resultSlice []*PaymentFxTrade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentFxTrade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentFxTrade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentFxTrade")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentFxTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentFxTradeR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentFxTrades = append(local.R.PaymentPaymentFxTrades, foreign)
				if foreign.R == nil {
					foreign.R = &paymentFxTradeR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentGateways allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentGateways(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentGateway`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentGateway")
	}

	var resultSlice []*PaymentGateway
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentGateway")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentGateway")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentGateway")
	}

	if len(paymentGatewayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentGateways = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentGatewayR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentGateways = append(local.R.PaymentPaymentGateways, foreign)
				if foreign.R == nil {
					foreign.R = &paymentGatewayR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentLoans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentLoans(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentLoan`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentLoan")
	}

	var resultSlice []*PaymentLoan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentLoan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentLoan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentLoan")
	}

	if len(paymentLoanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentLoans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentLoanR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentLoans = append(local.R.PaymentPaymentLoans, foreign)
				if foreign.R == nil {
					foreign.R = &paymentLoanR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentMessages(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentMessage`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentMessage")
	}

	var resultSlice []*PaymentMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentMessage")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentMessage")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentMessage")
	}

	if len(paymentMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentMessageR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentMessages = append(local.R.PaymentPaymentMessages, foreign)
				if foreign.R == nil {
					foreign.R = &paymentMessageR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentRtps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentRtps(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentRtp`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentRtp")
	}

	var resultSlice []*PaymentRtp
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentRtp")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentRtp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentRtp")
	}

	if len(paymentRtpAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentRtps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentRtpR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentRtps = append(local.R.PaymentPaymentRtps, foreign)
				if foreign.R == nil {
					foreign.R = &paymentRtpR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentL) LoadPaymentPaymentWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybePayment interface{}, mods queries.Applicator) error {
	var slice []*Payment
	var object *Payment

	if singular {
		object = maybePayment.(*Payment)
	} else {
		slice = *maybePayment.(*[]*Payment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentWire`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentWire")
	}

	var resultSlice []*PaymentWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentWire")
	}

	if len(paymentWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentWireR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentWires = append(local.R.PaymentPaymentWires, foreign)
				if foreign.R == nil {
					foreign.R = &paymentWireR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// SetPaymentMethodCode of the payment to the related item.
// Sets o.R.PaymentMethodCode to related.
// Adds o to related.R.PaymentMethodCodePayments.
func (o *Payment) SetPaymentMethodCode(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentMethod) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Payment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_method_code"}),
		strmangle.WhereClause("`", "`", 0, paymentPrimaryKeyColumns),
	)
	values := []interface{}{related.PaymentMethodCode, o.PaymentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PaymentMethodCode, related.PaymentMethodCode)
	if o.R == nil {
		o.R = &paymentR{
			PaymentMethodCode: related,
		}
	} else {
		o.R.PaymentMethodCode = related
	}

	if related.R == nil {
		related.R = &paymentMethodR{
			PaymentMethodCodePayments: PaymentSlice{o},
		}
	} else {
		related.R.PaymentMethodCodePayments = append(related.R.PaymentMethodCodePayments, o)
	}

	return nil
}

// RemovePaymentMethodCode relationship.
// Sets o.R.PaymentMethodCode to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Payment) RemovePaymentMethodCode(ctx context.Context, exec boil.ContextExecutor, related *PaymentMethod) error {
	var err error

	queries.SetScanner(&o.PaymentMethodCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("payment_method_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.PaymentMethodCode = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PaymentMethodCodePayments {
		if queries.Equal(o.PaymentMethodCode, ri.PaymentMethodCode) {
			continue
		}

		ln := len(related.R.PaymentMethodCodePayments)
		if ln > 1 && i < ln-1 {
			related.R.PaymentMethodCodePayments[i] = related.R.PaymentMethodCodePayments[ln-1]
		}
		related.R.PaymentMethodCodePayments = related.R.PaymentMethodCodePayments[:ln-1]
		break
	}
	return nil
}

// AddPaymentPaymentAches adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentAches.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentAchPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentAches: related,
		}
	} else {
		o.R.PaymentPaymentAches = append(o.R.PaymentPaymentAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAchR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentAches removes all previously related items of the
// Payment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentAches accordingly.
// Replaces o.R.PaymentPaymentAches with related.
// Sets related.R.Payment's PaymentPaymentAches accordingly.
func (o *Payment) SetPaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	query := "update `PaymentAch` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentAches {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentAches = nil
	}
	return o.AddPaymentPaymentAches(ctx, exec, insert, related...)
}

// RemovePaymentPaymentAches relationships from objects passed in.
// Removes related items from R.PaymentPaymentAches (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *Payment) RemovePaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentAches {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentAches)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentAches[i] = o.R.PaymentPaymentAches[ln-1]
			}
			o.R.PaymentPaymentAches = o.R.PaymentPaymentAches[:ln-1]
			break
		}
	}

	return nil
}

// AddPaymentPaymentBills adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentBills.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentBills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentBill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentBill` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentBillPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentBillID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentBills: related,
		}
	} else {
		o.R.PaymentPaymentBills = append(o.R.PaymentPaymentBills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentBillR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentCheques adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentCheques.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentCheques(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentCheque) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentCheque` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentChequePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentChequeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentCheques: related,
		}
	} else {
		o.R.PaymentPaymentCheques = append(o.R.PaymentPaymentCheques, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentChequeR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentFxTrades adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentFxTrades.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentFxTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentFxTrade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentFxTrade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentFXTradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentFxTrades: related,
		}
	} else {
		o.R.PaymentPaymentFxTrades = append(o.R.PaymentPaymentFxTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentFxTradeR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentGateways adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentGateways.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentGateways(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentGateway) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentGateway` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentGatewayPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentGatewayID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentGateways: related,
		}
	} else {
		o.R.PaymentPaymentGateways = append(o.R.PaymentPaymentGateways, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentGatewayR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentLoans adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentLoans.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentLoans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLoan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentLoan` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentLoanPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentLoanID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentLoans: related,
		}
	} else {
		o.R.PaymentPaymentLoans = append(o.R.PaymentPaymentLoans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentLoanR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentMessages adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentMessages.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentMessage` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentMessageID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentMessages: related,
		}
	} else {
		o.R.PaymentPaymentMessages = append(o.R.PaymentPaymentMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentMessageR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentMessages removes all previously related items of the
// Payment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentMessages accordingly.
// Replaces o.R.PaymentPaymentMessages with related.
// Sets related.R.Payment's PaymentPaymentMessages accordingly.
func (o *Payment) SetPaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentMessage) error {
	query := "update `PaymentMessage` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentMessages {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentMessages = nil
	}
	return o.AddPaymentPaymentMessages(ctx, exec, insert, related...)
}

// RemovePaymentPaymentMessages relationships from objects passed in.
// Removes related items from R.PaymentPaymentMessages (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *Payment) RemovePaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentMessage) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentMessages {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentMessages)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentMessages[i] = o.R.PaymentPaymentMessages[ln-1]
			}
			o.R.PaymentPaymentMessages = o.R.PaymentPaymentMessages[:ln-1]
			break
		}
	}

	return nil
}

// AddPaymentPaymentRtps adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentRtps.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentRtps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentRtp) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentRtp` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentRtpPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentRTPID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentRtps: related,
		}
	} else {
		o.R.PaymentPaymentRtps = append(o.R.PaymentPaymentRtps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentRtpR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentWires adds the given related objects to the existing relationships
// of the Payment, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentWires.
// Sets related.R.Payment appropriately.
func (o *Payment) AddPaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentWirePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentR{
			PaymentPaymentWires: related,
		}
	} else {
		o.R.PaymentPaymentWires = append(o.R.PaymentPaymentWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentWireR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentWires removes all previously related items of the
// Payment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentWires accordingly.
// Replaces o.R.PaymentPaymentWires with related.
// Sets related.R.Payment's PaymentPaymentWires accordingly.
func (o *Payment) SetPaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	query := "update `PaymentWire` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentWires {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentWires = nil
	}
	return o.AddPaymentPaymentWires(ctx, exec, insert, related...)
}

// RemovePaymentPaymentWires relationships from objects passed in.
// Removes related items from R.PaymentPaymentWires (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *Payment) RemovePaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentWires {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentWires)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentWires[i] = o.R.PaymentPaymentWires[ln-1]
			}
			o.R.PaymentPaymentWires = o.R.PaymentPaymentWires[:ln-1]
			break
		}
	}

	return nil
}

// Payments retrieves all the records using an executor.
func Payments(mods ...qm.QueryMod) paymentQuery {
	mods = append(mods, qm.From("`Payment`"))
	return paymentQuery{NewQuery(mods...)}
}

// FindPayment retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPayment(ctx context.Context, exec boil.ContextExecutor, paymentID int, selectCols ...string) (*Payment, error) {
	paymentObj := &Payment{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Payment` where `payment_id`=?", sel,
	)

	q := queries.Raw(query, paymentID)

	err := q.Bind(ctx, exec, paymentObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Payment")
	}

	return paymentObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Payment) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Payment provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	paymentInsertCacheMut.RLock()
	cache, cached := paymentInsertCache[key]
	paymentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			paymentColumns,
			paymentColumnsWithDefault,
			paymentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(paymentType, paymentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(paymentType, paymentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Payment` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Payment` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Payment` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, paymentPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Payment")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentMapping["PaymentID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PaymentID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Payment")
	}

CacheNoHooks:
	if !cached {
		paymentInsertCacheMut.Lock()
		paymentInsertCache[key] = cache
		paymentInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Payment.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Payment) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	paymentUpdateCacheMut.RLock()
	cache, cached := paymentUpdateCache[key]
	paymentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			paymentColumns,
			paymentPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Payment, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Payment` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, paymentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(paymentType, paymentMapping, append(wl, paymentPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Payment row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Payment")
	}

	if !cached {
		paymentUpdateCacheMut.Lock()
		paymentUpdateCache[key] = cache
		paymentUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q paymentQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Payment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Payment")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PaymentSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Payment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in payment slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all payment")
	}
	return rowsAff, nil
}

var mySQLPaymentUniqueColumns = []string{
	"payment_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Payment) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Payment provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPaymentUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	paymentUpsertCacheMut.RLock()
	cache, cached := paymentUpsertCache[key]
	paymentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			paymentColumns,
			paymentColumnsWithDefault,
			paymentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			paymentColumns,
			paymentPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Payment, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Payment", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Payment` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(paymentType, paymentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(paymentType, paymentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Payment")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentMapping["payment_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(paymentType, paymentMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Payment")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Payment")
	}

CacheNoHooks:
	if !cached {
		paymentUpsertCacheMut.Lock()
		paymentUpsertCache[key] = cache
		paymentUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Payment record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Payment) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Payment provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), paymentPrimaryKeyMapping)
	sql := "DELETE FROM `Payment` WHERE `payment_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Payment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Payment")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q paymentQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no paymentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Payment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Payment")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PaymentSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Payment slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(paymentBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Payment` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from payment slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Payment")
	}

	if len(paymentAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Payment) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPayment(ctx, exec, o.PaymentID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PaymentSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PaymentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Payment`.* FROM `Payment` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PaymentSlice")
	}

	*o = slice

	return nil
}

// PaymentExists checks if the Payment row exists.
func PaymentExists(ctx context.Context, exec boil.ContextExecutor, paymentID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Payment` where `payment_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, paymentID)
	}

	row := exec.QueryRowContext(ctx, sql, paymentID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Payment exists")
	}

	return exists, nil
}
