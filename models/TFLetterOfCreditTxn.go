// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// TFLetterOfCreditTxn is an object representing the database table.
type TFLetterOfCreditTxn struct {
	TFLCTXNID            int           `boil:"tf_lc_txn_id" json:"tf_lc_txn_id" toml:"tf_lc_txn_id" yaml:"tf_lc_txn_id"`
	ReferenceID          string        `boil:"reference_id" json:"reference_id" toml:"reference_id" yaml:"reference_id"`
	BranchID             int           `boil:"branch_id" json:"branch_id" toml:"branch_id" yaml:"branch_id"`
	TransactionID        int           `boil:"transaction_id" json:"transaction_id" toml:"transaction_id" yaml:"transaction_id"`
	ProductCode          string        `boil:"product_code" json:"product_code" toml:"product_code" yaml:"product_code"`
	PartyID              int           `boil:"party_id" json:"party_id" toml:"party_id" yaml:"party_id"`
	AccountNumber        string        `boil:"account_number" json:"account_number" toml:"account_number" yaml:"account_number"`
	OurReferenceID       string        `boil:"our_reference_id" json:"our_reference_id" toml:"our_reference_id" yaml:"our_reference_id"`
	RevocableFlag        string        `boil:"revocable_flag" json:"revocable_flag" toml:"revocable_flag" yaml:"revocable_flag"`
	STNDByLCFlag         string        `boil:"stnd_by_lc_flag" json:"stnd_by_lc_flag" toml:"stnd_by_lc_flag" yaml:"stnd_by_lc_flag"`
	Status               string        `boil:"status" json:"status" toml:"status" yaml:"status"`
	LetterofCreditNumber string        `boil:"letterof_credit_number" json:"letterof_credit_number" toml:"letterof_credit_number" yaml:"letterof_credit_number"`
	ExportOrImport       string        `boil:"export_or_import" json:"export_or_import" toml:"export_or_import" yaml:"export_or_import"`
	LCType               string        `boil:"lc_type" json:"lc_type" toml:"lc_type" yaml:"lc_type"`
	Ccy                  string        `boil:"ccy" json:"ccy" toml:"ccy" yaml:"ccy"`
	LinkedAccountID      int           `boil:"linked_account_id" json:"linked_account_id" toml:"linked_account_id" yaml:"linked_account_id"`
	BankID               int           `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	Amount               types.Decimal `boil:"amount" json:"amount" toml:"amount" yaml:"amount"`
	ApplicationDate      time.Time     `boil:"application_date" json:"application_date" toml:"application_date" yaml:"application_date"`
	IssueDate            time.Time     `boil:"issue_date" json:"issue_date" toml:"issue_date" yaml:"issue_date"`
	ExpiryDate           time.Time     `boil:"expiry_date" json:"expiry_date" toml:"expiry_date" yaml:"expiry_date"`
	ProdStatusCode       string        `boil:"prod_status_code" json:"prod_status_code" toml:"prod_status_code" yaml:"prod_status_code"`
	LCCurrency           string        `boil:"lc_currency" json:"lc_currency" toml:"lc_currency" yaml:"lc_currency"`
	LCAmount             types.Decimal `boil:"lc_amount" json:"lc_amount" toml:"lc_amount" yaml:"lc_amount"`
	LCLiabilityCurrency  string        `boil:"lc_liability_currency" json:"lc_liability_currency" toml:"lc_liability_currency" yaml:"lc_liability_currency"`
	LCLiabilityAmt       types.Decimal `boil:"lc_liability_amt" json:"lc_liability_amt" toml:"lc_liability_amt" yaml:"lc_liability_amt"`
	ApplicantName        string        `boil:"applicant_name" json:"applicant_name" toml:"applicant_name" yaml:"applicant_name"`
	ApplicantAddress     string        `boil:"applicant_address" json:"applicant_address" toml:"applicant_address" yaml:"applicant_address"`
	BeneficiaryName      string        `boil:"beneficiary_name" json:"beneficiary_name" toml:"beneficiary_name" yaml:"beneficiary_name"`
	BeneficiaryAddress   string        `boil:"beneficiary_address" json:"beneficiary_address" toml:"beneficiary_address" yaml:"beneficiary_address"`
	BeneficiaryCountry   string        `boil:"beneficiary_country" json:"beneficiary_country" toml:"beneficiary_country" yaml:"beneficiary_country"`
	AmendDate            time.Time     `boil:"amend_date" json:"amend_date" toml:"amend_date" yaml:"amend_date"`
	AmendNum             int           `boil:"amend_num" json:"amend_num" toml:"amend_num" yaml:"amend_num"`
	ExpiryPlace          string        `boil:"expiry_place" json:"expiry_place" toml:"expiry_place" yaml:"expiry_place"`
	AdvanceSendMode      string        `boil:"advance_send_mode" json:"advance_send_mode" toml:"advance_send_mode" yaml:"advance_send_mode"`
	IncoTerm             string        `boil:"inco_term" json:"inco_term" toml:"inco_term" yaml:"inco_term"`
	IncoPlace            string        `boil:"inco_place" json:"inco_place" toml:"inco_place" yaml:"inco_place"`
	ShipFrom             string        `boil:"ship_from" json:"ship_from" toml:"ship_from" yaml:"ship_from"`
	ShipTo               string        `boil:"ship_to" json:"ship_to" toml:"ship_to" yaml:"ship_to"`
	DraftTerm            string        `boil:"draft_term" json:"draft_term" toml:"draft_term" yaml:"draft_term"`
	CityOfDest           string        `boil:"city_of_dest" json:"city_of_dest" toml:"city_of_dest" yaml:"city_of_dest"`
	ChargeBRNBy          string        `boil:"charge_brn_by" json:"charge_brn_by" toml:"charge_brn_by" yaml:"charge_brn_by"`
	PartShipDTL          string        `boil:"part_ship_dtl" json:"part_ship_dtl" toml:"part_ship_dtl" yaml:"part_ship_dtl"`
	TranShipDTL          string        `boil:"tran_ship_dtl" json:"tran_ship_dtl" toml:"tran_ship_dtl" yaml:"tran_ship_dtl"`
	GoodsCategory        string        `boil:"goods_category" json:"goods_category" toml:"goods_category" yaml:"goods_category"`
	AdvisingBank         string        `boil:"advising_bank" json:"advising_bank" toml:"advising_bank" yaml:"advising_bank"`
	ReimbursingBank      string        `boil:"reimbursing_bank" json:"reimbursing_bank" toml:"reimbursing_bank" yaml:"reimbursing_bank"`
	MakerDate            time.Time     `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate          null.Time     `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID              string        `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID            null.String   `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy           null.String   `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate         null.Time     `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`
	SwiftInStatus        null.String   `boil:"swift_in_status" json:"swift_in_status,omitempty" toml:"swift_in_status" yaml:"swift_in_status,omitempty"`
	SwiftOutStatus       null.String   `boil:"swift_out_status" json:"swift_out_status,omitempty" toml:"swift_out_status" yaml:"swift_out_status,omitempty"`
	OfacStatus           null.String   `boil:"ofac_status" json:"ofac_status,omitempty" toml:"ofac_status" yaml:"ofac_status,omitempty"`
	PenaltyDetails       null.String   `boil:"penalty_details" json:"penalty_details,omitempty" toml:"penalty_details" yaml:"penalty_details,omitempty"`

	R *tFLetterOfCreditTxnR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L tFLetterOfCreditTxnL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TFLetterOfCreditTxnColumns = struct {
	TFLCTXNID            string
	ReferenceID          string
	BranchID             string
	TransactionID        string
	ProductCode          string
	PartyID              string
	AccountNumber        string
	OurReferenceID       string
	RevocableFlag        string
	STNDByLCFlag         string
	Status               string
	LetterofCreditNumber string
	ExportOrImport       string
	LCType               string
	Ccy                  string
	LinkedAccountID      string
	BankID               string
	Amount               string
	ApplicationDate      string
	IssueDate            string
	ExpiryDate           string
	ProdStatusCode       string
	LCCurrency           string
	LCAmount             string
	LCLiabilityCurrency  string
	LCLiabilityAmt       string
	ApplicantName        string
	ApplicantAddress     string
	BeneficiaryName      string
	BeneficiaryAddress   string
	BeneficiaryCountry   string
	AmendDate            string
	AmendNum             string
	ExpiryPlace          string
	AdvanceSendMode      string
	IncoTerm             string
	IncoPlace            string
	ShipFrom             string
	ShipTo               string
	DraftTerm            string
	CityOfDest           string
	ChargeBRNBy          string
	PartShipDTL          string
	TranShipDTL          string
	GoodsCategory        string
	AdvisingBank         string
	ReimbursingBank      string
	MakerDate            string
	CheckerDate          string
	MakerID              string
	CheckerID            string
	ModifiedBy           string
	ModifiedDate         string
	SwiftInStatus        string
	SwiftOutStatus       string
	OfacStatus           string
	PenaltyDetails       string
}{
	TFLCTXNID:            "tf_lc_txn_id",
	ReferenceID:          "reference_id",
	BranchID:             "branch_id",
	TransactionID:        "transaction_id",
	ProductCode:          "product_code",
	PartyID:              "party_id",
	AccountNumber:        "account_number",
	OurReferenceID:       "our_reference_id",
	RevocableFlag:        "revocable_flag",
	STNDByLCFlag:         "stnd_by_lc_flag",
	Status:               "status",
	LetterofCreditNumber: "letterof_credit_number",
	ExportOrImport:       "export_or_import",
	LCType:               "lc_type",
	Ccy:                  "ccy",
	LinkedAccountID:      "linked_account_id",
	BankID:               "bank_id",
	Amount:               "amount",
	ApplicationDate:      "application_date",
	IssueDate:            "issue_date",
	ExpiryDate:           "expiry_date",
	ProdStatusCode:       "prod_status_code",
	LCCurrency:           "lc_currency",
	LCAmount:             "lc_amount",
	LCLiabilityCurrency:  "lc_liability_currency",
	LCLiabilityAmt:       "lc_liability_amt",
	ApplicantName:        "applicant_name",
	ApplicantAddress:     "applicant_address",
	BeneficiaryName:      "beneficiary_name",
	BeneficiaryAddress:   "beneficiary_address",
	BeneficiaryCountry:   "beneficiary_country",
	AmendDate:            "amend_date",
	AmendNum:             "amend_num",
	ExpiryPlace:          "expiry_place",
	AdvanceSendMode:      "advance_send_mode",
	IncoTerm:             "inco_term",
	IncoPlace:            "inco_place",
	ShipFrom:             "ship_from",
	ShipTo:               "ship_to",
	DraftTerm:            "draft_term",
	CityOfDest:           "city_of_dest",
	ChargeBRNBy:          "charge_brn_by",
	PartShipDTL:          "part_ship_dtl",
	TranShipDTL:          "tran_ship_dtl",
	GoodsCategory:        "goods_category",
	AdvisingBank:         "advising_bank",
	ReimbursingBank:      "reimbursing_bank",
	MakerDate:            "maker_date",
	CheckerDate:          "checker_date",
	MakerID:              "maker_id",
	CheckerID:            "checker_id",
	ModifiedBy:           "modified_by",
	ModifiedDate:         "modified_date",
	SwiftInStatus:        "swift_in_status",
	SwiftOutStatus:       "swift_out_status",
	OfacStatus:           "ofac_status",
	PenaltyDetails:       "penalty_details",
}

// Generated where

var TFLetterOfCreditTxnWhere = struct {
	TFLCTXNID            whereHelperint
	ReferenceID          whereHelperstring
	BranchID             whereHelperint
	TransactionID        whereHelperint
	ProductCode          whereHelperstring
	PartyID              whereHelperint
	AccountNumber        whereHelperstring
	OurReferenceID       whereHelperstring
	RevocableFlag        whereHelperstring
	STNDByLCFlag         whereHelperstring
	Status               whereHelperstring
	LetterofCreditNumber whereHelperstring
	ExportOrImport       whereHelperstring
	LCType               whereHelperstring
	Ccy                  whereHelperstring
	LinkedAccountID      whereHelperint
	BankID               whereHelperint
	Amount               whereHelpertypes_Decimal
	ApplicationDate      whereHelpertime_Time
	IssueDate            whereHelpertime_Time
	ExpiryDate           whereHelpertime_Time
	ProdStatusCode       whereHelperstring
	LCCurrency           whereHelperstring
	LCAmount             whereHelpertypes_Decimal
	LCLiabilityCurrency  whereHelperstring
	LCLiabilityAmt       whereHelpertypes_Decimal
	ApplicantName        whereHelperstring
	ApplicantAddress     whereHelperstring
	BeneficiaryName      whereHelperstring
	BeneficiaryAddress   whereHelperstring
	BeneficiaryCountry   whereHelperstring
	AmendDate            whereHelpertime_Time
	AmendNum             whereHelperint
	ExpiryPlace          whereHelperstring
	AdvanceSendMode      whereHelperstring
	IncoTerm             whereHelperstring
	IncoPlace            whereHelperstring
	ShipFrom             whereHelperstring
	ShipTo               whereHelperstring
	DraftTerm            whereHelperstring
	CityOfDest           whereHelperstring
	ChargeBRNBy          whereHelperstring
	PartShipDTL          whereHelperstring
	TranShipDTL          whereHelperstring
	GoodsCategory        whereHelperstring
	AdvisingBank         whereHelperstring
	ReimbursingBank      whereHelperstring
	MakerDate            whereHelpertime_Time
	CheckerDate          whereHelpernull_Time
	MakerID              whereHelperstring
	CheckerID            whereHelpernull_String
	ModifiedBy           whereHelpernull_String
	ModifiedDate         whereHelpernull_Time
	SwiftInStatus        whereHelpernull_String
	SwiftOutStatus       whereHelpernull_String
	OfacStatus           whereHelpernull_String
	PenaltyDetails       whereHelpernull_String
}{
	TFLCTXNID:            whereHelperint{field: `tf_lc_txn_id`},
	ReferenceID:          whereHelperstring{field: `reference_id`},
	BranchID:             whereHelperint{field: `branch_id`},
	TransactionID:        whereHelperint{field: `transaction_id`},
	ProductCode:          whereHelperstring{field: `product_code`},
	PartyID:              whereHelperint{field: `party_id`},
	AccountNumber:        whereHelperstring{field: `account_number`},
	OurReferenceID:       whereHelperstring{field: `our_reference_id`},
	RevocableFlag:        whereHelperstring{field: `revocable_flag`},
	STNDByLCFlag:         whereHelperstring{field: `stnd_by_lc_flag`},
	Status:               whereHelperstring{field: `status`},
	LetterofCreditNumber: whereHelperstring{field: `letterof_credit_number`},
	ExportOrImport:       whereHelperstring{field: `export_or_import`},
	LCType:               whereHelperstring{field: `lc_type`},
	Ccy:                  whereHelperstring{field: `ccy`},
	LinkedAccountID:      whereHelperint{field: `linked_account_id`},
	BankID:               whereHelperint{field: `bank_id`},
	Amount:               whereHelpertypes_Decimal{field: `amount`},
	ApplicationDate:      whereHelpertime_Time{field: `application_date`},
	IssueDate:            whereHelpertime_Time{field: `issue_date`},
	ExpiryDate:           whereHelpertime_Time{field: `expiry_date`},
	ProdStatusCode:       whereHelperstring{field: `prod_status_code`},
	LCCurrency:           whereHelperstring{field: `lc_currency`},
	LCAmount:             whereHelpertypes_Decimal{field: `lc_amount`},
	LCLiabilityCurrency:  whereHelperstring{field: `lc_liability_currency`},
	LCLiabilityAmt:       whereHelpertypes_Decimal{field: `lc_liability_amt`},
	ApplicantName:        whereHelperstring{field: `applicant_name`},
	ApplicantAddress:     whereHelperstring{field: `applicant_address`},
	BeneficiaryName:      whereHelperstring{field: `beneficiary_name`},
	BeneficiaryAddress:   whereHelperstring{field: `beneficiary_address`},
	BeneficiaryCountry:   whereHelperstring{field: `beneficiary_country`},
	AmendDate:            whereHelpertime_Time{field: `amend_date`},
	AmendNum:             whereHelperint{field: `amend_num`},
	ExpiryPlace:          whereHelperstring{field: `expiry_place`},
	AdvanceSendMode:      whereHelperstring{field: `advance_send_mode`},
	IncoTerm:             whereHelperstring{field: `inco_term`},
	IncoPlace:            whereHelperstring{field: `inco_place`},
	ShipFrom:             whereHelperstring{field: `ship_from`},
	ShipTo:               whereHelperstring{field: `ship_to`},
	DraftTerm:            whereHelperstring{field: `draft_term`},
	CityOfDest:           whereHelperstring{field: `city_of_dest`},
	ChargeBRNBy:          whereHelperstring{field: `charge_brn_by`},
	PartShipDTL:          whereHelperstring{field: `part_ship_dtl`},
	TranShipDTL:          whereHelperstring{field: `tran_ship_dtl`},
	GoodsCategory:        whereHelperstring{field: `goods_category`},
	AdvisingBank:         whereHelperstring{field: `advising_bank`},
	ReimbursingBank:      whereHelperstring{field: `reimbursing_bank`},
	MakerDate:            whereHelpertime_Time{field: `maker_date`},
	CheckerDate:          whereHelpernull_Time{field: `checker_date`},
	MakerID:              whereHelperstring{field: `maker_id`},
	CheckerID:            whereHelpernull_String{field: `checker_id`},
	ModifiedBy:           whereHelpernull_String{field: `modified_by`},
	ModifiedDate:         whereHelpernull_Time{field: `modified_date`},
	SwiftInStatus:        whereHelpernull_String{field: `swift_in_status`},
	SwiftOutStatus:       whereHelpernull_String{field: `swift_out_status`},
	OfacStatus:           whereHelpernull_String{field: `ofac_status`},
	PenaltyDetails:       whereHelpernull_String{field: `penalty_details`},
}

// TFLetterOfCreditTxnRels is where relationship names are stored.
var TFLetterOfCreditTxnRels = struct {
	Reference string
	Bank      string
	Party     string
}{
	Reference: "Reference",
	Bank:      "Bank",
	Party:     "Party",
}

// tFLetterOfCreditTxnR is where relationships are stored.
type tFLetterOfCreditTxnR struct {
	Reference *TFLetterOfCredit
	Bank      *Bank
	Party     *Party
}

// NewStruct creates a new relationship struct
func (*tFLetterOfCreditTxnR) NewStruct() *tFLetterOfCreditTxnR {
	return &tFLetterOfCreditTxnR{}
}

// tFLetterOfCreditTxnL is where Load methods for each relationship are stored.
type tFLetterOfCreditTxnL struct{}

var (
	tFLetterOfCreditTxnColumns               = []string{"tf_lc_txn_id", "reference_id", "branch_id", "transaction_id", "product_code", "party_id", "account_number", "our_reference_id", "revocable_flag", "stnd_by_lc_flag", "status", "letterof_credit_number", "export_or_import", "lc_type", "ccy", "linked_account_id", "bank_id", "amount", "application_date", "issue_date", "expiry_date", "prod_status_code", "lc_currency", "lc_amount", "lc_liability_currency", "lc_liability_amt", "applicant_name", "applicant_address", "beneficiary_name", "beneficiary_address", "beneficiary_country", "amend_date", "amend_num", "expiry_place", "advance_send_mode", "inco_term", "inco_place", "ship_from", "ship_to", "draft_term", "city_of_dest", "charge_brn_by", "part_ship_dtl", "tran_ship_dtl", "goods_category", "advising_bank", "reimbursing_bank", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "swift_in_status", "swift_out_status", "ofac_status", "penalty_details"}
	tFLetterOfCreditTxnColumnsWithoutDefault = []string{"tf_lc_txn_id", "reference_id", "branch_id", "transaction_id", "product_code", "party_id", "account_number", "our_reference_id", "revocable_flag", "stnd_by_lc_flag", "status", "letterof_credit_number", "export_or_import", "lc_type", "ccy", "linked_account_id", "bank_id", "amount", "application_date", "issue_date", "expiry_date", "prod_status_code", "lc_currency", "lc_amount", "lc_liability_currency", "lc_liability_amt", "applicant_name", "applicant_address", "beneficiary_name", "beneficiary_address", "beneficiary_country", "amend_date", "amend_num", "expiry_place", "advance_send_mode", "inco_term", "inco_place", "ship_from", "ship_to", "draft_term", "city_of_dest", "charge_brn_by", "part_ship_dtl", "tran_ship_dtl", "goods_category", "advising_bank", "reimbursing_bank", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "swift_in_status", "swift_out_status", "ofac_status", "penalty_details"}
	tFLetterOfCreditTxnColumnsWithDefault    = []string{}
	tFLetterOfCreditTxnPrimaryKeyColumns     = []string{"tf_lc_txn_id"}
)

type (
	// TFLetterOfCreditTxnSlice is an alias for a slice of pointers to TFLetterOfCreditTxn.
	// This should generally be used opposed to []TFLetterOfCreditTxn.
	TFLetterOfCreditTxnSlice []*TFLetterOfCreditTxn
	// TFLetterOfCreditTxnHook is the signature for custom TFLetterOfCreditTxn hook methods
	TFLetterOfCreditTxnHook func(context.Context, boil.ContextExecutor, *TFLetterOfCreditTxn) error

	tFLetterOfCreditTxnQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	tFLetterOfCreditTxnType                 = reflect.TypeOf(&TFLetterOfCreditTxn{})
	tFLetterOfCreditTxnMapping              = queries.MakeStructMapping(tFLetterOfCreditTxnType)
	tFLetterOfCreditTxnPrimaryKeyMapping, _ = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, tFLetterOfCreditTxnPrimaryKeyColumns)
	tFLetterOfCreditTxnInsertCacheMut       sync.RWMutex
	tFLetterOfCreditTxnInsertCache          = make(map[string]insertCache)
	tFLetterOfCreditTxnUpdateCacheMut       sync.RWMutex
	tFLetterOfCreditTxnUpdateCache          = make(map[string]updateCache)
	tFLetterOfCreditTxnUpsertCacheMut       sync.RWMutex
	tFLetterOfCreditTxnUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var tFLetterOfCreditTxnBeforeInsertHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnBeforeUpdateHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnBeforeDeleteHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnBeforeUpsertHooks []TFLetterOfCreditTxnHook

var tFLetterOfCreditTxnAfterInsertHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnAfterSelectHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnAfterUpdateHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnAfterDeleteHooks []TFLetterOfCreditTxnHook
var tFLetterOfCreditTxnAfterUpsertHooks []TFLetterOfCreditTxnHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *TFLetterOfCreditTxn) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *TFLetterOfCreditTxn) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *TFLetterOfCreditTxn) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *TFLetterOfCreditTxn) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *TFLetterOfCreditTxn) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *TFLetterOfCreditTxn) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *TFLetterOfCreditTxn) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *TFLetterOfCreditTxn) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *TFLetterOfCreditTxn) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditTxnAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTFLetterOfCreditTxnHook registers your hook function for all future operations.
func AddTFLetterOfCreditTxnHook(hookPoint boil.HookPoint, tFLetterOfCreditTxnHook TFLetterOfCreditTxnHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		tFLetterOfCreditTxnBeforeInsertHooks = append(tFLetterOfCreditTxnBeforeInsertHooks, tFLetterOfCreditTxnHook)
	case boil.BeforeUpdateHook:
		tFLetterOfCreditTxnBeforeUpdateHooks = append(tFLetterOfCreditTxnBeforeUpdateHooks, tFLetterOfCreditTxnHook)
	case boil.BeforeDeleteHook:
		tFLetterOfCreditTxnBeforeDeleteHooks = append(tFLetterOfCreditTxnBeforeDeleteHooks, tFLetterOfCreditTxnHook)
	case boil.BeforeUpsertHook:
		tFLetterOfCreditTxnBeforeUpsertHooks = append(tFLetterOfCreditTxnBeforeUpsertHooks, tFLetterOfCreditTxnHook)
	case boil.AfterInsertHook:
		tFLetterOfCreditTxnAfterInsertHooks = append(tFLetterOfCreditTxnAfterInsertHooks, tFLetterOfCreditTxnHook)
	case boil.AfterSelectHook:
		tFLetterOfCreditTxnAfterSelectHooks = append(tFLetterOfCreditTxnAfterSelectHooks, tFLetterOfCreditTxnHook)
	case boil.AfterUpdateHook:
		tFLetterOfCreditTxnAfterUpdateHooks = append(tFLetterOfCreditTxnAfterUpdateHooks, tFLetterOfCreditTxnHook)
	case boil.AfterDeleteHook:
		tFLetterOfCreditTxnAfterDeleteHooks = append(tFLetterOfCreditTxnAfterDeleteHooks, tFLetterOfCreditTxnHook)
	case boil.AfterUpsertHook:
		tFLetterOfCreditTxnAfterUpsertHooks = append(tFLetterOfCreditTxnAfterUpsertHooks, tFLetterOfCreditTxnHook)
	}
}

// One returns a single tFLetterOfCreditTxn record from the query.
func (q tFLetterOfCreditTxnQuery) One(ctx context.Context, exec boil.ContextExecutor) (*TFLetterOfCreditTxn, error) {
	o := &TFLetterOfCreditTxn{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for TFLetterOfCreditTxn")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all TFLetterOfCreditTxn records from the query.
func (q tFLetterOfCreditTxnQuery) All(ctx context.Context, exec boil.ContextExecutor) (TFLetterOfCreditTxnSlice, error) {
	var o []*TFLetterOfCreditTxn

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to TFLetterOfCreditTxn slice")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all TFLetterOfCreditTxn records in the query.
func (q tFLetterOfCreditTxnQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count TFLetterOfCreditTxn rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q tFLetterOfCreditTxnQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if TFLetterOfCreditTxn exists")
	}

	return count > 0, nil
}

// Reference pointed to by the foreign key.
func (o *TFLetterOfCreditTxn) Reference(mods ...qm.QueryMod) tFLetterOfCreditQuery {
	queryMods := []qm.QueryMod{
		qm.Where("reference_id=?", o.ReferenceID),
	}

	queryMods = append(queryMods, mods...)

	query := TFLetterOfCredits(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCredit`")

	return query
}

// Bank pointed to by the foreign key.
func (o *TFLetterOfCreditTxn) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// Party pointed to by the foreign key.
func (o *TFLetterOfCreditTxn) Party(mods ...qm.QueryMod) partyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	return query
}

// LoadReference allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (tFLetterOfCreditTxnL) LoadReference(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCreditTxn interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCreditTxn
	var object *TFLetterOfCreditTxn

	if singular {
		object = maybeTFLetterOfCreditTxn.(*TFLetterOfCreditTxn)
	} else {
		slice = *maybeTFLetterOfCreditTxn.(*[]*TFLetterOfCreditTxn)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditTxnR{}
		}
		args = append(args, object.ReferenceID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditTxnR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCredit`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCredit")
	}

	var resultSlice []*TFLetterOfCredit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCredit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for TFLetterOfCredit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCredit")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Reference = foreign
		if foreign.R == nil {
			foreign.R = &tFLetterOfCreditR{}
		}
		foreign.R.ReferenceTFLetterOfCreditTxns = append(foreign.R.ReferenceTFLetterOfCreditTxns, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.Reference = foreign
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditR{}
				}
				foreign.R.ReferenceTFLetterOfCreditTxns = append(foreign.R.ReferenceTFLetterOfCreditTxns, local)
				break
			}
		}
	}

	return nil
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (tFLetterOfCreditTxnL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCreditTxn interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCreditTxn
	var object *TFLetterOfCreditTxn

	if singular {
		object = maybeTFLetterOfCreditTxn.(*TFLetterOfCreditTxn)
	} else {
		slice = *maybeTFLetterOfCreditTxn.(*[]*TFLetterOfCreditTxn)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditTxnR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditTxnR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankTFLetterOfCreditTxns = append(foreign.R.BankTFLetterOfCreditTxns, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankTFLetterOfCreditTxns = append(foreign.R.BankTFLetterOfCreditTxns, local)
				break
			}
		}
	}

	return nil
}

// LoadParty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (tFLetterOfCreditTxnL) LoadParty(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCreditTxn interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCreditTxn
	var object *TFLetterOfCreditTxn

	if singular {
		object = maybeTFLetterOfCreditTxn.(*TFLetterOfCreditTxn)
	} else {
		slice = *maybeTFLetterOfCreditTxn.(*[]*TFLetterOfCreditTxn)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditTxnR{}
		}
		args = append(args, object.PartyID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditTxnR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Party")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Party")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Party = foreign
		if foreign.R == nil {
			foreign.R = &partyR{}
		}
		foreign.R.PartyTFLetterOfCreditTxns = append(foreign.R.PartyTFLetterOfCreditTxns, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.Party = foreign
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.PartyTFLetterOfCreditTxns = append(foreign.R.PartyTFLetterOfCreditTxns, local)
				break
			}
		}
	}

	return nil
}

// SetReference of the tFLetterOfCreditTxn to the related item.
// Sets o.R.Reference to related.
// Adds o to related.R.ReferenceTFLetterOfCreditTxns.
func (o *TFLetterOfCreditTxn) SetReference(ctx context.Context, exec boil.ContextExecutor, insert bool, related *TFLetterOfCredit) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
		strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
	)
	values := []interface{}{related.ReferenceID, o.TFLCTXNID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ReferenceID = related.ReferenceID
	if o.R == nil {
		o.R = &tFLetterOfCreditTxnR{
			Reference: related,
		}
	} else {
		o.R.Reference = related
	}

	if related.R == nil {
		related.R = &tFLetterOfCreditR{
			ReferenceTFLetterOfCreditTxns: TFLetterOfCreditTxnSlice{o},
		}
	} else {
		related.R.ReferenceTFLetterOfCreditTxns = append(related.R.ReferenceTFLetterOfCreditTxns, o)
	}

	return nil
}

// SetBank of the tFLetterOfCreditTxn to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankTFLetterOfCreditTxns.
func (o *TFLetterOfCreditTxn) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.TFLCTXNID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &tFLetterOfCreditTxnR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankTFLetterOfCreditTxns: TFLetterOfCreditTxnSlice{o},
		}
	} else {
		related.R.BankTFLetterOfCreditTxns = append(related.R.BankTFLetterOfCreditTxns, o)
	}

	return nil
}

// SetParty of the tFLetterOfCreditTxn to the related item.
// Sets o.R.Party to related.
// Adds o to related.R.PartyTFLetterOfCreditTxns.
func (o *TFLetterOfCreditTxn) SetParty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Party) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
		strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
	)
	values := []interface{}{related.PartyID, o.TFLCTXNID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PartyID = related.PartyID
	if o.R == nil {
		o.R = &tFLetterOfCreditTxnR{
			Party: related,
		}
	} else {
		o.R.Party = related
	}

	if related.R == nil {
		related.R = &partyR{
			PartyTFLetterOfCreditTxns: TFLetterOfCreditTxnSlice{o},
		}
	} else {
		related.R.PartyTFLetterOfCreditTxns = append(related.R.PartyTFLetterOfCreditTxns, o)
	}

	return nil
}

// TFLetterOfCreditTxns retrieves all the records using an executor.
func TFLetterOfCreditTxns(mods ...qm.QueryMod) tFLetterOfCreditTxnQuery {
	mods = append(mods, qm.From("`TFLetterOfCreditTxn`"))
	return tFLetterOfCreditTxnQuery{NewQuery(mods...)}
}

// FindTFLetterOfCreditTxn retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTFLetterOfCreditTxn(ctx context.Context, exec boil.ContextExecutor, tFLCTXNID int, selectCols ...string) (*TFLetterOfCreditTxn, error) {
	tFLetterOfCreditTxnObj := &TFLetterOfCreditTxn{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `TFLetterOfCreditTxn` where `tf_lc_txn_id`=?", sel,
	)

	q := queries.Raw(query, tFLCTXNID)

	err := q.Bind(ctx, exec, tFLetterOfCreditTxnObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from TFLetterOfCreditTxn")
	}

	return tFLetterOfCreditTxnObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *TFLetterOfCreditTxn) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no TFLetterOfCreditTxn provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(tFLetterOfCreditTxnColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	tFLetterOfCreditTxnInsertCacheMut.RLock()
	cache, cached := tFLetterOfCreditTxnInsertCache[key]
	tFLetterOfCreditTxnInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			tFLetterOfCreditTxnColumns,
			tFLetterOfCreditTxnColumnsWithDefault,
			tFLetterOfCreditTxnColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `TFLetterOfCreditTxn` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `TFLetterOfCreditTxn` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `TFLetterOfCreditTxn` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into TFLetterOfCreditTxn")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.TFLCTXNID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for TFLetterOfCreditTxn")
	}

CacheNoHooks:
	if !cached {
		tFLetterOfCreditTxnInsertCacheMut.Lock()
		tFLetterOfCreditTxnInsertCache[key] = cache
		tFLetterOfCreditTxnInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the TFLetterOfCreditTxn.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *TFLetterOfCreditTxn) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	tFLetterOfCreditTxnUpdateCacheMut.RLock()
	cache, cached := tFLetterOfCreditTxnUpdateCache[key]
	tFLetterOfCreditTxnUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			tFLetterOfCreditTxnColumns,
			tFLetterOfCreditTxnPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update TFLetterOfCreditTxn, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, append(wl, tFLetterOfCreditTxnPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update TFLetterOfCreditTxn row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for TFLetterOfCreditTxn")
	}

	if !cached {
		tFLetterOfCreditTxnUpdateCacheMut.Lock()
		tFLetterOfCreditTxnUpdateCache[key] = cache
		tFLetterOfCreditTxnUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q tFLetterOfCreditTxnQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for TFLetterOfCreditTxn")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for TFLetterOfCreditTxn")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TFLetterOfCreditTxnSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditTxnPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditTxnPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in tFLetterOfCreditTxn slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all tFLetterOfCreditTxn")
	}
	return rowsAff, nil
}

var mySQLTFLetterOfCreditTxnUniqueColumns = []string{
	"tf_lc_txn_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *TFLetterOfCreditTxn) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no TFLetterOfCreditTxn provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(tFLetterOfCreditTxnColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLTFLetterOfCreditTxnUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	tFLetterOfCreditTxnUpsertCacheMut.RLock()
	cache, cached := tFLetterOfCreditTxnUpsertCache[key]
	tFLetterOfCreditTxnUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			tFLetterOfCreditTxnColumns,
			tFLetterOfCreditTxnColumnsWithDefault,
			tFLetterOfCreditTxnColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			tFLetterOfCreditTxnColumns,
			tFLetterOfCreditTxnPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert TFLetterOfCreditTxn, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "TFLetterOfCreditTxn", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `TFLetterOfCreditTxn` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for TFLetterOfCreditTxn")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(tFLetterOfCreditTxnType, tFLetterOfCreditTxnMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for TFLetterOfCreditTxn")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for TFLetterOfCreditTxn")
	}

CacheNoHooks:
	if !cached {
		tFLetterOfCreditTxnUpsertCacheMut.Lock()
		tFLetterOfCreditTxnUpsertCache[key] = cache
		tFLetterOfCreditTxnUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single TFLetterOfCreditTxn record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *TFLetterOfCreditTxn) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no TFLetterOfCreditTxn provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), tFLetterOfCreditTxnPrimaryKeyMapping)
	sql := "DELETE FROM `TFLetterOfCreditTxn` WHERE `tf_lc_txn_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from TFLetterOfCreditTxn")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for TFLetterOfCreditTxn")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q tFLetterOfCreditTxnQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no tFLetterOfCreditTxnQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from TFLetterOfCreditTxn")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for TFLetterOfCreditTxn")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TFLetterOfCreditTxnSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no TFLetterOfCreditTxn slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(tFLetterOfCreditTxnBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditTxnPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `TFLetterOfCreditTxn` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditTxnPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from tFLetterOfCreditTxn slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for TFLetterOfCreditTxn")
	}

	if len(tFLetterOfCreditTxnAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *TFLetterOfCreditTxn) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTFLetterOfCreditTxn(ctx, exec, o.TFLCTXNID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TFLetterOfCreditTxnSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TFLetterOfCreditTxnSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditTxnPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `TFLetterOfCreditTxn`.* FROM `TFLetterOfCreditTxn` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditTxnPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in TFLetterOfCreditTxnSlice")
	}

	*o = slice

	return nil
}

// TFLetterOfCreditTxnExists checks if the TFLetterOfCreditTxn row exists.
func TFLetterOfCreditTxnExists(ctx context.Context, exec boil.ContextExecutor, tFLCTXNID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `TFLetterOfCreditTxn` where `tf_lc_txn_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, tFLCTXNID)
	}

	row := exec.QueryRowContext(ctx, sql, tFLCTXNID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if TFLetterOfCreditTxn exists")
	}

	return exists, nil
}
