// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Party is an object representing the database table.
type Party struct {
	PartyID         int         `boil:"party_id" json:"party_id" toml:"party_id" yaml:"party_id"`
	PartyType       string      `boil:"party_type" json:"party_type" toml:"party_type" yaml:"party_type"`
	BankID          int         `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	CanOpenAccounts null.String `boil:"can_open_accounts" json:"can_open_accounts,omitempty" toml:"can_open_accounts" yaml:"can_open_accounts,omitempty"`
	CanGuarantee    null.String `boil:"can_guarantee" json:"can_guarantee,omitempty" toml:"can_guarantee" yaml:"can_guarantee,omitempty"`
	RequireID       null.String `boil:"require_id" json:"require_id,omitempty" toml:"require_id" yaml:"require_id,omitempty"`
	Description     null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	IsDebarred      null.String `boil:"is_debarred" json:"is_debarred,omitempty" toml:"is_debarred" yaml:"is_debarred,omitempty"`
	Ispep           null.String `boil:"ispep" json:"ispep,omitempty" toml:"ispep" yaml:"ispep,omitempty"`
	MakerDate       time.Time   `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate     null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID         string      `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID       null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy      null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate    null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *partyR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L partyL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PartyColumns = struct {
	PartyID         string
	PartyType       string
	BankID          string
	CanOpenAccounts string
	CanGuarantee    string
	RequireID       string
	Description     string
	IsDebarred      string
	Ispep           string
	MakerDate       string
	CheckerDate     string
	MakerID         string
	CheckerID       string
	ModifiedBy      string
	ModifiedDate    string
}{
	PartyID:         "party_id",
	PartyType:       "party_type",
	BankID:          "bank_id",
	CanOpenAccounts: "can_open_accounts",
	CanGuarantee:    "can_guarantee",
	RequireID:       "require_id",
	Description:     "description",
	IsDebarred:      "is_debarred",
	Ispep:           "ispep",
	MakerDate:       "maker_date",
	CheckerDate:     "checker_date",
	MakerID:         "maker_id",
	CheckerID:       "checker_id",
	ModifiedBy:      "modified_by",
	ModifiedDate:    "modified_date",
}

// Generated where

var PartyWhere = struct {
	PartyID         whereHelperint
	PartyType       whereHelperstring
	BankID          whereHelperint
	CanOpenAccounts whereHelpernull_String
	CanGuarantee    whereHelpernull_String
	RequireID       whereHelpernull_String
	Description     whereHelpernull_String
	IsDebarred      whereHelpernull_String
	Ispep           whereHelpernull_String
	MakerDate       whereHelpertime_Time
	CheckerDate     whereHelpernull_Time
	MakerID         whereHelperstring
	CheckerID       whereHelpernull_String
	ModifiedBy      whereHelpernull_String
	ModifiedDate    whereHelpernull_Time
}{
	PartyID:         whereHelperint{field: `party_id`},
	PartyType:       whereHelperstring{field: `party_type`},
	BankID:          whereHelperint{field: `bank_id`},
	CanOpenAccounts: whereHelpernull_String{field: `can_open_accounts`},
	CanGuarantee:    whereHelpernull_String{field: `can_guarantee`},
	RequireID:       whereHelpernull_String{field: `require_id`},
	Description:     whereHelpernull_String{field: `description`},
	IsDebarred:      whereHelpernull_String{field: `is_debarred`},
	Ispep:           whereHelpernull_String{field: `ispep`},
	MakerDate:       whereHelpertime_Time{field: `maker_date`},
	CheckerDate:     whereHelpernull_Time{field: `checker_date`},
	MakerID:         whereHelperstring{field: `maker_id`},
	CheckerID:       whereHelpernull_String{field: `checker_id`},
	ModifiedBy:      whereHelpernull_String{field: `modified_by`},
	ModifiedDate:    whereHelpernull_Time{field: `modified_date`},
}

// PartyRels is where relationship names are stored.
var PartyRels = struct {
	Bank                           string
	PartyCollateral                string
	PartyOrganization              string
	PartyOrganizationFinancialInfo string
	PartyPerson                    string
	PartyPersonFinancialInfo       string
	PartyRTP                       string
	PartyAccountOwners             string
	PartyAddresses                 string
	PayeeBillers                   string
	PayerBillers                   string
	PartyBorrowers                 string
	PartyBudgets                   string
	PartyCreditOriginations        string
	PartyCryptographies            string
	PartyCustomerGoalSummaries     string
	PartyCustomerOffers            string
	PartyCustomerRatings           string
	PartyDevices                   string
	DocumentHolderPartyDocuments   string
	PartyEmails                    string
	PartyFxDeals                   string
	LinkedPartyJointAccounts       string
	PrimaryPartyJointAccounts      string
	PartyLineOfCredits             string
	PartyNotifications             string
	FromPartyPaymentBills          string
	TraderPartyPaymentFxTrades     string
	PartyPhoneNumbers              string
	PartyPortfolioGoalSummaries    string
	PayeeRegisteredBillers         string
	PartyRisks                     string
	FromPartyRtpRequests           string
	PartySocialInfos               string
	PartyTFBankGuarantees          string
	PartyTFCharges                 string
	PartyTFChargesTxns             string
	PartyTFExportImportsBills      string
	PartyTFInterests               string
	PartyTFInterestTxns            string
	PartyTFLcLetters               string
	PartyTFLcLetterTxns            string
	PartyTFLetterOfCredits         string
	PartyTFLetterOfCreditTxns      string
	PartyTFParties                 string
	PartyTFPartyTxns               string
	PartyTFRisks                   string
	PartyTFSettlements             string
	FromPartyTrades                string
	ToPartyTrades                  string
	FromPartyTransfers             string
	PartyUserLogins                string
}{
	Bank:                           "Bank",
	PartyCollateral:                "PartyCollateral",
	PartyOrganization:              "PartyOrganization",
	PartyOrganizationFinancialInfo: "PartyOrganizationFinancialInfo",
	PartyPerson:                    "PartyPerson",
	PartyPersonFinancialInfo:       "PartyPersonFinancialInfo",
	PartyRTP:                       "PartyRTP",
	PartyAccountOwners:             "PartyAccountOwners",
	PartyAddresses:                 "PartyAddresses",
	PayeeBillers:                   "PayeeBillers",
	PayerBillers:                   "PayerBillers",
	PartyBorrowers:                 "PartyBorrowers",
	PartyBudgets:                   "PartyBudgets",
	PartyCreditOriginations:        "PartyCreditOriginations",
	PartyCryptographies:            "PartyCryptographies",
	PartyCustomerGoalSummaries:     "PartyCustomerGoalSummaries",
	PartyCustomerOffers:            "PartyCustomerOffers",
	PartyCustomerRatings:           "PartyCustomerRatings",
	PartyDevices:                   "PartyDevices",
	DocumentHolderPartyDocuments:   "DocumentHolderPartyDocuments",
	PartyEmails:                    "PartyEmails",
	PartyFxDeals:                   "PartyFxDeals",
	LinkedPartyJointAccounts:       "LinkedPartyJointAccounts",
	PrimaryPartyJointAccounts:      "PrimaryPartyJointAccounts",
	PartyLineOfCredits:             "PartyLineOfCredits",
	PartyNotifications:             "PartyNotifications",
	FromPartyPaymentBills:          "FromPartyPaymentBills",
	TraderPartyPaymentFxTrades:     "TraderPartyPaymentFxTrades",
	PartyPhoneNumbers:              "PartyPhoneNumbers",
	PartyPortfolioGoalSummaries:    "PartyPortfolioGoalSummaries",
	PayeeRegisteredBillers:         "PayeeRegisteredBillers",
	PartyRisks:                     "PartyRisks",
	FromPartyRtpRequests:           "FromPartyRtpRequests",
	PartySocialInfos:               "PartySocialInfos",
	PartyTFBankGuarantees:          "PartyTFBankGuarantees",
	PartyTFCharges:                 "PartyTFCharges",
	PartyTFChargesTxns:             "PartyTFChargesTxns",
	PartyTFExportImportsBills:      "PartyTFExportImportsBills",
	PartyTFInterests:               "PartyTFInterests",
	PartyTFInterestTxns:            "PartyTFInterestTxns",
	PartyTFLcLetters:               "PartyTFLcLetters",
	PartyTFLcLetterTxns:            "PartyTFLcLetterTxns",
	PartyTFLetterOfCredits:         "PartyTFLetterOfCredits",
	PartyTFLetterOfCreditTxns:      "PartyTFLetterOfCreditTxns",
	PartyTFParties:                 "PartyTFParties",
	PartyTFPartyTxns:               "PartyTFPartyTxns",
	PartyTFRisks:                   "PartyTFRisks",
	PartyTFSettlements:             "PartyTFSettlements",
	FromPartyTrades:                "FromPartyTrades",
	ToPartyTrades:                  "ToPartyTrades",
	FromPartyTransfers:             "FromPartyTransfers",
	PartyUserLogins:                "PartyUserLogins",
}

// partyR is where relationships are stored.
type partyR struct {
	Bank                           *Bank
	PartyCollateral                *Collateral
	PartyOrganization              *Organization
	PartyOrganizationFinancialInfo *OrganizationFinancialInfo
	PartyPerson                    *Person
	PartyPersonFinancialInfo       *PersonFinancialInfo
	PartyRTP                       *RTP
	PartyAccountOwners             AccountOwnerSlice
	PartyAddresses                 AddressSlice
	PayeeBillers                   BillerSlice
	PayerBillers                   BillerSlice
	PartyBorrowers                 BorrowerSlice
	PartyBudgets                   BudgetSlice
	PartyCreditOriginations        CreditOriginationSlice
	PartyCryptographies            CryptographySlice
	PartyCustomerGoalSummaries     CustomerGoalSummarySlice
	PartyCustomerOffers            CustomerOfferSlice
	PartyCustomerRatings           CustomerRatingSlice
	PartyDevices                   DeviceSlice
	DocumentHolderPartyDocuments   DocumentSlice
	PartyEmails                    EmailSlice
	PartyFxDeals                   FxDealSlice
	LinkedPartyJointAccounts       JointAccountSlice
	PrimaryPartyJointAccounts      JointAccountSlice
	PartyLineOfCredits             LineOfCreditSlice
	PartyNotifications             NotificationSlice
	FromPartyPaymentBills          PaymentBillSlice
	TraderPartyPaymentFxTrades     PaymentFxTradeSlice
	PartyPhoneNumbers              PhoneNumberSlice
	PartyPortfolioGoalSummaries    PortfolioGoalSummarySlice
	PayeeRegisteredBillers         RegisteredBillerSlice
	PartyRisks                     RiskSlice
	FromPartyRtpRequests           RtpRequestSlice
	PartySocialInfos               SocialInfoSlice
	PartyTFBankGuarantees          TFBankGuaranteeSlice
	PartyTFCharges                 TFChargeSlice
	PartyTFChargesTxns             TFChargesTxnSlice
	PartyTFExportImportsBills      TFExportImportsBillSlice
	PartyTFInterests               TFInterestSlice
	PartyTFInterestTxns            TFInterestTxnSlice
	PartyTFLcLetters               TFLcLetterSlice
	PartyTFLcLetterTxns            TFLcLetterTxnSlice
	PartyTFLetterOfCredits         TFLetterOfCreditSlice
	PartyTFLetterOfCreditTxns      TFLetterOfCreditTxnSlice
	PartyTFParties                 TFPartySlice
	PartyTFPartyTxns               TFPartyTxnSlice
	PartyTFRisks                   TFRiskSlice
	PartyTFSettlements             TFSettlementSlice
	FromPartyTrades                TradeSlice
	ToPartyTrades                  TradeSlice
	FromPartyTransfers             TransferSlice
	PartyUserLogins                UserLoginSlice
}

// NewStruct creates a new relationship struct
func (*partyR) NewStruct() *partyR {
	return &partyR{}
}

// partyL is where Load methods for each relationship are stored.
type partyL struct{}

var (
	partyColumns               = []string{"party_id", "party_type", "bank_id", "can_open_accounts", "can_guarantee", "require_id", "description", "is_debarred", "ispep", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	partyColumnsWithoutDefault = []string{"party_id", "party_type", "bank_id", "can_open_accounts", "can_guarantee", "require_id", "description", "is_debarred", "ispep", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	partyColumnsWithDefault    = []string{}
	partyPrimaryKeyColumns     = []string{"party_id"}
)

type (
	// PartySlice is an alias for a slice of pointers to Party.
	// This should generally be used opposed to []Party.
	PartySlice []*Party
	// PartyHook is the signature for custom Party hook methods
	PartyHook func(context.Context, boil.ContextExecutor, *Party) error

	partyQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	partyType                 = reflect.TypeOf(&Party{})
	partyMapping              = queries.MakeStructMapping(partyType)
	partyPrimaryKeyMapping, _ = queries.BindMapping(partyType, partyMapping, partyPrimaryKeyColumns)
	partyInsertCacheMut       sync.RWMutex
	partyInsertCache          = make(map[string]insertCache)
	partyUpdateCacheMut       sync.RWMutex
	partyUpdateCache          = make(map[string]updateCache)
	partyUpsertCacheMut       sync.RWMutex
	partyUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var partyBeforeInsertHooks []PartyHook
var partyBeforeUpdateHooks []PartyHook
var partyBeforeDeleteHooks []PartyHook
var partyBeforeUpsertHooks []PartyHook

var partyAfterInsertHooks []PartyHook
var partyAfterSelectHooks []PartyHook
var partyAfterUpdateHooks []PartyHook
var partyAfterDeleteHooks []PartyHook
var partyAfterUpsertHooks []PartyHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Party) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Party) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Party) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Party) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Party) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Party) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Party) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Party) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Party) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range partyAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPartyHook registers your hook function for all future operations.
func AddPartyHook(hookPoint boil.HookPoint, partyHook PartyHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		partyBeforeInsertHooks = append(partyBeforeInsertHooks, partyHook)
	case boil.BeforeUpdateHook:
		partyBeforeUpdateHooks = append(partyBeforeUpdateHooks, partyHook)
	case boil.BeforeDeleteHook:
		partyBeforeDeleteHooks = append(partyBeforeDeleteHooks, partyHook)
	case boil.BeforeUpsertHook:
		partyBeforeUpsertHooks = append(partyBeforeUpsertHooks, partyHook)
	case boil.AfterInsertHook:
		partyAfterInsertHooks = append(partyAfterInsertHooks, partyHook)
	case boil.AfterSelectHook:
		partyAfterSelectHooks = append(partyAfterSelectHooks, partyHook)
	case boil.AfterUpdateHook:
		partyAfterUpdateHooks = append(partyAfterUpdateHooks, partyHook)
	case boil.AfterDeleteHook:
		partyAfterDeleteHooks = append(partyAfterDeleteHooks, partyHook)
	case boil.AfterUpsertHook:
		partyAfterUpsertHooks = append(partyAfterUpsertHooks, partyHook)
	}
}

// One returns a single party record from the query.
func (q partyQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Party, error) {
	o := &Party{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Parties")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Party records from the query.
func (q partyQuery) All(ctx context.Context, exec boil.ContextExecutor) (PartySlice, error) {
	var o []*Party

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Party slice")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Party records in the query.
func (q partyQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Parties rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q partyQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Parties exists")
	}

	return count > 0, nil
}

// Bank pointed to by the foreign key.
func (o *Party) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// PartyCollateral pointed to by the foreign key.
func (o *Party) PartyCollateral(mods ...qm.QueryMod) collateralQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Collaterals(queryMods...)
	queries.SetFrom(query.Query, "`Collateral`")

	return query
}

// PartyOrganization pointed to by the foreign key.
func (o *Party) PartyOrganization(mods ...qm.QueryMod) organizationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Organizations(queryMods...)
	queries.SetFrom(query.Query, "`Organization`")

	return query
}

// PartyOrganizationFinancialInfo pointed to by the foreign key.
func (o *Party) PartyOrganizationFinancialInfo(mods ...qm.QueryMod) organizationFinancialInfoQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := OrganizationFinancialInfos(queryMods...)
	queries.SetFrom(query.Query, "`OrganizationFinancialInfo`")

	return query
}

// PartyPerson pointed to by the foreign key.
func (o *Party) PartyPerson(mods ...qm.QueryMod) personQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Persons(queryMods...)
	queries.SetFrom(query.Query, "`Person`")

	return query
}

// PartyPersonFinancialInfo pointed to by the foreign key.
func (o *Party) PartyPersonFinancialInfo(mods ...qm.QueryMod) personFinancialInfoQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := PersonFinancialInfos(queryMods...)
	queries.SetFrom(query.Query, "`PersonFinancialInfo`")

	return query
}

// PartyRTP pointed to by the foreign key.
func (o *Party) PartyRTP(mods ...qm.QueryMod) rtpQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := RTPS(queryMods...)
	queries.SetFrom(query.Query, "`Rtp`")

	return query
}

// PartyAccountOwners retrieves all the AccountOwner's AccountOwners with an executor via party_id column.
func (o *Party) PartyAccountOwners(mods ...qm.QueryMod) accountOwnerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountOwners`.`party_id`=?", o.PartyID),
	)

	query := AccountOwners(queryMods...)
	queries.SetFrom(query.Query, "`AccountOwners`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountOwners`.*"})
	}

	return query
}

// PartyAddresses retrieves all the Address's Addresses with an executor via party_id column.
func (o *Party) PartyAddresses(mods ...qm.QueryMod) addressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Address`.`party_id`=?", o.PartyID),
	)

	query := Addresses(queryMods...)
	queries.SetFrom(query.Query, "`Address`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Address`.*"})
	}

	return query
}

// PayeeBillers retrieves all the Biller's Billers with an executor via payee_id column.
func (o *Party) PayeeBillers(mods ...qm.QueryMod) billerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Biller`.`payee_id`=?", o.PartyID),
	)

	query := Billers(queryMods...)
	queries.SetFrom(query.Query, "`Biller`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Biller`.*"})
	}

	return query
}

// PayerBillers retrieves all the Biller's Billers with an executor via payer_id column.
func (o *Party) PayerBillers(mods ...qm.QueryMod) billerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Biller`.`payer_id`=?", o.PartyID),
	)

	query := Billers(queryMods...)
	queries.SetFrom(query.Query, "`Biller`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Biller`.*"})
	}

	return query
}

// PartyBorrowers retrieves all the Borrower's Borrowers with an executor via party_id column.
func (o *Party) PartyBorrowers(mods ...qm.QueryMod) borrowerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Borrower`.`party_id`=?", o.PartyID),
	)

	query := Borrowers(queryMods...)
	queries.SetFrom(query.Query, "`Borrower`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Borrower`.*"})
	}

	return query
}

// PartyBudgets retrieves all the Budget's Budgets with an executor via party_id column.
func (o *Party) PartyBudgets(mods ...qm.QueryMod) budgetQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Budget`.`party_id`=?", o.PartyID),
	)

	query := Budgets(queryMods...)
	queries.SetFrom(query.Query, "`Budget`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Budget`.*"})
	}

	return query
}

// PartyCreditOriginations retrieves all the CreditOrigination's CreditOriginations with an executor via party_id column.
func (o *Party) PartyCreditOriginations(mods ...qm.QueryMod) creditOriginationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CreditOrigination`.`party_id`=?", o.PartyID),
	)

	query := CreditOriginations(queryMods...)
	queries.SetFrom(query.Query, "`CreditOrigination`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CreditOrigination`.*"})
	}

	return query
}

// PartyCryptographies retrieves all the Cryptography's Cryptographies with an executor via party_id column.
func (o *Party) PartyCryptographies(mods ...qm.QueryMod) cryptographyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Cryptography`.`party_id`=?", o.PartyID),
	)

	query := Cryptographies(queryMods...)
	queries.SetFrom(query.Query, "`Cryptography`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Cryptography`.*"})
	}

	return query
}

// PartyCustomerGoalSummaries retrieves all the CustomerGoalSummary's CustomerGoalSummaries with an executor via party_id column.
func (o *Party) PartyCustomerGoalSummaries(mods ...qm.QueryMod) customerGoalSummaryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CustomerGoalSummary`.`party_id`=?", o.PartyID),
	)

	query := CustomerGoalSummaries(queryMods...)
	queries.SetFrom(query.Query, "`CustomerGoalSummary`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CustomerGoalSummary`.*"})
	}

	return query
}

// PartyCustomerOffers retrieves all the CustomerOffer's CustomerOffers with an executor via party_id column.
func (o *Party) PartyCustomerOffers(mods ...qm.QueryMod) customerOfferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CustomerOffer`.`party_id`=?", o.PartyID),
	)

	query := CustomerOffers(queryMods...)
	queries.SetFrom(query.Query, "`CustomerOffer`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CustomerOffer`.*"})
	}

	return query
}

// PartyCustomerRatings retrieves all the CustomerRating's CustomerRatings with an executor via party_id column.
func (o *Party) PartyCustomerRatings(mods ...qm.QueryMod) customerRatingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CustomerRating`.`party_id`=?", o.PartyID),
	)

	query := CustomerRatings(queryMods...)
	queries.SetFrom(query.Query, "`CustomerRating`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CustomerRating`.*"})
	}

	return query
}

// PartyDevices retrieves all the Device's Devices with an executor via party_id column.
func (o *Party) PartyDevices(mods ...qm.QueryMod) deviceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Devices`.`party_id`=?", o.PartyID),
	)

	query := Devices(queryMods...)
	queries.SetFrom(query.Query, "`Devices`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Devices`.*"})
	}

	return query
}

// DocumentHolderPartyDocuments retrieves all the Document's Documents with an executor via document_holder_party_id column.
func (o *Party) DocumentHolderPartyDocuments(mods ...qm.QueryMod) documentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Document`.`document_holder_party_id`=?", o.PartyID),
	)

	query := Documents(queryMods...)
	queries.SetFrom(query.Query, "`Document`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Document`.*"})
	}

	return query
}

// PartyEmails retrieves all the Email's Emails with an executor via party_id column.
func (o *Party) PartyEmails(mods ...qm.QueryMod) emailQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Emails`.`party_id`=?", o.PartyID),
	)

	query := Emails(queryMods...)
	queries.SetFrom(query.Query, "`Emails`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Emails`.*"})
	}

	return query
}

// PartyFxDeals retrieves all the FxDeal's FxDeals with an executor via party_id column.
func (o *Party) PartyFxDeals(mods ...qm.QueryMod) fxDealQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`FxDeals`.`party_id`=?", o.PartyID),
	)

	query := FxDeals(queryMods...)
	queries.SetFrom(query.Query, "`FxDeals`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`FxDeals`.*"})
	}

	return query
}

// LinkedPartyJointAccounts retrieves all the JointAccount's JointAccounts with an executor via linked_party_id column.
func (o *Party) LinkedPartyJointAccounts(mods ...qm.QueryMod) jointAccountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JointAccount`.`linked_party_id`=?", o.PartyID),
	)

	query := JointAccounts(queryMods...)
	queries.SetFrom(query.Query, "`JointAccount`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JointAccount`.*"})
	}

	return query
}

// PrimaryPartyJointAccounts retrieves all the JointAccount's JointAccounts with an executor via primary_party_id column.
func (o *Party) PrimaryPartyJointAccounts(mods ...qm.QueryMod) jointAccountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JointAccount`.`primary_party_id`=?", o.PartyID),
	)

	query := JointAccounts(queryMods...)
	queries.SetFrom(query.Query, "`JointAccount`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JointAccount`.*"})
	}

	return query
}

// PartyLineOfCredits retrieves all the LineOfCredit's LineOfCredits with an executor via party_id column.
func (o *Party) PartyLineOfCredits(mods ...qm.QueryMod) lineOfCreditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`LineOfCredit`.`party_id`=?", o.PartyID),
	)

	query := LineOfCredits(queryMods...)
	queries.SetFrom(query.Query, "`LineOfCredit`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`LineOfCredit`.*"})
	}

	return query
}

// PartyNotifications retrieves all the Notification's Notifications with an executor via party_id column.
func (o *Party) PartyNotifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Notifications`.`party_id`=?", o.PartyID),
	)

	query := Notifications(queryMods...)
	queries.SetFrom(query.Query, "`Notifications`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Notifications`.*"})
	}

	return query
}

// FromPartyPaymentBills retrieves all the PaymentBill's PaymentBills with an executor via from_party_id column.
func (o *Party) FromPartyPaymentBills(mods ...qm.QueryMod) paymentBillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentBill`.`from_party_id`=?", o.PartyID),
	)

	query := PaymentBills(queryMods...)
	queries.SetFrom(query.Query, "`PaymentBill`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentBill`.*"})
	}

	return query
}

// TraderPartyPaymentFxTrades retrieves all the PaymentFxTrade's PaymentFxTrades with an executor via trader_party_id column.
func (o *Party) TraderPartyPaymentFxTrades(mods ...qm.QueryMod) paymentFxTradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentFxTrade`.`trader_party_id`=?", o.PartyID),
	)

	query := PaymentFxTrades(queryMods...)
	queries.SetFrom(query.Query, "`PaymentFxTrade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentFxTrade`.*"})
	}

	return query
}

// PartyPhoneNumbers retrieves all the PhoneNumber's PhoneNumbers with an executor via party_id column.
func (o *Party) PartyPhoneNumbers(mods ...qm.QueryMod) phoneNumberQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PhoneNumbers`.`party_id`=?", o.PartyID),
	)

	query := PhoneNumbers(queryMods...)
	queries.SetFrom(query.Query, "`PhoneNumbers`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PhoneNumbers`.*"})
	}

	return query
}

// PartyPortfolioGoalSummaries retrieves all the PortfolioGoalSummary's PortfolioGoalSummaries with an executor via party_id column.
func (o *Party) PartyPortfolioGoalSummaries(mods ...qm.QueryMod) portfolioGoalSummaryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PortfolioGoalSummary`.`party_id`=?", o.PartyID),
	)

	query := PortfolioGoalSummaries(queryMods...)
	queries.SetFrom(query.Query, "`PortfolioGoalSummary`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PortfolioGoalSummary`.*"})
	}

	return query
}

// PayeeRegisteredBillers retrieves all the RegisteredBiller's RegisteredBillers with an executor via payee_id column.
func (o *Party) PayeeRegisteredBillers(mods ...qm.QueryMod) registeredBillerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`RegisteredBiller`.`payee_id`=?", o.PartyID),
	)

	query := RegisteredBillers(queryMods...)
	queries.SetFrom(query.Query, "`RegisteredBiller`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`RegisteredBiller`.*"})
	}

	return query
}

// PartyRisks retrieves all the Risk's Risks with an executor via party_id column.
func (o *Party) PartyRisks(mods ...qm.QueryMod) riskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Risk`.`party_id`=?", o.PartyID),
	)

	query := Risks(queryMods...)
	queries.SetFrom(query.Query, "`Risk`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Risk`.*"})
	}

	return query
}

// FromPartyRtpRequests retrieves all the RtpRequest's RtpRequests with an executor via from_party_id column.
func (o *Party) FromPartyRtpRequests(mods ...qm.QueryMod) rtpRequestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`RtpRequest`.`from_party_id`=?", o.PartyID),
	)

	query := RtpRequests(queryMods...)
	queries.SetFrom(query.Query, "`RtpRequest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`RtpRequest`.*"})
	}

	return query
}

// PartySocialInfos retrieves all the SocialInfo's SocialInfos with an executor via party_id column.
func (o *Party) PartySocialInfos(mods ...qm.QueryMod) socialInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`SocialInfo`.`party_id`=?", o.PartyID),
	)

	query := SocialInfos(queryMods...)
	queries.SetFrom(query.Query, "`SocialInfo`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`SocialInfo`.*"})
	}

	return query
}

// PartyTFBankGuarantees retrieves all the TFBankGuarantee's TFBankGuarantees with an executor via party_id column.
func (o *Party) PartyTFBankGuarantees(mods ...qm.QueryMod) tFBankGuaranteeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFBankGuarantee`.`party_id`=?", o.PartyID),
	)

	query := TFBankGuarantees(queryMods...)
	queries.SetFrom(query.Query, "`TFBankGuarantee`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFBankGuarantee`.*"})
	}

	return query
}

// PartyTFCharges retrieves all the TFCharge's TFCharges with an executor via party_id column.
func (o *Party) PartyTFCharges(mods ...qm.QueryMod) tFChargeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFCharges`.`party_id`=?", o.PartyID),
	)

	query := TFCharges(queryMods...)
	queries.SetFrom(query.Query, "`TFCharges`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFCharges`.*"})
	}

	return query
}

// PartyTFChargesTxns retrieves all the TFChargesTxn's TFChargesTxns with an executor via party_id column.
func (o *Party) PartyTFChargesTxns(mods ...qm.QueryMod) tFChargesTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFChargesTxn`.`party_id`=?", o.PartyID),
	)

	query := TFChargesTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFChargesTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFChargesTxn`.*"})
	}

	return query
}

// PartyTFExportImportsBills retrieves all the TFExportImportsBill's TFExportImportsBills with an executor via party_id column.
func (o *Party) PartyTFExportImportsBills(mods ...qm.QueryMod) tFExportImportsBillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFExportImportsBill`.`party_id`=?", o.PartyID),
	)

	query := TFExportImportsBills(queryMods...)
	queries.SetFrom(query.Query, "`TFExportImportsBill`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFExportImportsBill`.*"})
	}

	return query
}

// PartyTFInterests retrieves all the TFInterest's TFInterests with an executor via party_id column.
func (o *Party) PartyTFInterests(mods ...qm.QueryMod) tFInterestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFInterest`.`party_id`=?", o.PartyID),
	)

	query := TFInterests(queryMods...)
	queries.SetFrom(query.Query, "`TFInterest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFInterest`.*"})
	}

	return query
}

// PartyTFInterestTxns retrieves all the TFInterestTxn's TFInterestTxns with an executor via party_id column.
func (o *Party) PartyTFInterestTxns(mods ...qm.QueryMod) tFInterestTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFInterestTxn`.`party_id`=?", o.PartyID),
	)

	query := TFInterestTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFInterestTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFInterestTxn`.*"})
	}

	return query
}

// PartyTFLcLetters retrieves all the TFLcLetter's TFLcLetters with an executor via party_id column.
func (o *Party) PartyTFLcLetters(mods ...qm.QueryMod) tFLcLetterQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLcLetter`.`party_id`=?", o.PartyID),
	)

	query := TFLcLetters(queryMods...)
	queries.SetFrom(query.Query, "`TFLcLetter`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLcLetter`.*"})
	}

	return query
}

// PartyTFLcLetterTxns retrieves all the TFLcLetterTxn's TFLcLetterTxns with an executor via party_id column.
func (o *Party) PartyTFLcLetterTxns(mods ...qm.QueryMod) tFLcLetterTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLcLetterTxn`.`party_id`=?", o.PartyID),
	)

	query := TFLcLetterTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFLcLetterTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLcLetterTxn`.*"})
	}

	return query
}

// PartyTFLetterOfCredits retrieves all the TFLetterOfCredit's TFLetterOfCredits with an executor via party_id column.
func (o *Party) PartyTFLetterOfCredits(mods ...qm.QueryMod) tFLetterOfCreditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLetterOfCredit`.`party_id`=?", o.PartyID),
	)

	query := TFLetterOfCredits(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCredit`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLetterOfCredit`.*"})
	}

	return query
}

// PartyTFLetterOfCreditTxns retrieves all the TFLetterOfCreditTxn's TFLetterOfCreditTxns with an executor via party_id column.
func (o *Party) PartyTFLetterOfCreditTxns(mods ...qm.QueryMod) tFLetterOfCreditTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLetterOfCreditTxn`.`party_id`=?", o.PartyID),
	)

	query := TFLetterOfCreditTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCreditTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLetterOfCreditTxn`.*"})
	}

	return query
}

// PartyTFParties retrieves all the TFParty's TFParties with an executor via party_id column.
func (o *Party) PartyTFParties(mods ...qm.QueryMod) tFPartyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFParty`.`party_id`=?", o.PartyID),
	)

	query := TFParties(queryMods...)
	queries.SetFrom(query.Query, "`TFParty`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFParty`.*"})
	}

	return query
}

// PartyTFPartyTxns retrieves all the TFPartyTxn's TFPartyTxns with an executor via party_id column.
func (o *Party) PartyTFPartyTxns(mods ...qm.QueryMod) tFPartyTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFPartyTxn`.`party_id`=?", o.PartyID),
	)

	query := TFPartyTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFPartyTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFPartyTxn`.*"})
	}

	return query
}

// PartyTFRisks retrieves all the TFRisk's TFRisks with an executor via party_id column.
func (o *Party) PartyTFRisks(mods ...qm.QueryMod) tFRiskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFRisk`.`party_id`=?", o.PartyID),
	)

	query := TFRisks(queryMods...)
	queries.SetFrom(query.Query, "`TFRisk`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFRisk`.*"})
	}

	return query
}

// PartyTFSettlements retrieves all the TFSettlement's TFSettlements with an executor via party_id column.
func (o *Party) PartyTFSettlements(mods ...qm.QueryMod) tFSettlementQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFSettlement`.`party_id`=?", o.PartyID),
	)

	query := TFSettlements(queryMods...)
	queries.SetFrom(query.Query, "`TFSettlement`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFSettlement`.*"})
	}

	return query
}

// FromPartyTrades retrieves all the Trade's Trades with an executor via from_party_id column.
func (o *Party) FromPartyTrades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Trade`.`from_party_id`=?", o.PartyID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "`Trade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Trade`.*"})
	}

	return query
}

// ToPartyTrades retrieves all the Trade's Trades with an executor via to_party_id column.
func (o *Party) ToPartyTrades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Trade`.`to_party_id`=?", o.PartyID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "`Trade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Trade`.*"})
	}

	return query
}

// FromPartyTransfers retrieves all the Transfer's Transfers with an executor via from_party_id column.
func (o *Party) FromPartyTransfers(mods ...qm.QueryMod) transferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Transfer`.`from_party_id`=?", o.PartyID),
	)

	query := Transfers(queryMods...)
	queries.SetFrom(query.Query, "`Transfer`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Transfer`.*"})
	}

	return query
}

// PartyUserLogins retrieves all the UserLogin's UserLogins with an executor via party_id column.
func (o *Party) PartyUserLogins(mods ...qm.QueryMod) userLoginQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`UserLogin`.`party_id`=?", o.PartyID),
	)

	query := UserLogins(queryMods...)
	queries.SetFrom(query.Query, "`UserLogin`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`UserLogin`.*"})
	}

	return query
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (partyL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankParties = append(foreign.R.BankParties, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankParties = append(foreign.R.BankParties, local)
				break
			}
		}
	}

	return nil
}

// LoadPartyCollateral allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyCollateral(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Collateral`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Collateral")
	}

	var resultSlice []*Collateral
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Collateral")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Collateral")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Collateral")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyCollateral = foreign
		if foreign.R == nil {
			foreign.R = &collateralR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCollateral = foreign
				if foreign.R == nil {
					foreign.R = &collateralR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyOrganization allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyOrganization(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Organization`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Organization")
	}

	var resultSlice []*Organization
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Organization")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Organization")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Organization")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyOrganization = foreign
		if foreign.R == nil {
			foreign.R = &organizationR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyOrganization = foreign
				if foreign.R == nil {
					foreign.R = &organizationR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyOrganizationFinancialInfo allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyOrganizationFinancialInfo(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`OrganizationFinancialInfo`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrganizationFinancialInfo")
	}

	var resultSlice []*OrganizationFinancialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrganizationFinancialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for OrganizationFinancialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for OrganizationFinancialInfo")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyOrganizationFinancialInfo = foreign
		if foreign.R == nil {
			foreign.R = &organizationFinancialInfoR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyOrganizationFinancialInfo = foreign
				if foreign.R == nil {
					foreign.R = &organizationFinancialInfoR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyPerson allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyPerson(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Person`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Person")
	}

	var resultSlice []*Person
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Person")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Person")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Person")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyPerson = foreign
		if foreign.R == nil {
			foreign.R = &personR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyPerson = foreign
				if foreign.R == nil {
					foreign.R = &personR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyPersonFinancialInfo allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyPersonFinancialInfo(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PersonFinancialInfo`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PersonFinancialInfo")
	}

	var resultSlice []*PersonFinancialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PersonFinancialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for PersonFinancialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PersonFinancialInfo")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyPersonFinancialInfo = foreign
		if foreign.R == nil {
			foreign.R = &personFinancialInfoR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyPersonFinancialInfo = foreign
				if foreign.R == nil {
					foreign.R = &personFinancialInfoR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyRTP allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (partyL) LoadPartyRTP(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Rtp`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RTP")
	}

	var resultSlice []*RTP
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RTP")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Rtp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Rtp")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PartyRTP = foreign
		if foreign.R == nil {
			foreign.R = &rtpR{}
		}
		foreign.R.Party = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyRTP = foreign
				if foreign.R == nil {
					foreign.R = &rtpR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyAccountOwners allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyAccountOwners(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountOwners`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountOwners")
	}

	var resultSlice []*AccountOwner
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountOwners")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountOwners")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountOwners")
	}

	if len(accountOwnerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyAccountOwners = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountOwnerR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyAccountOwners = append(local.R.PartyAccountOwners, foreign)
				if foreign.R == nil {
					foreign.R = &accountOwnerR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Address`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Address")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Address")
	}

	if len(addressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &addressR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyAddresses = append(local.R.PartyAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPayeeBillers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPayeeBillers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Biller`), qm.WhereIn(`payee_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Biller")
	}

	var resultSlice []*Biller
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Biller")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Biller")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Biller")
	}

	if len(billerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PayeeBillers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &billerR{}
			}
			foreign.R.Payee = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PayeeID {
				local.R.PayeeBillers = append(local.R.PayeeBillers, foreign)
				if foreign.R == nil {
					foreign.R = &billerR{}
				}
				foreign.R.Payee = local
				break
			}
		}
	}

	return nil
}

// LoadPayerBillers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPayerBillers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Biller`), qm.WhereIn(`payer_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Biller")
	}

	var resultSlice []*Biller
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Biller")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Biller")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Biller")
	}

	if len(billerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PayerBillers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &billerR{}
			}
			foreign.R.Payer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PayerID {
				local.R.PayerBillers = append(local.R.PayerBillers, foreign)
				if foreign.R == nil {
					foreign.R = &billerR{}
				}
				foreign.R.Payer = local
				break
			}
		}
	}

	return nil
}

// LoadPartyBorrowers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyBorrowers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Borrower`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Borrower")
	}

	var resultSlice []*Borrower
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Borrower")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Borrower")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Borrower")
	}

	if len(borrowerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyBorrowers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &borrowerR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyBorrowers = append(local.R.PartyBorrowers, foreign)
				if foreign.R == nil {
					foreign.R = &borrowerR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyBudgets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyBudgets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Budget`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Budget")
	}

	var resultSlice []*Budget
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Budget")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Budget")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Budget")
	}

	if len(budgetAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyBudgets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &budgetR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyBudgets = append(local.R.PartyBudgets, foreign)
				if foreign.R == nil {
					foreign.R = &budgetR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyCreditOriginations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyCreditOriginations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CreditOrigination`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CreditOrigination")
	}

	var resultSlice []*CreditOrigination
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CreditOrigination")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CreditOrigination")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CreditOrigination")
	}

	if len(creditOriginationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyCreditOriginations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &creditOriginationR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCreditOriginations = append(local.R.PartyCreditOriginations, foreign)
				if foreign.R == nil {
					foreign.R = &creditOriginationR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyCryptographies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyCryptographies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Cryptography`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Cryptography")
	}

	var resultSlice []*Cryptography
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Cryptography")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Cryptography")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Cryptography")
	}

	if len(cryptographyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyCryptographies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cryptographyR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCryptographies = append(local.R.PartyCryptographies, foreign)
				if foreign.R == nil {
					foreign.R = &cryptographyR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyCustomerGoalSummaries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyCustomerGoalSummaries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CustomerGoalSummary`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerGoalSummary")
	}

	var resultSlice []*CustomerGoalSummary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerGoalSummary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CustomerGoalSummary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CustomerGoalSummary")
	}

	if len(customerGoalSummaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyCustomerGoalSummaries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerGoalSummaryR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCustomerGoalSummaries = append(local.R.PartyCustomerGoalSummaries, foreign)
				if foreign.R == nil {
					foreign.R = &customerGoalSummaryR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyCustomerOffers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyCustomerOffers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CustomerOffer`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerOffer")
	}

	var resultSlice []*CustomerOffer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerOffer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CustomerOffer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CustomerOffer")
	}

	if len(customerOfferAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyCustomerOffers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerOfferR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCustomerOffers = append(local.R.PartyCustomerOffers, foreign)
				if foreign.R == nil {
					foreign.R = &customerOfferR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyCustomerRatings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyCustomerRatings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CustomerRating`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerRating")
	}

	var resultSlice []*CustomerRating
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerRating")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CustomerRating")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CustomerRating")
	}

	if len(customerRatingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyCustomerRatings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerRatingR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyCustomerRatings = append(local.R.PartyCustomerRatings, foreign)
				if foreign.R == nil {
					foreign.R = &customerRatingR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyDevices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyDevices(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Devices`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Devices")
	}

	var resultSlice []*Device
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Devices")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Devices")
	}

	if len(deviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyDevices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyDevices = append(local.R.PartyDevices, foreign)
				if foreign.R == nil {
					foreign.R = &deviceR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadDocumentHolderPartyDocuments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadDocumentHolderPartyDocuments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PartyID) {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Document`), qm.WhereIn(`document_holder_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Document")
	}

	var resultSlice []*Document
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Document")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Document")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Document")
	}

	if len(documentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DocumentHolderPartyDocuments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &documentR{}
			}
			foreign.R.DocumentHolderParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PartyID, foreign.DocumentHolderPartyID) {
				local.R.DocumentHolderPartyDocuments = append(local.R.DocumentHolderPartyDocuments, foreign)
				if foreign.R == nil {
					foreign.R = &documentR{}
				}
				foreign.R.DocumentHolderParty = local
				break
			}
		}
	}

	return nil
}

// LoadPartyEmails allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyEmails(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Emails`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Emails")
	}

	var resultSlice []*Email
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Emails")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Emails")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Emails")
	}

	if len(emailAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyEmails = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emailR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyEmails = append(local.R.PartyEmails, foreign)
				if foreign.R == nil {
					foreign.R = &emailR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyFxDeals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyFxDeals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PartyID) {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`FxDeals`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FxDeals")
	}

	var resultSlice []*FxDeal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FxDeals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on FxDeals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for FxDeals")
	}

	if len(fxDealAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyFxDeals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fxDealR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PartyID, foreign.PartyID) {
				local.R.PartyFxDeals = append(local.R.PartyFxDeals, foreign)
				if foreign.R == nil {
					foreign.R = &fxDealR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadLinkedPartyJointAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadLinkedPartyJointAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JointAccount`), qm.WhereIn(`linked_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JointAccount")
	}

	var resultSlice []*JointAccount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JointAccount")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JointAccount")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JointAccount")
	}

	if len(jointAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LinkedPartyJointAccounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &jointAccountR{}
			}
			foreign.R.LinkedParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.LinkedPartyID {
				local.R.LinkedPartyJointAccounts = append(local.R.LinkedPartyJointAccounts, foreign)
				if foreign.R == nil {
					foreign.R = &jointAccountR{}
				}
				foreign.R.LinkedParty = local
				break
			}
		}
	}

	return nil
}

// LoadPrimaryPartyJointAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPrimaryPartyJointAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JointAccount`), qm.WhereIn(`primary_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JointAccount")
	}

	var resultSlice []*JointAccount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JointAccount")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JointAccount")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JointAccount")
	}

	if len(jointAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PrimaryPartyJointAccounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &jointAccountR{}
			}
			foreign.R.PrimaryParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PrimaryPartyID {
				local.R.PrimaryPartyJointAccounts = append(local.R.PrimaryPartyJointAccounts, foreign)
				if foreign.R == nil {
					foreign.R = &jointAccountR{}
				}
				foreign.R.PrimaryParty = local
				break
			}
		}
	}

	return nil
}

// LoadPartyLineOfCredits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyLineOfCredits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`LineOfCredit`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LineOfCredit")
	}

	var resultSlice []*LineOfCredit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LineOfCredit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on LineOfCredit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for LineOfCredit")
	}

	if len(lineOfCreditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyLineOfCredits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &lineOfCreditR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyLineOfCredits = append(local.R.PartyLineOfCredits, foreign)
				if foreign.R == nil {
					foreign.R = &lineOfCreditR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PartyID) {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Notifications`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Notifications")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Notifications")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Notifications")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Notifications")
	}

	if len(notificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyNotifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PartyID, foreign.PartyID) {
				local.R.PartyNotifications = append(local.R.PartyNotifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadFromPartyPaymentBills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadFromPartyPaymentBills(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentBill`), qm.WhereIn(`from_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentBill")
	}

	var resultSlice []*PaymentBill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentBill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentBill")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentBill")
	}

	if len(paymentBillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromPartyPaymentBills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentBillR{}
			}
			foreign.R.FromParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.FromPartyID {
				local.R.FromPartyPaymentBills = append(local.R.FromPartyPaymentBills, foreign)
				if foreign.R == nil {
					foreign.R = &paymentBillR{}
				}
				foreign.R.FromParty = local
				break
			}
		}
	}

	return nil
}

// LoadTraderPartyPaymentFxTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadTraderPartyPaymentFxTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentFxTrade`), qm.WhereIn(`trader_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentFxTrade")
	}

	var resultSlice []*PaymentFxTrade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentFxTrade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentFxTrade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentFxTrade")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TraderPartyPaymentFxTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentFxTradeR{}
			}
			foreign.R.TraderParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.TraderPartyID {
				local.R.TraderPartyPaymentFxTrades = append(local.R.TraderPartyPaymentFxTrades, foreign)
				if foreign.R == nil {
					foreign.R = &paymentFxTradeR{}
				}
				foreign.R.TraderParty = local
				break
			}
		}
	}

	return nil
}

// LoadPartyPhoneNumbers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyPhoneNumbers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PhoneNumbers`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PhoneNumbers")
	}

	var resultSlice []*PhoneNumber
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PhoneNumbers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PhoneNumbers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PhoneNumbers")
	}

	if len(phoneNumberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyPhoneNumbers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &phoneNumberR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyPhoneNumbers = append(local.R.PartyPhoneNumbers, foreign)
				if foreign.R == nil {
					foreign.R = &phoneNumberR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyPortfolioGoalSummaries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyPortfolioGoalSummaries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PortfolioGoalSummary`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PortfolioGoalSummary")
	}

	var resultSlice []*PortfolioGoalSummary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PortfolioGoalSummary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PortfolioGoalSummary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PortfolioGoalSummary")
	}

	if len(portfolioGoalSummaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyPortfolioGoalSummaries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &portfolioGoalSummaryR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyPortfolioGoalSummaries = append(local.R.PartyPortfolioGoalSummaries, foreign)
				if foreign.R == nil {
					foreign.R = &portfolioGoalSummaryR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPayeeRegisteredBillers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPayeeRegisteredBillers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`RegisteredBiller`), qm.WhereIn(`payee_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RegisteredBiller")
	}

	var resultSlice []*RegisteredBiller
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RegisteredBiller")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on RegisteredBiller")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for RegisteredBiller")
	}

	if len(registeredBillerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PayeeRegisteredBillers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &registeredBillerR{}
			}
			foreign.R.Payee = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PayeeID {
				local.R.PayeeRegisteredBillers = append(local.R.PayeeRegisteredBillers, foreign)
				if foreign.R == nil {
					foreign.R = &registeredBillerR{}
				}
				foreign.R.Payee = local
				break
			}
		}
	}

	return nil
}

// LoadPartyRisks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyRisks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PartyID) {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Risk`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Risk")
	}

	var resultSlice []*Risk
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Risk")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Risk")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Risk")
	}

	if len(riskAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyRisks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &riskR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PartyID, foreign.PartyID) {
				local.R.PartyRisks = append(local.R.PartyRisks, foreign)
				if foreign.R == nil {
					foreign.R = &riskR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadFromPartyRtpRequests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadFromPartyRtpRequests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`RtpRequest`), qm.WhereIn(`from_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RtpRequest")
	}

	var resultSlice []*RtpRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RtpRequest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on RtpRequest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for RtpRequest")
	}

	if len(rtpRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromPartyRtpRequests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &rtpRequestR{}
			}
			foreign.R.FromParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.FromPartyID {
				local.R.FromPartyRtpRequests = append(local.R.FromPartyRtpRequests, foreign)
				if foreign.R == nil {
					foreign.R = &rtpRequestR{}
				}
				foreign.R.FromParty = local
				break
			}
		}
	}

	return nil
}

// LoadPartySocialInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartySocialInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`SocialInfo`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SocialInfo")
	}

	var resultSlice []*SocialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SocialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on SocialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for SocialInfo")
	}

	if len(socialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartySocialInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &socialInfoR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartySocialInfos = append(local.R.PartySocialInfos, foreign)
				if foreign.R == nil {
					foreign.R = &socialInfoR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFBankGuarantees allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFBankGuarantees(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFBankGuarantee`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFBankGuarantee")
	}

	var resultSlice []*TFBankGuarantee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFBankGuarantee")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFBankGuarantee")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFBankGuarantee")
	}

	if len(tFBankGuaranteeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFBankGuarantees = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFBankGuaranteeR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFBankGuarantees = append(local.R.PartyTFBankGuarantees, foreign)
				if foreign.R == nil {
					foreign.R = &tFBankGuaranteeR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFCharges allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFCharges(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFCharges`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFCharges")
	}

	var resultSlice []*TFCharge
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFCharges")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFCharges")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFCharges")
	}

	if len(tFChargeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFCharges = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFChargeR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFCharges = append(local.R.PartyTFCharges, foreign)
				if foreign.R == nil {
					foreign.R = &tFChargeR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFChargesTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFChargesTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFChargesTxn`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFChargesTxn")
	}

	var resultSlice []*TFChargesTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFChargesTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFChargesTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFChargesTxn")
	}

	if len(tFChargesTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFChargesTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFChargesTxnR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFChargesTxns = append(local.R.PartyTFChargesTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFChargesTxnR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFExportImportsBills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFExportImportsBills(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFExportImportsBill`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFExportImportsBill")
	}

	var resultSlice []*TFExportImportsBill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFExportImportsBill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFExportImportsBill")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFExportImportsBill")
	}

	if len(tFExportImportsBillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFExportImportsBills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFExportImportsBillR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFExportImportsBills = append(local.R.PartyTFExportImportsBills, foreign)
				if foreign.R == nil {
					foreign.R = &tFExportImportsBillR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFInterests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFInterests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFInterest`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFInterest")
	}

	var resultSlice []*TFInterest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFInterest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFInterest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFInterest")
	}

	if len(tFInterestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFInterests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFInterestR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFInterests = append(local.R.PartyTFInterests, foreign)
				if foreign.R == nil {
					foreign.R = &tFInterestR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFInterestTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFInterestTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFInterestTxn`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFInterestTxn")
	}

	var resultSlice []*TFInterestTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFInterestTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFInterestTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFInterestTxn")
	}

	if len(tFInterestTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFInterestTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFInterestTxnR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFInterestTxns = append(local.R.PartyTFInterestTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFInterestTxnR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFLcLetters allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFLcLetters(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLcLetter`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLcLetter")
	}

	var resultSlice []*TFLcLetter
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLcLetter")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLcLetter")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLcLetter")
	}

	if len(tFLcLetterAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFLcLetters = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLcLetterR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFLcLetters = append(local.R.PartyTFLcLetters, foreign)
				if foreign.R == nil {
					foreign.R = &tFLcLetterR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFLcLetterTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFLcLetterTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLcLetterTxn`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLcLetterTxn")
	}

	var resultSlice []*TFLcLetterTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLcLetterTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLcLetterTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLcLetterTxn")
	}

	if len(tFLcLetterTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFLcLetterTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLcLetterTxnR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFLcLetterTxns = append(local.R.PartyTFLcLetterTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFLcLetterTxnR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFLetterOfCredits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFLetterOfCredits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCredit`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCredit")
	}

	var resultSlice []*TFLetterOfCredit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCredit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLetterOfCredit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCredit")
	}

	if len(tFLetterOfCreditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFLetterOfCredits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLetterOfCreditR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFLetterOfCredits = append(local.R.PartyTFLetterOfCredits, foreign)
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFLetterOfCreditTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFLetterOfCreditTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCreditTxn`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCreditTxn")
	}

	var resultSlice []*TFLetterOfCreditTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCreditTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLetterOfCreditTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCreditTxn")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFLetterOfCreditTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLetterOfCreditTxnR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFLetterOfCreditTxns = append(local.R.PartyTFLetterOfCreditTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditTxnR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFParties allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFParties(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFParty`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFParty")
	}

	var resultSlice []*TFParty
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFParty")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFParty")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFParty")
	}

	if len(tFPartyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFParties = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFParties = append(local.R.PartyTFParties, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFPartyTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFPartyTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFPartyTxn`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFPartyTxn")
	}

	var resultSlice []*TFPartyTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFPartyTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFPartyTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFPartyTxn")
	}

	if len(tFPartyTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFPartyTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyTxnR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFPartyTxns = append(local.R.PartyTFPartyTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyTxnR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFRisks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFRisks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFRisk`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFRisk")
	}

	var resultSlice []*TFRisk
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFRisk")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFRisk")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFRisk")
	}

	if len(tFRiskAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFRisks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFRiskR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFRisks = append(local.R.PartyTFRisks, foreign)
				if foreign.R == nil {
					foreign.R = &tFRiskR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadPartyTFSettlements allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyTFSettlements(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFSettlement`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFSettlement")
	}

	var resultSlice []*TFSettlement
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFSettlement")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFSettlement")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFSettlement")
	}

	if len(tFSettlementAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyTFSettlements = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFSettlementR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.PartyID {
				local.R.PartyTFSettlements = append(local.R.PartyTFSettlements, foreign)
				if foreign.R == nil {
					foreign.R = &tFSettlementR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// LoadFromPartyTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadFromPartyTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Trade`), qm.WhereIn(`from_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Trade")
	}

	if len(tradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromPartyTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.FromParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.FromPartyID {
				local.R.FromPartyTrades = append(local.R.FromPartyTrades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.FromParty = local
				break
			}
		}
	}

	return nil
}

// LoadToPartyTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadToPartyTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Trade`), qm.WhereIn(`to_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Trade")
	}

	if len(tradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToPartyTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.ToParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.ToPartyID {
				local.R.ToPartyTrades = append(local.R.ToPartyTrades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.ToParty = local
				break
			}
		}
	}

	return nil
}

// LoadFromPartyTransfers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadFromPartyTransfers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Transfer`), qm.WhereIn(`from_party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Transfer")
	}

	var resultSlice []*Transfer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Transfer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Transfer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Transfer")
	}

	if len(transferAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromPartyTransfers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferR{}
			}
			foreign.R.FromParty = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PartyID == foreign.FromPartyID {
				local.R.FromPartyTransfers = append(local.R.FromPartyTransfers, foreign)
				if foreign.R == nil {
					foreign.R = &transferR{}
				}
				foreign.R.FromParty = local
				break
			}
		}
	}

	return nil
}

// LoadPartyUserLogins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (partyL) LoadPartyUserLogins(ctx context.Context, e boil.ContextExecutor, singular bool, maybeParty interface{}, mods queries.Applicator) error {
	var slice []*Party
	var object *Party

	if singular {
		object = maybeParty.(*Party)
	} else {
		slice = *maybeParty.(*[]*Party)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &partyR{}
		}
		args = append(args, object.PartyID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &partyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PartyID) {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`UserLogin`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UserLogin")
	}

	var resultSlice []*UserLogin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UserLogin")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on UserLogin")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for UserLogin")
	}

	if len(userLoginAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PartyUserLogins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userLoginR{}
			}
			foreign.R.Party = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PartyID, foreign.PartyID) {
				local.R.PartyUserLogins = append(local.R.PartyUserLogins, foreign)
				if foreign.R == nil {
					foreign.R = &userLoginR{}
				}
				foreign.R.Party = local
				break
			}
		}
	}

	return nil
}

// SetBank of the party to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankParties.
func (o *Party) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Parties` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, partyPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.PartyID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &partyR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankParties: PartySlice{o},
		}
	} else {
		related.R.BankParties = append(related.R.BankParties, o)
	}

	return nil
}

// SetPartyCollateral of the party to the related item.
// Sets o.R.PartyCollateral to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyCollateral(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Collateral) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `Collateral` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, collateralPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.PartyID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyCollateral: related,
		}
	} else {
		o.R.PartyCollateral = related
	}

	if related.R == nil {
		related.R = &collateralR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// SetPartyOrganization of the party to the related item.
// Sets o.R.PartyOrganization to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyOrganization(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Organization) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `Organization` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, organizationPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.PartyID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyOrganization: related,
		}
	} else {
		o.R.PartyOrganization = related
	}

	if related.R == nil {
		related.R = &organizationR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// SetPartyOrganizationFinancialInfo of the party to the related item.
// Sets o.R.PartyOrganizationFinancialInfo to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyOrganizationFinancialInfo(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OrganizationFinancialInfo) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `OrganizationFinancialInfo` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, organizationFinancialInfoPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.OrganizationFinancialInfoID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyOrganizationFinancialInfo: related,
		}
	} else {
		o.R.PartyOrganizationFinancialInfo = related
	}

	if related.R == nil {
		related.R = &organizationFinancialInfoR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// SetPartyPerson of the party to the related item.
// Sets o.R.PartyPerson to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyPerson(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Person) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `Person` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, personPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.PartyID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyPerson: related,
		}
	} else {
		o.R.PartyPerson = related
	}

	if related.R == nil {
		related.R = &personR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// SetPartyPersonFinancialInfo of the party to the related item.
// Sets o.R.PartyPersonFinancialInfo to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyPersonFinancialInfo(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PersonFinancialInfo) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `PersonFinancialInfo` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.PersonFinancialInfoID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyPersonFinancialInfo: related,
		}
	} else {
		o.R.PartyPersonFinancialInfo = related
	}

	if related.R == nil {
		related.R = &personFinancialInfoR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// SetPartyRTP of the party to the related item.
// Sets o.R.PartyRTP to related.
// Adds o to related.R.Party.
func (o *Party) SetPartyRTP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RTP) error {
	var err error

	if insert {
		related.PartyID = o.PartyID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `Rtp` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
			strmangle.WhereClause("`", "`", 0, rtpPrimaryKeyColumns),
		)
		values := []interface{}{o.PartyID, related.RTPID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PartyID = o.PartyID

	}

	if o.R == nil {
		o.R = &partyR{
			PartyRTP: related,
		}
	} else {
		o.R.PartyRTP = related
	}

	if related.R == nil {
		related.R = &rtpR{
			Party: o,
		}
	} else {
		related.R.Party = o
	}
	return nil
}

// AddPartyAccountOwners adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyAccountOwners.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyAccountOwners(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountOwner) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountOwners` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, accountOwnerPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.AccountOwnerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyAccountOwners: related,
		}
	} else {
		o.R.PartyAccountOwners = append(o.R.PartyAccountOwners, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountOwnerR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyAddresses adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyAddresses.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Address) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Address` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, addressPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.AddressID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyAddresses: related,
		}
	} else {
		o.R.PartyAddresses = append(o.R.PartyAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &addressR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPayeeBillers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PayeeBillers.
// Sets related.R.Payee appropriately.
func (o *Party) AddPayeeBillers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Biller) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PayeeID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Biller` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payee_id"}),
				strmangle.WhereClause("`", "`", 0, billerPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.BillerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PayeeID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PayeeBillers: related,
		}
	} else {
		o.R.PayeeBillers = append(o.R.PayeeBillers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &billerR{
				Payee: o,
			}
		} else {
			rel.R.Payee = o
		}
	}
	return nil
}

// AddPayerBillers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PayerBillers.
// Sets related.R.Payer appropriately.
func (o *Party) AddPayerBillers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Biller) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PayerID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Biller` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payer_id"}),
				strmangle.WhereClause("`", "`", 0, billerPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.BillerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PayerID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PayerBillers: related,
		}
	} else {
		o.R.PayerBillers = append(o.R.PayerBillers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &billerR{
				Payer: o,
			}
		} else {
			rel.R.Payer = o
		}
	}
	return nil
}

// AddPartyBorrowers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyBorrowers.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyBorrowers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Borrower) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Borrower` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, borrowerPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.BorrowerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyBorrowers: related,
		}
	} else {
		o.R.PartyBorrowers = append(o.R.PartyBorrowers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &borrowerR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyBudgets adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyBudgets.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyBudgets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Budget) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Budget` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, budgetPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.BudgetID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyBudgets: related,
		}
	} else {
		o.R.PartyBudgets = append(o.R.PartyBudgets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &budgetR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyCreditOriginations adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyCreditOriginations.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyCreditOriginations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CreditOrigination) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CreditOrigination` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, creditOriginationPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.CreditOriginationID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyCreditOriginations: related,
		}
	} else {
		o.R.PartyCreditOriginations = append(o.R.PartyCreditOriginations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &creditOriginationR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyCryptographies adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyCryptographies.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyCryptographies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Cryptography) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Cryptography` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, cryptographyPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.CryptographyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyCryptographies: related,
		}
	} else {
		o.R.PartyCryptographies = append(o.R.PartyCryptographies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cryptographyR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyCustomerGoalSummaries adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyCustomerGoalSummaries.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyCustomerGoalSummaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerGoalSummary) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CustomerGoalSummary` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, customerGoalSummaryPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.CustomerGoalSummaryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyCustomerGoalSummaries: related,
		}
	} else {
		o.R.PartyCustomerGoalSummaries = append(o.R.PartyCustomerGoalSummaries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerGoalSummaryR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyCustomerOffers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyCustomerOffers.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyCustomerOffers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerOffer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CustomerOffer` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, customerOfferPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.CustomerOfferID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyCustomerOffers: related,
		}
	} else {
		o.R.PartyCustomerOffers = append(o.R.PartyCustomerOffers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerOfferR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyCustomerRatings adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyCustomerRatings.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyCustomerRatings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerRating) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CustomerRating` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, customerRatingPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.CustomerRatingID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyCustomerRatings: related,
		}
	} else {
		o.R.PartyCustomerRatings = append(o.R.PartyCustomerRatings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerRatingR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyDevices adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyDevices.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyDevices(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Device) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Devices` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, devicePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.DevicesID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyDevices: related,
		}
	} else {
		o.R.PartyDevices = append(o.R.PartyDevices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddDocumentHolderPartyDocuments adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.DocumentHolderPartyDocuments.
// Sets related.R.DocumentHolderParty appropriately.
func (o *Party) AddDocumentHolderPartyDocuments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Document) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.DocumentHolderPartyID, o.PartyID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Document` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"document_holder_party_id"}),
				strmangle.WhereClause("`", "`", 0, documentPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.DocumentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.DocumentHolderPartyID, o.PartyID)
		}
	}

	if o.R == nil {
		o.R = &partyR{
			DocumentHolderPartyDocuments: related,
		}
	} else {
		o.R.DocumentHolderPartyDocuments = append(o.R.DocumentHolderPartyDocuments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &documentR{
				DocumentHolderParty: o,
			}
		} else {
			rel.R.DocumentHolderParty = o
		}
	}
	return nil
}

// SetDocumentHolderPartyDocuments removes all previously related items of the
// Party replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.DocumentHolderParty's DocumentHolderPartyDocuments accordingly.
// Replaces o.R.DocumentHolderPartyDocuments with related.
// Sets related.R.DocumentHolderParty's DocumentHolderPartyDocuments accordingly.
func (o *Party) SetDocumentHolderPartyDocuments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Document) error {
	query := "update `Document` set `document_holder_party_id` = null where `document_holder_party_id` = ?"
	values := []interface{}{o.PartyID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.DocumentHolderPartyDocuments {
			queries.SetScanner(&rel.DocumentHolderPartyID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.DocumentHolderParty = nil
		}

		o.R.DocumentHolderPartyDocuments = nil
	}
	return o.AddDocumentHolderPartyDocuments(ctx, exec, insert, related...)
}

// RemoveDocumentHolderPartyDocuments relationships from objects passed in.
// Removes related items from R.DocumentHolderPartyDocuments (uses pointer comparison, removal does not keep order)
// Sets related.R.DocumentHolderParty.
func (o *Party) RemoveDocumentHolderPartyDocuments(ctx context.Context, exec boil.ContextExecutor, related ...*Document) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.DocumentHolderPartyID, nil)
		if rel.R != nil {
			rel.R.DocumentHolderParty = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("document_holder_party_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.DocumentHolderPartyDocuments {
			if rel != ri {
				continue
			}

			ln := len(o.R.DocumentHolderPartyDocuments)
			if ln > 1 && i < ln-1 {
				o.R.DocumentHolderPartyDocuments[i] = o.R.DocumentHolderPartyDocuments[ln-1]
			}
			o.R.DocumentHolderPartyDocuments = o.R.DocumentHolderPartyDocuments[:ln-1]
			break
		}
	}

	return nil
}

// AddPartyEmails adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyEmails.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyEmails(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Email) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Emails` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, emailPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.PartyID, rel.EmailType}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyEmails: related,
		}
	} else {
		o.R.PartyEmails = append(o.R.PartyEmails, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emailR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyFxDeals adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyFxDeals.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyFxDeals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FxDeal) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PartyID, o.PartyID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `FxDeals` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, fxDealPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.FXDealID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PartyID, o.PartyID)
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyFxDeals: related,
		}
	} else {
		o.R.PartyFxDeals = append(o.R.PartyFxDeals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fxDealR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// SetPartyFxDeals removes all previously related items of the
// Party replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Party's PartyFxDeals accordingly.
// Replaces o.R.PartyFxDeals with related.
// Sets related.R.Party's PartyFxDeals accordingly.
func (o *Party) SetPartyFxDeals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FxDeal) error {
	query := "update `FxDeals` set `party_id` = null where `party_id` = ?"
	values := []interface{}{o.PartyID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PartyFxDeals {
			queries.SetScanner(&rel.PartyID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Party = nil
		}

		o.R.PartyFxDeals = nil
	}
	return o.AddPartyFxDeals(ctx, exec, insert, related...)
}

// RemovePartyFxDeals relationships from objects passed in.
// Removes related items from R.PartyFxDeals (uses pointer comparison, removal does not keep order)
// Sets related.R.Party.
func (o *Party) RemovePartyFxDeals(ctx context.Context, exec boil.ContextExecutor, related ...*FxDeal) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PartyID, nil)
		if rel.R != nil {
			rel.R.Party = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("party_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PartyFxDeals {
			if rel != ri {
				continue
			}

			ln := len(o.R.PartyFxDeals)
			if ln > 1 && i < ln-1 {
				o.R.PartyFxDeals[i] = o.R.PartyFxDeals[ln-1]
			}
			o.R.PartyFxDeals = o.R.PartyFxDeals[:ln-1]
			break
		}
	}

	return nil
}

// AddLinkedPartyJointAccounts adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.LinkedPartyJointAccounts.
// Sets related.R.LinkedParty appropriately.
func (o *Party) AddLinkedPartyJointAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JointAccount) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LinkedPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JointAccount` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"linked_party_id"}),
				strmangle.WhereClause("`", "`", 0, jointAccountPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.AccountID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LinkedPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			LinkedPartyJointAccounts: related,
		}
	} else {
		o.R.LinkedPartyJointAccounts = append(o.R.LinkedPartyJointAccounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &jointAccountR{
				LinkedParty: o,
			}
		} else {
			rel.R.LinkedParty = o
		}
	}
	return nil
}

// AddPrimaryPartyJointAccounts adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PrimaryPartyJointAccounts.
// Sets related.R.PrimaryParty appropriately.
func (o *Party) AddPrimaryPartyJointAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JointAccount) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PrimaryPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JointAccount` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"primary_party_id"}),
				strmangle.WhereClause("`", "`", 0, jointAccountPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.AccountID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PrimaryPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PrimaryPartyJointAccounts: related,
		}
	} else {
		o.R.PrimaryPartyJointAccounts = append(o.R.PrimaryPartyJointAccounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &jointAccountR{
				PrimaryParty: o,
			}
		} else {
			rel.R.PrimaryParty = o
		}
	}
	return nil
}

// AddPartyLineOfCredits adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyLineOfCredits.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyLineOfCredits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LineOfCredit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `LineOfCredit` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, lineOfCreditPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.LineofCreditID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyLineOfCredits: related,
		}
	} else {
		o.R.PartyLineOfCredits = append(o.R.PartyLineOfCredits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &lineOfCreditR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyNotifications adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyNotifications.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PartyID, o.PartyID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Notifications` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.MSGID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PartyID, o.PartyID)
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyNotifications: related,
		}
	} else {
		o.R.PartyNotifications = append(o.R.PartyNotifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// SetPartyNotifications removes all previously related items of the
// Party replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Party's PartyNotifications accordingly.
// Replaces o.R.PartyNotifications with related.
// Sets related.R.Party's PartyNotifications accordingly.
func (o *Party) SetPartyNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	query := "update `Notifications` set `party_id` = null where `party_id` = ?"
	values := []interface{}{o.PartyID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PartyNotifications {
			queries.SetScanner(&rel.PartyID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Party = nil
		}

		o.R.PartyNotifications = nil
	}
	return o.AddPartyNotifications(ctx, exec, insert, related...)
}

// RemovePartyNotifications relationships from objects passed in.
// Removes related items from R.PartyNotifications (uses pointer comparison, removal does not keep order)
// Sets related.R.Party.
func (o *Party) RemovePartyNotifications(ctx context.Context, exec boil.ContextExecutor, related ...*Notification) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PartyID, nil)
		if rel.R != nil {
			rel.R.Party = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("party_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PartyNotifications {
			if rel != ri {
				continue
			}

			ln := len(o.R.PartyNotifications)
			if ln > 1 && i < ln-1 {
				o.R.PartyNotifications[i] = o.R.PartyNotifications[ln-1]
			}
			o.R.PartyNotifications = o.R.PartyNotifications[:ln-1]
			break
		}
	}

	return nil
}

// AddFromPartyPaymentBills adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.FromPartyPaymentBills.
// Sets related.R.FromParty appropriately.
func (o *Party) AddFromPartyPaymentBills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentBill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentBill` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_party_id"}),
				strmangle.WhereClause("`", "`", 0, paymentBillPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.PaymentBillID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			FromPartyPaymentBills: related,
		}
	} else {
		o.R.FromPartyPaymentBills = append(o.R.FromPartyPaymentBills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentBillR{
				FromParty: o,
			}
		} else {
			rel.R.FromParty = o
		}
	}
	return nil
}

// AddTraderPartyPaymentFxTrades adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.TraderPartyPaymentFxTrades.
// Sets related.R.TraderParty appropriately.
func (o *Party) AddTraderPartyPaymentFxTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentFxTrade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.TraderPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentFxTrade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"trader_party_id"}),
				strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.PaymentFXTradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.TraderPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			TraderPartyPaymentFxTrades: related,
		}
	} else {
		o.R.TraderPartyPaymentFxTrades = append(o.R.TraderPartyPaymentFxTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentFxTradeR{
				TraderParty: o,
			}
		} else {
			rel.R.TraderParty = o
		}
	}
	return nil
}

// AddPartyPhoneNumbers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyPhoneNumbers.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyPhoneNumbers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PhoneNumber) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PhoneNumbers` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, phoneNumberPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.PhoneNumberID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyPhoneNumbers: related,
		}
	} else {
		o.R.PartyPhoneNumbers = append(o.R.PartyPhoneNumbers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &phoneNumberR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyPortfolioGoalSummaries adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyPortfolioGoalSummaries.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyPortfolioGoalSummaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PortfolioGoalSummary) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PortfolioGoalSummary` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, portfolioGoalSummaryPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.PartyID, rel.GoalID, rel.ReportDate}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyPortfolioGoalSummaries: related,
		}
	} else {
		o.R.PartyPortfolioGoalSummaries = append(o.R.PartyPortfolioGoalSummaries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &portfolioGoalSummaryR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPayeeRegisteredBillers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PayeeRegisteredBillers.
// Sets related.R.Payee appropriately.
func (o *Party) AddPayeeRegisteredBillers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RegisteredBiller) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PayeeID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `RegisteredBiller` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payee_id"}),
				strmangle.WhereClause("`", "`", 0, registeredBillerPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.BillerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PayeeID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PayeeRegisteredBillers: related,
		}
	} else {
		o.R.PayeeRegisteredBillers = append(o.R.PayeeRegisteredBillers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &registeredBillerR{
				Payee: o,
			}
		} else {
			rel.R.Payee = o
		}
	}
	return nil
}

// AddPartyRisks adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyRisks.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyRisks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Risk) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PartyID, o.PartyID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Risk` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, riskPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.RiskID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PartyID, o.PartyID)
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyRisks: related,
		}
	} else {
		o.R.PartyRisks = append(o.R.PartyRisks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &riskR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// SetPartyRisks removes all previously related items of the
// Party replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Party's PartyRisks accordingly.
// Replaces o.R.PartyRisks with related.
// Sets related.R.Party's PartyRisks accordingly.
func (o *Party) SetPartyRisks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Risk) error {
	query := "update `Risk` set `party_id` = null where `party_id` = ?"
	values := []interface{}{o.PartyID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PartyRisks {
			queries.SetScanner(&rel.PartyID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Party = nil
		}

		o.R.PartyRisks = nil
	}
	return o.AddPartyRisks(ctx, exec, insert, related...)
}

// RemovePartyRisks relationships from objects passed in.
// Removes related items from R.PartyRisks (uses pointer comparison, removal does not keep order)
// Sets related.R.Party.
func (o *Party) RemovePartyRisks(ctx context.Context, exec boil.ContextExecutor, related ...*Risk) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PartyID, nil)
		if rel.R != nil {
			rel.R.Party = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("party_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PartyRisks {
			if rel != ri {
				continue
			}

			ln := len(o.R.PartyRisks)
			if ln > 1 && i < ln-1 {
				o.R.PartyRisks[i] = o.R.PartyRisks[ln-1]
			}
			o.R.PartyRisks = o.R.PartyRisks[:ln-1]
			break
		}
	}

	return nil
}

// AddFromPartyRtpRequests adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.FromPartyRtpRequests.
// Sets related.R.FromParty appropriately.
func (o *Party) AddFromPartyRtpRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RtpRequest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `RtpRequest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_party_id"}),
				strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.RTPRequestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			FromPartyRtpRequests: related,
		}
	} else {
		o.R.FromPartyRtpRequests = append(o.R.FromPartyRtpRequests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &rtpRequestR{
				FromParty: o,
			}
		} else {
			rel.R.FromParty = o
		}
	}
	return nil
}

// AddPartySocialInfos adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartySocialInfos.
// Sets related.R.Party appropriately.
func (o *Party) AddPartySocialInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SocialInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `SocialInfo` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, socialInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.SocialInfoID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartySocialInfos: related,
		}
	} else {
		o.R.PartySocialInfos = append(o.R.PartySocialInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &socialInfoR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFBankGuarantees adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFBankGuarantees.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFBankGuarantees(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFBankGuarantee) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFBankGuarantee` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFBankGuaranteePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFBankGuaranteeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFBankGuarantees: related,
		}
	} else {
		o.R.PartyTFBankGuarantees = append(o.R.PartyTFBankGuarantees, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFBankGuaranteeR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFCharges adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFCharges.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFCharges(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFCharge) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFCharges` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFChargePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFChargesID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFCharges: related,
		}
	} else {
		o.R.PartyTFCharges = append(o.R.PartyTFCharges, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFChargeR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFChargesTxns adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFChargesTxns.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFChargesTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFChargesTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFChargesTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFChargesTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFChargesID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFChargesTxns: related,
		}
	} else {
		o.R.PartyTFChargesTxns = append(o.R.PartyTFChargesTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFChargesTxnR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFExportImportsBills adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFExportImportsBills.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFExportImportsBills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFExportImportsBill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFExportImportsBill` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFExportImportsBillPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFBillID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFExportImportsBills: related,
		}
	} else {
		o.R.PartyTFExportImportsBills = append(o.R.PartyTFExportImportsBills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFExportImportsBillR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFInterests adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFInterests.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFInterests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFInterest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFInterest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFInterestPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TradeInterestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFInterests: related,
		}
	} else {
		o.R.PartyTFInterests = append(o.R.PartyTFInterests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFInterestR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFInterestTxns adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFInterestTxns.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFInterestTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFInterestTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFInterestTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFInterestTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TradeInterestID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFInterestTxns: related,
		}
	} else {
		o.R.PartyTFInterestTxns = append(o.R.PartyTFInterestTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFInterestTxnR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFLcLetters adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFLcLetters.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFLcLetters(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLcLetter) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLcLetter` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFLcLetterPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFLCLetterID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFLcLetters: related,
		}
	} else {
		o.R.PartyTFLcLetters = append(o.R.PartyTFLcLetters, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLcLetterR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFLcLetterTxns adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFLcLetterTxns.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFLcLetterTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLcLetterTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLcLetterTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFLcLetterTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFLCLetterID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFLcLetterTxns: related,
		}
	} else {
		o.R.PartyTFLcLetterTxns = append(o.R.PartyTFLcLetterTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLcLetterTxnR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFLetterOfCredits adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFLetterOfCredits.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFLetterOfCredits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLetterOfCredit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLetterOfCredit` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFLCID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFLetterOfCredits: related,
		}
	} else {
		o.R.PartyTFLetterOfCredits = append(o.R.PartyTFLetterOfCredits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLetterOfCreditR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFLetterOfCreditTxns adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFLetterOfCreditTxns.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFLetterOfCreditTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLetterOfCreditTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFLCTXNID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFLetterOfCreditTxns: related,
		}
	} else {
		o.R.PartyTFLetterOfCreditTxns = append(o.R.PartyTFLetterOfCreditTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLetterOfCreditTxnR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFParties adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFParties.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFParties(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFParty) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFParty` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFPartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFParties: related,
		}
	} else {
		o.R.PartyTFParties = append(o.R.PartyTFParties, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFPartyTxns adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFPartyTxns.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFPartyTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFPartyTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFPartyTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFPartyID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFPartyTxns: related,
		}
	} else {
		o.R.PartyTFPartyTxns = append(o.R.PartyTFPartyTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyTxnR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFRisks adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFRisks.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFRisks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFRisk) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFRisk` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFRiskPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.RiskID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFRisks: related,
		}
	} else {
		o.R.PartyTFRisks = append(o.R.PartyTFRisks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFRiskR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddPartyTFSettlements adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyTFSettlements.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyTFSettlements(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFSettlement) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFSettlement` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, tFSettlementPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TFSettlementID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyTFSettlements: related,
		}
	} else {
		o.R.PartyTFSettlements = append(o.R.PartyTFSettlements, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFSettlementR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// AddFromPartyTrades adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.FromPartyTrades.
// Sets related.R.FromParty appropriately.
func (o *Party) AddFromPartyTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Trade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_party_id"}),
				strmangle.WhereClause("`", "`", 0, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			FromPartyTrades: related,
		}
	} else {
		o.R.FromPartyTrades = append(o.R.FromPartyTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				FromParty: o,
			}
		} else {
			rel.R.FromParty = o
		}
	}
	return nil
}

// AddToPartyTrades adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.ToPartyTrades.
// Sets related.R.ToParty appropriately.
func (o *Party) AddToPartyTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Trade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_party_id"}),
				strmangle.WhereClause("`", "`", 0, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			ToPartyTrades: related,
		}
	} else {
		o.R.ToPartyTrades = append(o.R.ToPartyTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				ToParty: o,
			}
		} else {
			rel.R.ToParty = o
		}
	}
	return nil
}

// AddFromPartyTransfers adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.FromPartyTransfers.
// Sets related.R.FromParty appropriately.
func (o *Party) AddFromPartyTransfers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transfer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromPartyID = o.PartyID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Transfer` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_party_id"}),
				strmangle.WhereClause("`", "`", 0, transferPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.TransferID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromPartyID = o.PartyID
		}
	}

	if o.R == nil {
		o.R = &partyR{
			FromPartyTransfers: related,
		}
	} else {
		o.R.FromPartyTransfers = append(o.R.FromPartyTransfers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferR{
				FromParty: o,
			}
		} else {
			rel.R.FromParty = o
		}
	}
	return nil
}

// AddPartyUserLogins adds the given related objects to the existing relationships
// of the Party, optionally inserting them as new records.
// Appends related to o.R.PartyUserLogins.
// Sets related.R.Party appropriately.
func (o *Party) AddPartyUserLogins(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserLogin) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PartyID, o.PartyID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `UserLogin` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
				strmangle.WhereClause("`", "`", 0, userLoginPrimaryKeyColumns),
			)
			values := []interface{}{o.PartyID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PartyID, o.PartyID)
		}
	}

	if o.R == nil {
		o.R = &partyR{
			PartyUserLogins: related,
		}
	} else {
		o.R.PartyUserLogins = append(o.R.PartyUserLogins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userLoginR{
				Party: o,
			}
		} else {
			rel.R.Party = o
		}
	}
	return nil
}

// SetPartyUserLogins removes all previously related items of the
// Party replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Party's PartyUserLogins accordingly.
// Replaces o.R.PartyUserLogins with related.
// Sets related.R.Party's PartyUserLogins accordingly.
func (o *Party) SetPartyUserLogins(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserLogin) error {
	query := "update `UserLogin` set `party_id` = null where `party_id` = ?"
	values := []interface{}{o.PartyID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PartyUserLogins {
			queries.SetScanner(&rel.PartyID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Party = nil
		}

		o.R.PartyUserLogins = nil
	}
	return o.AddPartyUserLogins(ctx, exec, insert, related...)
}

// RemovePartyUserLogins relationships from objects passed in.
// Removes related items from R.PartyUserLogins (uses pointer comparison, removal does not keep order)
// Sets related.R.Party.
func (o *Party) RemovePartyUserLogins(ctx context.Context, exec boil.ContextExecutor, related ...*UserLogin) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PartyID, nil)
		if rel.R != nil {
			rel.R.Party = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("party_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PartyUserLogins {
			if rel != ri {
				continue
			}

			ln := len(o.R.PartyUserLogins)
			if ln > 1 && i < ln-1 {
				o.R.PartyUserLogins[i] = o.R.PartyUserLogins[ln-1]
			}
			o.R.PartyUserLogins = o.R.PartyUserLogins[:ln-1]
			break
		}
	}

	return nil
}

// Parties retrieves all the records using an executor.
func Parties(mods ...qm.QueryMod) partyQuery {
	mods = append(mods, qm.From("`Parties`"))
	return partyQuery{NewQuery(mods...)}
}

// FindParty retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindParty(ctx context.Context, exec boil.ContextExecutor, partyID int, selectCols ...string) (*Party, error) {
	partyObj := &Party{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Parties` where `party_id`=?", sel,
	)

	q := queries.Raw(query, partyID)

	err := q.Bind(ctx, exec, partyObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Parties")
	}

	return partyObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Party) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Parties provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(partyColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	partyInsertCacheMut.RLock()
	cache, cached := partyInsertCache[key]
	partyInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			partyColumns,
			partyColumnsWithDefault,
			partyColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(partyType, partyMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(partyType, partyMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Parties` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Parties` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Parties` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, partyPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Parties")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PartyID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Parties")
	}

CacheNoHooks:
	if !cached {
		partyInsertCacheMut.Lock()
		partyInsertCache[key] = cache
		partyInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Party.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Party) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	partyUpdateCacheMut.RLock()
	cache, cached := partyUpdateCache[key]
	partyUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			partyColumns,
			partyPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Parties, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Parties` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, partyPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(partyType, partyMapping, append(wl, partyPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Parties row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Parties")
	}

	if !cached {
		partyUpdateCacheMut.Lock()
		partyUpdateCache[key] = cache
		partyUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q partyQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Parties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Parties")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PartySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), partyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Parties` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, partyPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in party slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all party")
	}
	return rowsAff, nil
}

var mySQLPartyUniqueColumns = []string{
	"party_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Party) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Parties provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(partyColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPartyUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	partyUpsertCacheMut.RLock()
	cache, cached := partyUpsertCache[key]
	partyUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			partyColumns,
			partyColumnsWithDefault,
			partyColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			partyColumns,
			partyPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Parties, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Parties", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Parties` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(partyType, partyMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(partyType, partyMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Parties")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(partyType, partyMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Parties")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Parties")
	}

CacheNoHooks:
	if !cached {
		partyUpsertCacheMut.Lock()
		partyUpsertCache[key] = cache
		partyUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Party record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Party) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Party provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), partyPrimaryKeyMapping)
	sql := "DELETE FROM `Parties` WHERE `party_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Parties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Parties")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q partyQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no partyQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Parties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Parties")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PartySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Party slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(partyBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), partyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Parties` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, partyPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from party slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Parties")
	}

	if len(partyAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Party) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindParty(ctx, exec, o.PartyID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PartySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PartySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), partyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Parties`.* FROM `Parties` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, partyPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PartySlice")
	}

	*o = slice

	return nil
}

// PartyExists checks if the Party row exists.
func PartyExists(ctx context.Context, exec boil.ContextExecutor, partyID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Parties` where `party_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, partyID)
	}

	row := exec.QueryRowContext(ctx, sql, partyID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Parties exists")
	}

	return exists, nil
}
