// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// TFLetterOfCredit is an object representing the database table.
type TFLetterOfCredit struct {
	TFLCID               int           `boil:"tf_lc_id" json:"tf_lc_id" toml:"tf_lc_id" yaml:"tf_lc_id"`
	ReferenceID          string        `boil:"reference_id" json:"reference_id" toml:"reference_id" yaml:"reference_id"`
	BranchID             int           `boil:"branch_id" json:"branch_id" toml:"branch_id" yaml:"branch_id"`
	ProductCode          string        `boil:"product_code" json:"product_code" toml:"product_code" yaml:"product_code"`
	PartyID              int           `boil:"party_id" json:"party_id" toml:"party_id" yaml:"party_id"`
	AccountNumber        string        `boil:"account_number" json:"account_number" toml:"account_number" yaml:"account_number"`
	OurReferenceID       string        `boil:"our_reference_id" json:"our_reference_id" toml:"our_reference_id" yaml:"our_reference_id"`
	RevocableFlag        string        `boil:"revocable_flag" json:"revocable_flag" toml:"revocable_flag" yaml:"revocable_flag"`
	STNDByLCFlag         string        `boil:"stnd_by_lc_flag" json:"stnd_by_lc_flag" toml:"stnd_by_lc_flag" yaml:"stnd_by_lc_flag"`
	Status               string        `boil:"status" json:"status" toml:"status" yaml:"status"`
	LetterofCreditNumber string        `boil:"letterof_credit_number" json:"letterof_credit_number" toml:"letterof_credit_number" yaml:"letterof_credit_number"`
	ExportOrImport       string        `boil:"export_or_import" json:"export_or_import" toml:"export_or_import" yaml:"export_or_import"`
	LCType               string        `boil:"lc_type" json:"lc_type" toml:"lc_type" yaml:"lc_type"`
	Ccy                  string        `boil:"ccy" json:"ccy" toml:"ccy" yaml:"ccy"`
	LinkedAccountID      int           `boil:"linked_account_id" json:"linked_account_id" toml:"linked_account_id" yaml:"linked_account_id"`
	BankID               int           `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	Amount               types.Decimal `boil:"amount" json:"amount" toml:"amount" yaml:"amount"`
	ApplicationDate      time.Time     `boil:"application_date" json:"application_date" toml:"application_date" yaml:"application_date"`
	IssueDate            time.Time     `boil:"issue_date" json:"issue_date" toml:"issue_date" yaml:"issue_date"`
	ExpiryDate           time.Time     `boil:"expiry_date" json:"expiry_date" toml:"expiry_date" yaml:"expiry_date"`
	ProdStatusCode       string        `boil:"prod_status_code" json:"prod_status_code" toml:"prod_status_code" yaml:"prod_status_code"`
	LCCurrency           string        `boil:"lc_currency" json:"lc_currency" toml:"lc_currency" yaml:"lc_currency"`
	LCAmount             types.Decimal `boil:"lc_amount" json:"lc_amount" toml:"lc_amount" yaml:"lc_amount"`
	LCLiabilityCurrency  string        `boil:"lc_liability_currency" json:"lc_liability_currency" toml:"lc_liability_currency" yaml:"lc_liability_currency"`
	LCLiabilityAmt       types.Decimal `boil:"lc_liability_amt" json:"lc_liability_amt" toml:"lc_liability_amt" yaml:"lc_liability_amt"`
	ApplicantName        string        `boil:"applicant_name" json:"applicant_name" toml:"applicant_name" yaml:"applicant_name"`
	ApplicantAddress     string        `boil:"applicant_address" json:"applicant_address" toml:"applicant_address" yaml:"applicant_address"`
	BeneficiaryName      string        `boil:"beneficiary_name" json:"beneficiary_name" toml:"beneficiary_name" yaml:"beneficiary_name"`
	BeneficiaryAddress   string        `boil:"beneficiary_address" json:"beneficiary_address" toml:"beneficiary_address" yaml:"beneficiary_address"`
	BeneficiaryCountry   string        `boil:"beneficiary_country" json:"beneficiary_country" toml:"beneficiary_country" yaml:"beneficiary_country"`
	AmendDate            time.Time     `boil:"amend_date" json:"amend_date" toml:"amend_date" yaml:"amend_date"`
	AmendNum             int           `boil:"amend_num" json:"amend_num" toml:"amend_num" yaml:"amend_num"`
	ExpiryPlace          string        `boil:"expiry_place" json:"expiry_place" toml:"expiry_place" yaml:"expiry_place"`
	AdvanceSendMode      string        `boil:"advance_send_mode" json:"advance_send_mode" toml:"advance_send_mode" yaml:"advance_send_mode"`
	IncoTerm             string        `boil:"inco_term" json:"inco_term" toml:"inco_term" yaml:"inco_term"`
	IncoPlace            string        `boil:"inco_place" json:"inco_place" toml:"inco_place" yaml:"inco_place"`
	ShipFrom             string        `boil:"ship_from" json:"ship_from" toml:"ship_from" yaml:"ship_from"`
	ShipTo               string        `boil:"ship_to" json:"ship_to" toml:"ship_to" yaml:"ship_to"`
	DraftTerm            string        `boil:"draft_term" json:"draft_term" toml:"draft_term" yaml:"draft_term"`
	CityOfDest           string        `boil:"city_of_dest" json:"city_of_dest" toml:"city_of_dest" yaml:"city_of_dest"`
	ChargeBRNBy          string        `boil:"charge_brn_by" json:"charge_brn_by" toml:"charge_brn_by" yaml:"charge_brn_by"`
	PartShipDTL          string        `boil:"part_ship_dtl" json:"part_ship_dtl" toml:"part_ship_dtl" yaml:"part_ship_dtl"`
	TranShipDTL          string        `boil:"tran_ship_dtl" json:"tran_ship_dtl" toml:"tran_ship_dtl" yaml:"tran_ship_dtl"`
	GoodsCategory        string        `boil:"goods_category" json:"goods_category" toml:"goods_category" yaml:"goods_category"`
	AdvisingBank         string        `boil:"advising_bank" json:"advising_bank" toml:"advising_bank" yaml:"advising_bank"`
	ReimbursingBank      string        `boil:"reimbursing_bank" json:"reimbursing_bank" toml:"reimbursing_bank" yaml:"reimbursing_bank"`
	MakerDate            time.Time     `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate          null.Time     `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID              string        `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID            null.String   `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy           null.String   `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate         null.Time     `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`
	SwiftInStatus        null.String   `boil:"swift_in_status" json:"swift_in_status,omitempty" toml:"swift_in_status" yaml:"swift_in_status,omitempty"`
	SwiftOutStatus       null.String   `boil:"swift_out_status" json:"swift_out_status,omitempty" toml:"swift_out_status" yaml:"swift_out_status,omitempty"`
	OfacStatus           null.String   `boil:"ofac_status" json:"ofac_status,omitempty" toml:"ofac_status" yaml:"ofac_status,omitempty"`
	PenaltyDetails       null.String   `boil:"penalty_details" json:"penalty_details,omitempty" toml:"penalty_details" yaml:"penalty_details,omitempty"`

	R *tFLetterOfCreditR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L tFLetterOfCreditL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TFLetterOfCreditColumns = struct {
	TFLCID               string
	ReferenceID          string
	BranchID             string
	ProductCode          string
	PartyID              string
	AccountNumber        string
	OurReferenceID       string
	RevocableFlag        string
	STNDByLCFlag         string
	Status               string
	LetterofCreditNumber string
	ExportOrImport       string
	LCType               string
	Ccy                  string
	LinkedAccountID      string
	BankID               string
	Amount               string
	ApplicationDate      string
	IssueDate            string
	ExpiryDate           string
	ProdStatusCode       string
	LCCurrency           string
	LCAmount             string
	LCLiabilityCurrency  string
	LCLiabilityAmt       string
	ApplicantName        string
	ApplicantAddress     string
	BeneficiaryName      string
	BeneficiaryAddress   string
	BeneficiaryCountry   string
	AmendDate            string
	AmendNum             string
	ExpiryPlace          string
	AdvanceSendMode      string
	IncoTerm             string
	IncoPlace            string
	ShipFrom             string
	ShipTo               string
	DraftTerm            string
	CityOfDest           string
	ChargeBRNBy          string
	PartShipDTL          string
	TranShipDTL          string
	GoodsCategory        string
	AdvisingBank         string
	ReimbursingBank      string
	MakerDate            string
	CheckerDate          string
	MakerID              string
	CheckerID            string
	ModifiedBy           string
	ModifiedDate         string
	SwiftInStatus        string
	SwiftOutStatus       string
	OfacStatus           string
	PenaltyDetails       string
}{
	TFLCID:               "tf_lc_id",
	ReferenceID:          "reference_id",
	BranchID:             "branch_id",
	ProductCode:          "product_code",
	PartyID:              "party_id",
	AccountNumber:        "account_number",
	OurReferenceID:       "our_reference_id",
	RevocableFlag:        "revocable_flag",
	STNDByLCFlag:         "stnd_by_lc_flag",
	Status:               "status",
	LetterofCreditNumber: "letterof_credit_number",
	ExportOrImport:       "export_or_import",
	LCType:               "lc_type",
	Ccy:                  "ccy",
	LinkedAccountID:      "linked_account_id",
	BankID:               "bank_id",
	Amount:               "amount",
	ApplicationDate:      "application_date",
	IssueDate:            "issue_date",
	ExpiryDate:           "expiry_date",
	ProdStatusCode:       "prod_status_code",
	LCCurrency:           "lc_currency",
	LCAmount:             "lc_amount",
	LCLiabilityCurrency:  "lc_liability_currency",
	LCLiabilityAmt:       "lc_liability_amt",
	ApplicantName:        "applicant_name",
	ApplicantAddress:     "applicant_address",
	BeneficiaryName:      "beneficiary_name",
	BeneficiaryAddress:   "beneficiary_address",
	BeneficiaryCountry:   "beneficiary_country",
	AmendDate:            "amend_date",
	AmendNum:             "amend_num",
	ExpiryPlace:          "expiry_place",
	AdvanceSendMode:      "advance_send_mode",
	IncoTerm:             "inco_term",
	IncoPlace:            "inco_place",
	ShipFrom:             "ship_from",
	ShipTo:               "ship_to",
	DraftTerm:            "draft_term",
	CityOfDest:           "city_of_dest",
	ChargeBRNBy:          "charge_brn_by",
	PartShipDTL:          "part_ship_dtl",
	TranShipDTL:          "tran_ship_dtl",
	GoodsCategory:        "goods_category",
	AdvisingBank:         "advising_bank",
	ReimbursingBank:      "reimbursing_bank",
	MakerDate:            "maker_date",
	CheckerDate:          "checker_date",
	MakerID:              "maker_id",
	CheckerID:            "checker_id",
	ModifiedBy:           "modified_by",
	ModifiedDate:         "modified_date",
	SwiftInStatus:        "swift_in_status",
	SwiftOutStatus:       "swift_out_status",
	OfacStatus:           "ofac_status",
	PenaltyDetails:       "penalty_details",
}

// Generated where

var TFLetterOfCreditWhere = struct {
	TFLCID               whereHelperint
	ReferenceID          whereHelperstring
	BranchID             whereHelperint
	ProductCode          whereHelperstring
	PartyID              whereHelperint
	AccountNumber        whereHelperstring
	OurReferenceID       whereHelperstring
	RevocableFlag        whereHelperstring
	STNDByLCFlag         whereHelperstring
	Status               whereHelperstring
	LetterofCreditNumber whereHelperstring
	ExportOrImport       whereHelperstring
	LCType               whereHelperstring
	Ccy                  whereHelperstring
	LinkedAccountID      whereHelperint
	BankID               whereHelperint
	Amount               whereHelpertypes_Decimal
	ApplicationDate      whereHelpertime_Time
	IssueDate            whereHelpertime_Time
	ExpiryDate           whereHelpertime_Time
	ProdStatusCode       whereHelperstring
	LCCurrency           whereHelperstring
	LCAmount             whereHelpertypes_Decimal
	LCLiabilityCurrency  whereHelperstring
	LCLiabilityAmt       whereHelpertypes_Decimal
	ApplicantName        whereHelperstring
	ApplicantAddress     whereHelperstring
	BeneficiaryName      whereHelperstring
	BeneficiaryAddress   whereHelperstring
	BeneficiaryCountry   whereHelperstring
	AmendDate            whereHelpertime_Time
	AmendNum             whereHelperint
	ExpiryPlace          whereHelperstring
	AdvanceSendMode      whereHelperstring
	IncoTerm             whereHelperstring
	IncoPlace            whereHelperstring
	ShipFrom             whereHelperstring
	ShipTo               whereHelperstring
	DraftTerm            whereHelperstring
	CityOfDest           whereHelperstring
	ChargeBRNBy          whereHelperstring
	PartShipDTL          whereHelperstring
	TranShipDTL          whereHelperstring
	GoodsCategory        whereHelperstring
	AdvisingBank         whereHelperstring
	ReimbursingBank      whereHelperstring
	MakerDate            whereHelpertime_Time
	CheckerDate          whereHelpernull_Time
	MakerID              whereHelperstring
	CheckerID            whereHelpernull_String
	ModifiedBy           whereHelpernull_String
	ModifiedDate         whereHelpernull_Time
	SwiftInStatus        whereHelpernull_String
	SwiftOutStatus       whereHelpernull_String
	OfacStatus           whereHelpernull_String
	PenaltyDetails       whereHelpernull_String
}{
	TFLCID:               whereHelperint{field: `tf_lc_id`},
	ReferenceID:          whereHelperstring{field: `reference_id`},
	BranchID:             whereHelperint{field: `branch_id`},
	ProductCode:          whereHelperstring{field: `product_code`},
	PartyID:              whereHelperint{field: `party_id`},
	AccountNumber:        whereHelperstring{field: `account_number`},
	OurReferenceID:       whereHelperstring{field: `our_reference_id`},
	RevocableFlag:        whereHelperstring{field: `revocable_flag`},
	STNDByLCFlag:         whereHelperstring{field: `stnd_by_lc_flag`},
	Status:               whereHelperstring{field: `status`},
	LetterofCreditNumber: whereHelperstring{field: `letterof_credit_number`},
	ExportOrImport:       whereHelperstring{field: `export_or_import`},
	LCType:               whereHelperstring{field: `lc_type`},
	Ccy:                  whereHelperstring{field: `ccy`},
	LinkedAccountID:      whereHelperint{field: `linked_account_id`},
	BankID:               whereHelperint{field: `bank_id`},
	Amount:               whereHelpertypes_Decimal{field: `amount`},
	ApplicationDate:      whereHelpertime_Time{field: `application_date`},
	IssueDate:            whereHelpertime_Time{field: `issue_date`},
	ExpiryDate:           whereHelpertime_Time{field: `expiry_date`},
	ProdStatusCode:       whereHelperstring{field: `prod_status_code`},
	LCCurrency:           whereHelperstring{field: `lc_currency`},
	LCAmount:             whereHelpertypes_Decimal{field: `lc_amount`},
	LCLiabilityCurrency:  whereHelperstring{field: `lc_liability_currency`},
	LCLiabilityAmt:       whereHelpertypes_Decimal{field: `lc_liability_amt`},
	ApplicantName:        whereHelperstring{field: `applicant_name`},
	ApplicantAddress:     whereHelperstring{field: `applicant_address`},
	BeneficiaryName:      whereHelperstring{field: `beneficiary_name`},
	BeneficiaryAddress:   whereHelperstring{field: `beneficiary_address`},
	BeneficiaryCountry:   whereHelperstring{field: `beneficiary_country`},
	AmendDate:            whereHelpertime_Time{field: `amend_date`},
	AmendNum:             whereHelperint{field: `amend_num`},
	ExpiryPlace:          whereHelperstring{field: `expiry_place`},
	AdvanceSendMode:      whereHelperstring{field: `advance_send_mode`},
	IncoTerm:             whereHelperstring{field: `inco_term`},
	IncoPlace:            whereHelperstring{field: `inco_place`},
	ShipFrom:             whereHelperstring{field: `ship_from`},
	ShipTo:               whereHelperstring{field: `ship_to`},
	DraftTerm:            whereHelperstring{field: `draft_term`},
	CityOfDest:           whereHelperstring{field: `city_of_dest`},
	ChargeBRNBy:          whereHelperstring{field: `charge_brn_by`},
	PartShipDTL:          whereHelperstring{field: `part_ship_dtl`},
	TranShipDTL:          whereHelperstring{field: `tran_ship_dtl`},
	GoodsCategory:        whereHelperstring{field: `goods_category`},
	AdvisingBank:         whereHelperstring{field: `advising_bank`},
	ReimbursingBank:      whereHelperstring{field: `reimbursing_bank`},
	MakerDate:            whereHelpertime_Time{field: `maker_date`},
	CheckerDate:          whereHelpernull_Time{field: `checker_date`},
	MakerID:              whereHelperstring{field: `maker_id`},
	CheckerID:            whereHelpernull_String{field: `checker_id`},
	ModifiedBy:           whereHelpernull_String{field: `modified_by`},
	ModifiedDate:         whereHelpernull_Time{field: `modified_date`},
	SwiftInStatus:        whereHelpernull_String{field: `swift_in_status`},
	SwiftOutStatus:       whereHelpernull_String{field: `swift_out_status`},
	OfacStatus:           whereHelpernull_String{field: `ofac_status`},
	PenaltyDetails:       whereHelpernull_String{field: `penalty_details`},
}

// TFLetterOfCreditRels is where relationship names are stored.
var TFLetterOfCreditRels = struct {
	Bank                          string
	Party                         string
	ReferenceTFInterests          string
	ReferenceTFInterestTxns       string
	ReferenceTFLcLetters          string
	ReferenceTFLcLetterTxns       string
	ReferenceTFLetterOfCreditTxns string
	ReferenceTFParties            string
	ReferenceTFPartyTxns          string
}{
	Bank:                          "Bank",
	Party:                         "Party",
	ReferenceTFInterests:          "ReferenceTFInterests",
	ReferenceTFInterestTxns:       "ReferenceTFInterestTxns",
	ReferenceTFLcLetters:          "ReferenceTFLcLetters",
	ReferenceTFLcLetterTxns:       "ReferenceTFLcLetterTxns",
	ReferenceTFLetterOfCreditTxns: "ReferenceTFLetterOfCreditTxns",
	ReferenceTFParties:            "ReferenceTFParties",
	ReferenceTFPartyTxns:          "ReferenceTFPartyTxns",
}

// tFLetterOfCreditR is where relationships are stored.
type tFLetterOfCreditR struct {
	Bank                          *Bank
	Party                         *Party
	ReferenceTFInterests          TFInterestSlice
	ReferenceTFInterestTxns       TFInterestTxnSlice
	ReferenceTFLcLetters          TFLcLetterSlice
	ReferenceTFLcLetterTxns       TFLcLetterTxnSlice
	ReferenceTFLetterOfCreditTxns TFLetterOfCreditTxnSlice
	ReferenceTFParties            TFPartySlice
	ReferenceTFPartyTxns          TFPartyTxnSlice
}

// NewStruct creates a new relationship struct
func (*tFLetterOfCreditR) NewStruct() *tFLetterOfCreditR {
	return &tFLetterOfCreditR{}
}

// tFLetterOfCreditL is where Load methods for each relationship are stored.
type tFLetterOfCreditL struct{}

var (
	tFLetterOfCreditColumns               = []string{"tf_lc_id", "reference_id", "branch_id", "product_code", "party_id", "account_number", "our_reference_id", "revocable_flag", "stnd_by_lc_flag", "status", "letterof_credit_number", "export_or_import", "lc_type", "ccy", "linked_account_id", "bank_id", "amount", "application_date", "issue_date", "expiry_date", "prod_status_code", "lc_currency", "lc_amount", "lc_liability_currency", "lc_liability_amt", "applicant_name", "applicant_address", "beneficiary_name", "beneficiary_address", "beneficiary_country", "amend_date", "amend_num", "expiry_place", "advance_send_mode", "inco_term", "inco_place", "ship_from", "ship_to", "draft_term", "city_of_dest", "charge_brn_by", "part_ship_dtl", "tran_ship_dtl", "goods_category", "advising_bank", "reimbursing_bank", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "swift_in_status", "swift_out_status", "ofac_status", "penalty_details"}
	tFLetterOfCreditColumnsWithoutDefault = []string{"tf_lc_id", "reference_id", "branch_id", "product_code", "party_id", "account_number", "our_reference_id", "revocable_flag", "stnd_by_lc_flag", "status", "letterof_credit_number", "export_or_import", "lc_type", "ccy", "linked_account_id", "bank_id", "amount", "application_date", "issue_date", "expiry_date", "prod_status_code", "lc_currency", "lc_amount", "lc_liability_currency", "lc_liability_amt", "applicant_name", "applicant_address", "beneficiary_name", "beneficiary_address", "beneficiary_country", "amend_date", "amend_num", "expiry_place", "advance_send_mode", "inco_term", "inco_place", "ship_from", "ship_to", "draft_term", "city_of_dest", "charge_brn_by", "part_ship_dtl", "tran_ship_dtl", "goods_category", "advising_bank", "reimbursing_bank", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "swift_in_status", "swift_out_status", "ofac_status", "penalty_details"}
	tFLetterOfCreditColumnsWithDefault    = []string{}
	tFLetterOfCreditPrimaryKeyColumns     = []string{"tf_lc_id"}
)

type (
	// TFLetterOfCreditSlice is an alias for a slice of pointers to TFLetterOfCredit.
	// This should generally be used opposed to []TFLetterOfCredit.
	TFLetterOfCreditSlice []*TFLetterOfCredit
	// TFLetterOfCreditHook is the signature for custom TFLetterOfCredit hook methods
	TFLetterOfCreditHook func(context.Context, boil.ContextExecutor, *TFLetterOfCredit) error

	tFLetterOfCreditQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	tFLetterOfCreditType                 = reflect.TypeOf(&TFLetterOfCredit{})
	tFLetterOfCreditMapping              = queries.MakeStructMapping(tFLetterOfCreditType)
	tFLetterOfCreditPrimaryKeyMapping, _ = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, tFLetterOfCreditPrimaryKeyColumns)
	tFLetterOfCreditInsertCacheMut       sync.RWMutex
	tFLetterOfCreditInsertCache          = make(map[string]insertCache)
	tFLetterOfCreditUpdateCacheMut       sync.RWMutex
	tFLetterOfCreditUpdateCache          = make(map[string]updateCache)
	tFLetterOfCreditUpsertCacheMut       sync.RWMutex
	tFLetterOfCreditUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var tFLetterOfCreditBeforeInsertHooks []TFLetterOfCreditHook
var tFLetterOfCreditBeforeUpdateHooks []TFLetterOfCreditHook
var tFLetterOfCreditBeforeDeleteHooks []TFLetterOfCreditHook
var tFLetterOfCreditBeforeUpsertHooks []TFLetterOfCreditHook

var tFLetterOfCreditAfterInsertHooks []TFLetterOfCreditHook
var tFLetterOfCreditAfterSelectHooks []TFLetterOfCreditHook
var tFLetterOfCreditAfterUpdateHooks []TFLetterOfCreditHook
var tFLetterOfCreditAfterDeleteHooks []TFLetterOfCreditHook
var tFLetterOfCreditAfterUpsertHooks []TFLetterOfCreditHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *TFLetterOfCredit) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *TFLetterOfCredit) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *TFLetterOfCredit) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *TFLetterOfCredit) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *TFLetterOfCredit) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *TFLetterOfCredit) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *TFLetterOfCredit) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *TFLetterOfCredit) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *TFLetterOfCredit) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range tFLetterOfCreditAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTFLetterOfCreditHook registers your hook function for all future operations.
func AddTFLetterOfCreditHook(hookPoint boil.HookPoint, tFLetterOfCreditHook TFLetterOfCreditHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		tFLetterOfCreditBeforeInsertHooks = append(tFLetterOfCreditBeforeInsertHooks, tFLetterOfCreditHook)
	case boil.BeforeUpdateHook:
		tFLetterOfCreditBeforeUpdateHooks = append(tFLetterOfCreditBeforeUpdateHooks, tFLetterOfCreditHook)
	case boil.BeforeDeleteHook:
		tFLetterOfCreditBeforeDeleteHooks = append(tFLetterOfCreditBeforeDeleteHooks, tFLetterOfCreditHook)
	case boil.BeforeUpsertHook:
		tFLetterOfCreditBeforeUpsertHooks = append(tFLetterOfCreditBeforeUpsertHooks, tFLetterOfCreditHook)
	case boil.AfterInsertHook:
		tFLetterOfCreditAfterInsertHooks = append(tFLetterOfCreditAfterInsertHooks, tFLetterOfCreditHook)
	case boil.AfterSelectHook:
		tFLetterOfCreditAfterSelectHooks = append(tFLetterOfCreditAfterSelectHooks, tFLetterOfCreditHook)
	case boil.AfterUpdateHook:
		tFLetterOfCreditAfterUpdateHooks = append(tFLetterOfCreditAfterUpdateHooks, tFLetterOfCreditHook)
	case boil.AfterDeleteHook:
		tFLetterOfCreditAfterDeleteHooks = append(tFLetterOfCreditAfterDeleteHooks, tFLetterOfCreditHook)
	case boil.AfterUpsertHook:
		tFLetterOfCreditAfterUpsertHooks = append(tFLetterOfCreditAfterUpsertHooks, tFLetterOfCreditHook)
	}
}

// One returns a single tFLetterOfCredit record from the query.
func (q tFLetterOfCreditQuery) One(ctx context.Context, exec boil.ContextExecutor) (*TFLetterOfCredit, error) {
	o := &TFLetterOfCredit{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for TFLetterOfCredit")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all TFLetterOfCredit records from the query.
func (q tFLetterOfCreditQuery) All(ctx context.Context, exec boil.ContextExecutor) (TFLetterOfCreditSlice, error) {
	var o []*TFLetterOfCredit

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to TFLetterOfCredit slice")
	}

	if len(tFLetterOfCreditAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all TFLetterOfCredit records in the query.
func (q tFLetterOfCreditQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count TFLetterOfCredit rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q tFLetterOfCreditQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if TFLetterOfCredit exists")
	}

	return count > 0, nil
}

// Bank pointed to by the foreign key.
func (o *TFLetterOfCredit) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// Party pointed to by the foreign key.
func (o *TFLetterOfCredit) Party(mods ...qm.QueryMod) partyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	return query
}

// ReferenceTFInterests retrieves all the TFInterest's TFInterests with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFInterests(mods ...qm.QueryMod) tFInterestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFInterest`.`reference_id`=?", o.ReferenceID),
	)

	query := TFInterests(queryMods...)
	queries.SetFrom(query.Query, "`TFInterest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFInterest`.*"})
	}

	return query
}

// ReferenceTFInterestTxns retrieves all the TFInterestTxn's TFInterestTxns with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFInterestTxns(mods ...qm.QueryMod) tFInterestTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFInterestTxn`.`reference_id`=?", o.ReferenceID),
	)

	query := TFInterestTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFInterestTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFInterestTxn`.*"})
	}

	return query
}

// ReferenceTFLcLetters retrieves all the TFLcLetter's TFLcLetters with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFLcLetters(mods ...qm.QueryMod) tFLcLetterQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLcLetter`.`reference_id`=?", o.ReferenceID),
	)

	query := TFLcLetters(queryMods...)
	queries.SetFrom(query.Query, "`TFLcLetter`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLcLetter`.*"})
	}

	return query
}

// ReferenceTFLcLetterTxns retrieves all the TFLcLetterTxn's TFLcLetterTxns with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFLcLetterTxns(mods ...qm.QueryMod) tFLcLetterTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLcLetterTxn`.`reference_id`=?", o.ReferenceID),
	)

	query := TFLcLetterTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFLcLetterTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLcLetterTxn`.*"})
	}

	return query
}

// ReferenceTFLetterOfCreditTxns retrieves all the TFLetterOfCreditTxn's TFLetterOfCreditTxns with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFLetterOfCreditTxns(mods ...qm.QueryMod) tFLetterOfCreditTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLetterOfCreditTxn`.`reference_id`=?", o.ReferenceID),
	)

	query := TFLetterOfCreditTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCreditTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLetterOfCreditTxn`.*"})
	}

	return query
}

// ReferenceTFParties retrieves all the TFParty's TFParties with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFParties(mods ...qm.QueryMod) tFPartyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFParty`.`reference_id`=?", o.ReferenceID),
	)

	query := TFParties(queryMods...)
	queries.SetFrom(query.Query, "`TFParty`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFParty`.*"})
	}

	return query
}

// ReferenceTFPartyTxns retrieves all the TFPartyTxn's TFPartyTxns with an executor via reference_id column.
func (o *TFLetterOfCredit) ReferenceTFPartyTxns(mods ...qm.QueryMod) tFPartyTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFPartyTxn`.`reference_id`=?", o.ReferenceID),
	)

	query := TFPartyTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFPartyTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFPartyTxn`.*"})
	}

	return query
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (tFLetterOfCreditL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(tFLetterOfCreditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankTFLetterOfCredits = append(foreign.R.BankTFLetterOfCredits, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankTFLetterOfCredits = append(foreign.R.BankTFLetterOfCredits, local)
				break
			}
		}
	}

	return nil
}

// LoadParty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (tFLetterOfCreditL) LoadParty(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.PartyID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Party")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Party")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(tFLetterOfCreditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Party = foreign
		if foreign.R == nil {
			foreign.R = &partyR{}
		}
		foreign.R.PartyTFLetterOfCredits = append(foreign.R.PartyTFLetterOfCredits, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.Party = foreign
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.PartyTFLetterOfCredits = append(foreign.R.PartyTFLetterOfCredits, local)
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFInterests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFInterests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFInterest`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFInterest")
	}

	var resultSlice []*TFInterest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFInterest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFInterest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFInterest")
	}

	if len(tFInterestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFInterests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFInterestR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFInterests = append(local.R.ReferenceTFInterests, foreign)
				if foreign.R == nil {
					foreign.R = &tFInterestR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFInterestTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFInterestTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFInterestTxn`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFInterestTxn")
	}

	var resultSlice []*TFInterestTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFInterestTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFInterestTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFInterestTxn")
	}

	if len(tFInterestTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFInterestTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFInterestTxnR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFInterestTxns = append(local.R.ReferenceTFInterestTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFInterestTxnR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFLcLetters allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFLcLetters(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLcLetter`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLcLetter")
	}

	var resultSlice []*TFLcLetter
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLcLetter")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLcLetter")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLcLetter")
	}

	if len(tFLcLetterAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFLcLetters = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLcLetterR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFLcLetters = append(local.R.ReferenceTFLcLetters, foreign)
				if foreign.R == nil {
					foreign.R = &tFLcLetterR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFLcLetterTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFLcLetterTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLcLetterTxn`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLcLetterTxn")
	}

	var resultSlice []*TFLcLetterTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLcLetterTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLcLetterTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLcLetterTxn")
	}

	if len(tFLcLetterTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFLcLetterTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLcLetterTxnR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFLcLetterTxns = append(local.R.ReferenceTFLcLetterTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFLcLetterTxnR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFLetterOfCreditTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFLetterOfCreditTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCreditTxn`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCreditTxn")
	}

	var resultSlice []*TFLetterOfCreditTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCreditTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLetterOfCreditTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCreditTxn")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFLetterOfCreditTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLetterOfCreditTxnR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFLetterOfCreditTxns = append(local.R.ReferenceTFLetterOfCreditTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditTxnR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFParties allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFParties(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFParty`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFParty")
	}

	var resultSlice []*TFParty
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFParty")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFParty")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFParty")
	}

	if len(tFPartyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFParties = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFParties = append(local.R.ReferenceTFParties, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// LoadReferenceTFPartyTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (tFLetterOfCreditL) LoadReferenceTFPartyTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTFLetterOfCredit interface{}, mods queries.Applicator) error {
	var slice []*TFLetterOfCredit
	var object *TFLetterOfCredit

	if singular {
		object = maybeTFLetterOfCredit.(*TFLetterOfCredit)
	} else {
		slice = *maybeTFLetterOfCredit.(*[]*TFLetterOfCredit)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &tFLetterOfCreditR{}
		}
		args = append(args, object.ReferenceID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &tFLetterOfCreditR{}
			}

			for _, a := range args {
				if a == obj.ReferenceID {
					continue Outer
				}
			}

			args = append(args, obj.ReferenceID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFPartyTxn`), qm.WhereIn(`reference_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFPartyTxn")
	}

	var resultSlice []*TFPartyTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFPartyTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFPartyTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFPartyTxn")
	}

	if len(tFPartyTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferenceTFPartyTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyTxnR{}
			}
			foreign.R.Reference = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReferenceID == foreign.ReferenceID {
				local.R.ReferenceTFPartyTxns = append(local.R.ReferenceTFPartyTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyTxnR{}
				}
				foreign.R.Reference = local
				break
			}
		}
	}

	return nil
}

// SetBank of the tFLetterOfCredit to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankTFLetterOfCredits.
func (o *TFLetterOfCredit) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `TFLetterOfCredit` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.TFLCID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankTFLetterOfCredits: TFLetterOfCreditSlice{o},
		}
	} else {
		related.R.BankTFLetterOfCredits = append(related.R.BankTFLetterOfCredits, o)
	}

	return nil
}

// SetParty of the tFLetterOfCredit to the related item.
// Sets o.R.Party to related.
// Adds o to related.R.PartyTFLetterOfCredits.
func (o *TFLetterOfCredit) SetParty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Party) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `TFLetterOfCredit` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
		strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns),
	)
	values := []interface{}{related.PartyID, o.TFLCID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PartyID = related.PartyID
	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			Party: related,
		}
	} else {
		o.R.Party = related
	}

	if related.R == nil {
		related.R = &partyR{
			PartyTFLetterOfCredits: TFLetterOfCreditSlice{o},
		}
	} else {
		related.R.PartyTFLetterOfCredits = append(related.R.PartyTFLetterOfCredits, o)
	}

	return nil
}

// AddReferenceTFInterests adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFInterests.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFInterests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFInterest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFInterest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFInterestPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TradeInterestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFInterests: related,
		}
	} else {
		o.R.ReferenceTFInterests = append(o.R.ReferenceTFInterests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFInterestR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFInterestTxns adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFInterestTxns.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFInterestTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFInterestTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFInterestTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFInterestTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TradeInterestID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFInterestTxns: related,
		}
	} else {
		o.R.ReferenceTFInterestTxns = append(o.R.ReferenceTFInterestTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFInterestTxnR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFLcLetters adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFLcLetters.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFLcLetters(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLcLetter) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLcLetter` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFLcLetterPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TFLCLetterID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFLcLetters: related,
		}
	} else {
		o.R.ReferenceTFLcLetters = append(o.R.ReferenceTFLcLetters, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLcLetterR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFLcLetterTxns adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFLcLetterTxns.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFLcLetterTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLcLetterTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLcLetterTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFLcLetterTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TFLCLetterID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFLcLetterTxns: related,
		}
	} else {
		o.R.ReferenceTFLcLetterTxns = append(o.R.ReferenceTFLcLetterTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLcLetterTxnR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFLetterOfCreditTxns adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFLetterOfCreditTxns.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFLetterOfCreditTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLetterOfCreditTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TFLCTXNID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFLetterOfCreditTxns: related,
		}
	} else {
		o.R.ReferenceTFLetterOfCreditTxns = append(o.R.ReferenceTFLetterOfCreditTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLetterOfCreditTxnR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFParties adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFParties.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFParties(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFParty) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFParty` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TFPartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFParties: related,
		}
	} else {
		o.R.ReferenceTFParties = append(o.R.ReferenceTFParties, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// AddReferenceTFPartyTxns adds the given related objects to the existing relationships
// of the TFLetterOfCredit, optionally inserting them as new records.
// Appends related to o.R.ReferenceTFPartyTxns.
// Sets related.R.Reference appropriately.
func (o *TFLetterOfCredit) AddReferenceTFPartyTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFPartyTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferenceID = o.ReferenceID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFPartyTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reference_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.ReferenceID, rel.TFPartyID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferenceID = o.ReferenceID
		}
	}

	if o.R == nil {
		o.R = &tFLetterOfCreditR{
			ReferenceTFPartyTxns: related,
		}
	} else {
		o.R.ReferenceTFPartyTxns = append(o.R.ReferenceTFPartyTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyTxnR{
				Reference: o,
			}
		} else {
			rel.R.Reference = o
		}
	}
	return nil
}

// TFLetterOfCredits retrieves all the records using an executor.
func TFLetterOfCredits(mods ...qm.QueryMod) tFLetterOfCreditQuery {
	mods = append(mods, qm.From("`TFLetterOfCredit`"))
	return tFLetterOfCreditQuery{NewQuery(mods...)}
}

// FindTFLetterOfCredit retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTFLetterOfCredit(ctx context.Context, exec boil.ContextExecutor, tFLCID int, selectCols ...string) (*TFLetterOfCredit, error) {
	tFLetterOfCreditObj := &TFLetterOfCredit{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `TFLetterOfCredit` where `tf_lc_id`=?", sel,
	)

	q := queries.Raw(query, tFLCID)

	err := q.Bind(ctx, exec, tFLetterOfCreditObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from TFLetterOfCredit")
	}

	return tFLetterOfCreditObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *TFLetterOfCredit) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no TFLetterOfCredit provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(tFLetterOfCreditColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	tFLetterOfCreditInsertCacheMut.RLock()
	cache, cached := tFLetterOfCreditInsertCache[key]
	tFLetterOfCreditInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			tFLetterOfCreditColumns,
			tFLetterOfCreditColumnsWithDefault,
			tFLetterOfCreditColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `TFLetterOfCredit` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `TFLetterOfCredit` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `TFLetterOfCredit` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into TFLetterOfCredit")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.TFLCID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for TFLetterOfCredit")
	}

CacheNoHooks:
	if !cached {
		tFLetterOfCreditInsertCacheMut.Lock()
		tFLetterOfCreditInsertCache[key] = cache
		tFLetterOfCreditInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the TFLetterOfCredit.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *TFLetterOfCredit) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	tFLetterOfCreditUpdateCacheMut.RLock()
	cache, cached := tFLetterOfCreditUpdateCache[key]
	tFLetterOfCreditUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			tFLetterOfCreditColumns,
			tFLetterOfCreditPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update TFLetterOfCredit, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `TFLetterOfCredit` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, append(wl, tFLetterOfCreditPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update TFLetterOfCredit row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for TFLetterOfCredit")
	}

	if !cached {
		tFLetterOfCreditUpdateCacheMut.Lock()
		tFLetterOfCreditUpdateCache[key] = cache
		tFLetterOfCreditUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q tFLetterOfCreditQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for TFLetterOfCredit")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for TFLetterOfCredit")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TFLetterOfCreditSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `TFLetterOfCredit` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in tFLetterOfCredit slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all tFLetterOfCredit")
	}
	return rowsAff, nil
}

var mySQLTFLetterOfCreditUniqueColumns = []string{
	"tf_lc_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *TFLetterOfCredit) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no TFLetterOfCredit provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(tFLetterOfCreditColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLTFLetterOfCreditUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	tFLetterOfCreditUpsertCacheMut.RLock()
	cache, cached := tFLetterOfCreditUpsertCache[key]
	tFLetterOfCreditUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			tFLetterOfCreditColumns,
			tFLetterOfCreditColumnsWithDefault,
			tFLetterOfCreditColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			tFLetterOfCreditColumns,
			tFLetterOfCreditPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert TFLetterOfCredit, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "TFLetterOfCredit", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `TFLetterOfCredit` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for TFLetterOfCredit")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(tFLetterOfCreditType, tFLetterOfCreditMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for TFLetterOfCredit")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for TFLetterOfCredit")
	}

CacheNoHooks:
	if !cached {
		tFLetterOfCreditUpsertCacheMut.Lock()
		tFLetterOfCreditUpsertCache[key] = cache
		tFLetterOfCreditUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single TFLetterOfCredit record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *TFLetterOfCredit) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no TFLetterOfCredit provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), tFLetterOfCreditPrimaryKeyMapping)
	sql := "DELETE FROM `TFLetterOfCredit` WHERE `tf_lc_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from TFLetterOfCredit")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for TFLetterOfCredit")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q tFLetterOfCreditQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no tFLetterOfCreditQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from TFLetterOfCredit")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for TFLetterOfCredit")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TFLetterOfCreditSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no TFLetterOfCredit slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(tFLetterOfCreditBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `TFLetterOfCredit` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from tFLetterOfCredit slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for TFLetterOfCredit")
	}

	if len(tFLetterOfCreditAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *TFLetterOfCredit) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTFLetterOfCredit(ctx, exec, o.TFLCID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TFLetterOfCreditSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TFLetterOfCreditSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), tFLetterOfCreditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `TFLetterOfCredit`.* FROM `TFLetterOfCredit` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, tFLetterOfCreditPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in TFLetterOfCreditSlice")
	}

	*o = slice

	return nil
}

// TFLetterOfCreditExists checks if the TFLetterOfCredit row exists.
func TFLetterOfCreditExists(ctx context.Context, exec boil.ContextExecutor, tFLCID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `TFLetterOfCredit` where `tf_lc_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, tFLCID)
	}

	row := exec.QueryRowContext(ctx, sql, tFLCID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if TFLetterOfCredit exists")
	}

	return exists, nil
}
