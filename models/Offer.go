// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Offer is an object representing the database table.
type Offer struct {
	OfferID       int               `boil:"offer_id" json:"offer_id" toml:"offer_id" yaml:"offer_id"`
	AccountID     int               `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	OfferType     null.String       `boil:"offer_type" json:"offer_type,omitempty" toml:"offer_type" yaml:"offer_type,omitempty"`
	OfferRefID    string            `boil:"offer_ref_id" json:"offer_ref_id" toml:"offer_ref_id" yaml:"offer_ref_id"`
	Description   null.String       `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	StartDateTime null.Time         `boil:"start_date_time" json:"start_date_time,omitempty" toml:"start_date_time" yaml:"start_date_time,omitempty"`
	EndDateTime   null.Time         `boil:"end_date_time" json:"end_date_time,omitempty" toml:"end_date_time" yaml:"end_date_time,omitempty"`
	Rate          null.String       `boil:"rate" json:"rate,omitempty" toml:"rate" yaml:"rate,omitempty"`
	Value         types.NullDecimal `boil:"value" json:"value,omitempty" toml:"value" yaml:"value,omitempty"`
	Term          null.String       `boil:"term" json:"term,omitempty" toml:"term" yaml:"term,omitempty"`
	URL           null.String       `boil:"url" json:"url,omitempty" toml:"url" yaml:"url,omitempty"`
	Amount        types.NullDecimal `boil:"amount" json:"amount,omitempty" toml:"amount" yaml:"amount,omitempty"`
	Currency      null.String       `boil:"currency" json:"currency,omitempty" toml:"currency" yaml:"currency,omitempty"`
	FeeAmount     types.NullDecimal `boil:"fee_amount" json:"fee_amount,omitempty" toml:"fee_amount" yaml:"fee_amount,omitempty"`
	FeeCurency    null.String       `boil:"fee_curency" json:"fee_curency,omitempty" toml:"fee_curency" yaml:"fee_curency,omitempty"`
	MakerDate     null.Time         `boil:"maker_date" json:"maker_date,omitempty" toml:"maker_date" yaml:"maker_date,omitempty"`
	CheckerDate   null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID       null.String       `boil:"maker_id" json:"maker_id,omitempty" toml:"maker_id" yaml:"maker_id,omitempty"`
	CheckerID     null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy    null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate  null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *offerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L offerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OfferColumns = struct {
	OfferID       string
	AccountID     string
	OfferType     string
	OfferRefID    string
	Description   string
	StartDateTime string
	EndDateTime   string
	Rate          string
	Value         string
	Term          string
	URL           string
	Amount        string
	Currency      string
	FeeAmount     string
	FeeCurency    string
	MakerDate     string
	CheckerDate   string
	MakerID       string
	CheckerID     string
	ModifiedBy    string
	ModifiedDate  string
}{
	OfferID:       "offer_id",
	AccountID:     "account_id",
	OfferType:     "offer_type",
	OfferRefID:    "offer_ref_id",
	Description:   "description",
	StartDateTime: "start_date_time",
	EndDateTime:   "end_date_time",
	Rate:          "rate",
	Value:         "value",
	Term:          "term",
	URL:           "url",
	Amount:        "amount",
	Currency:      "currency",
	FeeAmount:     "fee_amount",
	FeeCurency:    "fee_curency",
	MakerDate:     "maker_date",
	CheckerDate:   "checker_date",
	MakerID:       "maker_id",
	CheckerID:     "checker_id",
	ModifiedBy:    "modified_by",
	ModifiedDate:  "modified_date",
}

// Generated where

var OfferWhere = struct {
	OfferID       whereHelperint
	AccountID     whereHelperint
	OfferType     whereHelpernull_String
	OfferRefID    whereHelperstring
	Description   whereHelpernull_String
	StartDateTime whereHelpernull_Time
	EndDateTime   whereHelpernull_Time
	Rate          whereHelpernull_String
	Value         whereHelpertypes_NullDecimal
	Term          whereHelpernull_String
	URL           whereHelpernull_String
	Amount        whereHelpertypes_NullDecimal
	Currency      whereHelpernull_String
	FeeAmount     whereHelpertypes_NullDecimal
	FeeCurency    whereHelpernull_String
	MakerDate     whereHelpernull_Time
	CheckerDate   whereHelpernull_Time
	MakerID       whereHelpernull_String
	CheckerID     whereHelpernull_String
	ModifiedBy    whereHelpernull_String
	ModifiedDate  whereHelpernull_Time
}{
	OfferID:       whereHelperint{field: `offer_id`},
	AccountID:     whereHelperint{field: `account_id`},
	OfferType:     whereHelpernull_String{field: `offer_type`},
	OfferRefID:    whereHelperstring{field: `offer_ref_id`},
	Description:   whereHelpernull_String{field: `description`},
	StartDateTime: whereHelpernull_Time{field: `start_date_time`},
	EndDateTime:   whereHelpernull_Time{field: `end_date_time`},
	Rate:          whereHelpernull_String{field: `rate`},
	Value:         whereHelpertypes_NullDecimal{field: `value`},
	Term:          whereHelpernull_String{field: `term`},
	URL:           whereHelpernull_String{field: `url`},
	Amount:        whereHelpertypes_NullDecimal{field: `amount`},
	Currency:      whereHelpernull_String{field: `currency`},
	FeeAmount:     whereHelpertypes_NullDecimal{field: `fee_amount`},
	FeeCurency:    whereHelpernull_String{field: `fee_curency`},
	MakerDate:     whereHelpernull_Time{field: `maker_date`},
	CheckerDate:   whereHelpernull_Time{field: `checker_date`},
	MakerID:       whereHelpernull_String{field: `maker_id`},
	CheckerID:     whereHelpernull_String{field: `checker_id`},
	ModifiedBy:    whereHelpernull_String{field: `modified_by`},
	ModifiedDate:  whereHelpernull_Time{field: `modified_date`},
}

// OfferRels is where relationship names are stored.
var OfferRels = struct {
}{}

// offerR is where relationships are stored.
type offerR struct {
}

// NewStruct creates a new relationship struct
func (*offerR) NewStruct() *offerR {
	return &offerR{}
}

// offerL is where Load methods for each relationship are stored.
type offerL struct{}

var (
	offerColumns               = []string{"offer_id", "account_id", "offer_type", "offer_ref_id", "description", "start_date_time", "end_date_time", "rate", "value", "term", "url", "amount", "currency", "fee_amount", "fee_curency", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	offerColumnsWithoutDefault = []string{"account_id", "offer_type", "offer_ref_id", "description", "start_date_time", "end_date_time", "rate", "value", "term", "url", "amount", "currency", "fee_amount", "fee_curency", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	offerColumnsWithDefault    = []string{"offer_id"}
	offerPrimaryKeyColumns     = []string{"offer_id"}
)

type (
	// OfferSlice is an alias for a slice of pointers to Offer.
	// This should generally be used opposed to []Offer.
	OfferSlice []*Offer
	// OfferHook is the signature for custom Offer hook methods
	OfferHook func(context.Context, boil.ContextExecutor, *Offer) error

	offerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	offerType                 = reflect.TypeOf(&Offer{})
	offerMapping              = queries.MakeStructMapping(offerType)
	offerPrimaryKeyMapping, _ = queries.BindMapping(offerType, offerMapping, offerPrimaryKeyColumns)
	offerInsertCacheMut       sync.RWMutex
	offerInsertCache          = make(map[string]insertCache)
	offerUpdateCacheMut       sync.RWMutex
	offerUpdateCache          = make(map[string]updateCache)
	offerUpsertCacheMut       sync.RWMutex
	offerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var offerBeforeInsertHooks []OfferHook
var offerBeforeUpdateHooks []OfferHook
var offerBeforeDeleteHooks []OfferHook
var offerBeforeUpsertHooks []OfferHook

var offerAfterInsertHooks []OfferHook
var offerAfterSelectHooks []OfferHook
var offerAfterUpdateHooks []OfferHook
var offerAfterDeleteHooks []OfferHook
var offerAfterUpsertHooks []OfferHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Offer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Offer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Offer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Offer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Offer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Offer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Offer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Offer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Offer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range offerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOfferHook registers your hook function for all future operations.
func AddOfferHook(hookPoint boil.HookPoint, offerHook OfferHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		offerBeforeInsertHooks = append(offerBeforeInsertHooks, offerHook)
	case boil.BeforeUpdateHook:
		offerBeforeUpdateHooks = append(offerBeforeUpdateHooks, offerHook)
	case boil.BeforeDeleteHook:
		offerBeforeDeleteHooks = append(offerBeforeDeleteHooks, offerHook)
	case boil.BeforeUpsertHook:
		offerBeforeUpsertHooks = append(offerBeforeUpsertHooks, offerHook)
	case boil.AfterInsertHook:
		offerAfterInsertHooks = append(offerAfterInsertHooks, offerHook)
	case boil.AfterSelectHook:
		offerAfterSelectHooks = append(offerAfterSelectHooks, offerHook)
	case boil.AfterUpdateHook:
		offerAfterUpdateHooks = append(offerAfterUpdateHooks, offerHook)
	case boil.AfterDeleteHook:
		offerAfterDeleteHooks = append(offerAfterDeleteHooks, offerHook)
	case boil.AfterUpsertHook:
		offerAfterUpsertHooks = append(offerAfterUpsertHooks, offerHook)
	}
}

// One returns a single offer record from the query.
func (q offerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Offer, error) {
	o := &Offer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Offer")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Offer records from the query.
func (q offerQuery) All(ctx context.Context, exec boil.ContextExecutor) (OfferSlice, error) {
	var o []*Offer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Offer slice")
	}

	if len(offerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Offer records in the query.
func (q offerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Offer rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q offerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Offer exists")
	}

	return count > 0, nil
}

// Offers retrieves all the records using an executor.
func Offers(mods ...qm.QueryMod) offerQuery {
	mods = append(mods, qm.From("`Offer`"))
	return offerQuery{NewQuery(mods...)}
}

// FindOffer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOffer(ctx context.Context, exec boil.ContextExecutor, offerID int, selectCols ...string) (*Offer, error) {
	offerObj := &Offer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Offer` where `offer_id`=?", sel,
	)

	q := queries.Raw(query, offerID)

	err := q.Bind(ctx, exec, offerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Offer")
	}

	return offerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Offer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Offer provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(offerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	offerInsertCacheMut.RLock()
	cache, cached := offerInsertCache[key]
	offerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			offerColumns,
			offerColumnsWithDefault,
			offerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(offerType, offerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(offerType, offerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Offer` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Offer` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Offer` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, offerPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Offer")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.OfferID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == offerMapping["OfferID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.OfferID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Offer")
	}

CacheNoHooks:
	if !cached {
		offerInsertCacheMut.Lock()
		offerInsertCache[key] = cache
		offerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Offer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Offer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	offerUpdateCacheMut.RLock()
	cache, cached := offerUpdateCache[key]
	offerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			offerColumns,
			offerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Offer, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Offer` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, offerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(offerType, offerMapping, append(wl, offerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Offer row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Offer")
	}

	if !cached {
		offerUpdateCacheMut.Lock()
		offerUpdateCache[key] = cache
		offerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q offerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Offer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Offer")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OfferSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), offerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Offer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, offerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in offer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all offer")
	}
	return rowsAff, nil
}

var mySQLOfferUniqueColumns = []string{
	"offer_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Offer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Offer provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(offerColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLOfferUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	offerUpsertCacheMut.RLock()
	cache, cached := offerUpsertCache[key]
	offerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			offerColumns,
			offerColumnsWithDefault,
			offerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			offerColumns,
			offerPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Offer, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Offer", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Offer` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(offerType, offerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(offerType, offerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Offer")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.OfferID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == offerMapping["offer_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(offerType, offerMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Offer")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Offer")
	}

CacheNoHooks:
	if !cached {
		offerUpsertCacheMut.Lock()
		offerUpsertCache[key] = cache
		offerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Offer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Offer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Offer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), offerPrimaryKeyMapping)
	sql := "DELETE FROM `Offer` WHERE `offer_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Offer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Offer")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q offerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no offerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Offer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Offer")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OfferSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Offer slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(offerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), offerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Offer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, offerPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from offer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Offer")
	}

	if len(offerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Offer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOffer(ctx, exec, o.OfferID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OfferSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OfferSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), offerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Offer`.* FROM `Offer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, offerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OfferSlice")
	}

	*o = slice

	return nil
}

// OfferExists checks if the Offer row exists.
func OfferExists(ctx context.Context, exec boil.ContextExecutor, offerID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Offer` where `offer_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, offerID)
	}

	row := exec.QueryRowContext(ctx, sql, offerID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Offer exists")
	}

	return exists, nil
}
