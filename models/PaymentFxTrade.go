// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// PaymentFxTrade is an object representing the database table.
type PaymentFxTrade struct {
	PaymentFXTradeID    int           `boil:"payment_fx_trade_id" json:"payment_fx_trade_id" toml:"payment_fx_trade_id" yaml:"payment_fx_trade_id"`
	PaymentID           int           `boil:"payment_id" json:"payment_id" toml:"payment_id" yaml:"payment_id"`
	TraderPartyID       int           `boil:"trader_party_id" json:"trader_party_id" toml:"trader_party_id" yaml:"trader_party_id"`
	ValueDate           time.Time     `boil:"value_date" json:"value_date" toml:"value_date" yaml:"value_date"`
	SourceCurrency      string        `boil:"source_currency" json:"source_currency" toml:"source_currency" yaml:"source_currency"`
	DestinationCurrency string        `boil:"destination_currency" json:"destination_currency" toml:"destination_currency" yaml:"destination_currency"`
	Status              null.String   `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	ProductID           null.Int      `boil:"product_id" json:"product_id,omitempty" toml:"product_id" yaml:"product_id,omitempty"`
	BankID              int           `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	SystemName          null.String   `boil:"system_name" json:"system_name,omitempty" toml:"system_name" yaml:"system_name,omitempty"`
	ExchangeRate        types.Decimal `boil:"exchange_rate" json:"exchange_rate" toml:"exchange_rate" yaml:"exchange_rate"`
	SourceAmount        types.Decimal `boil:"source_amount" json:"source_amount" toml:"source_amount" yaml:"source_amount"`
	DestinationAmount   types.Decimal `boil:"destination_amount" json:"destination_amount" toml:"destination_amount" yaml:"destination_amount"`
	TransactionDate     time.Time     `boil:"transaction_date" json:"transaction_date" toml:"transaction_date" yaml:"transaction_date"`
	CtpyDealCode        null.String   `boil:"ctpy_Deal_Code" json:"ctpy_Deal_Code,omitempty" toml:"ctpy_Deal_Code" yaml:"ctpy_Deal_Code,omitempty"`
	CtpyFirmName        null.String   `boil:"ctpy_firm_name" json:"ctpy_firm_name,omitempty" toml:"ctpy_firm_name" yaml:"ctpy_firm_name,omitempty"`
	Role                null.String   `boil:"role" json:"role,omitempty" toml:"role" yaml:"role,omitempty"`
	Ccys                null.String   `boil:"ccys" json:"ccys,omitempty" toml:"ccys" yaml:"ccys,omitempty"`
	DealType            null.String   `boil:"deal_type" json:"deal_type,omitempty" toml:"deal_type" yaml:"deal_type,omitempty"`
	Side                null.String   `boil:"side" json:"side,omitempty" toml:"side" yaml:"side,omitempty"`
	Tenor               null.String   `boil:"tenor" json:"tenor,omitempty" toml:"tenor" yaml:"tenor,omitempty"`
	MakerDate           time.Time     `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate         null.Time     `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID             string        `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID           null.String   `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy          null.String   `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate        null.Time     `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *paymentFxTradeR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L paymentFxTradeL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PaymentFxTradeColumns = struct {
	PaymentFXTradeID    string
	PaymentID           string
	TraderPartyID       string
	ValueDate           string
	SourceCurrency      string
	DestinationCurrency string
	Status              string
	ProductID           string
	BankID              string
	SystemName          string
	ExchangeRate        string
	SourceAmount        string
	DestinationAmount   string
	TransactionDate     string
	CtpyDealCode        string
	CtpyFirmName        string
	Role                string
	Ccys                string
	DealType            string
	Side                string
	Tenor               string
	MakerDate           string
	CheckerDate         string
	MakerID             string
	CheckerID           string
	ModifiedBy          string
	ModifiedDate        string
}{
	PaymentFXTradeID:    "payment_fx_trade_id",
	PaymentID:           "payment_id",
	TraderPartyID:       "trader_party_id",
	ValueDate:           "value_date",
	SourceCurrency:      "source_currency",
	DestinationCurrency: "destination_currency",
	Status:              "status",
	ProductID:           "product_id",
	BankID:              "bank_id",
	SystemName:          "system_name",
	ExchangeRate:        "exchange_rate",
	SourceAmount:        "source_amount",
	DestinationAmount:   "destination_amount",
	TransactionDate:     "transaction_date",
	CtpyDealCode:        "ctpy_Deal_Code",
	CtpyFirmName:        "ctpy_firm_name",
	Role:                "role",
	Ccys:                "ccys",
	DealType:            "deal_type",
	Side:                "side",
	Tenor:               "tenor",
	MakerDate:           "maker_date",
	CheckerDate:         "checker_date",
	MakerID:             "maker_id",
	CheckerID:           "checker_id",
	ModifiedBy:          "modified_by",
	ModifiedDate:        "modified_date",
}

// Generated where

var PaymentFxTradeWhere = struct {
	PaymentFXTradeID    whereHelperint
	PaymentID           whereHelperint
	TraderPartyID       whereHelperint
	ValueDate           whereHelpertime_Time
	SourceCurrency      whereHelperstring
	DestinationCurrency whereHelperstring
	Status              whereHelpernull_String
	ProductID           whereHelpernull_Int
	BankID              whereHelperint
	SystemName          whereHelpernull_String
	ExchangeRate        whereHelpertypes_Decimal
	SourceAmount        whereHelpertypes_Decimal
	DestinationAmount   whereHelpertypes_Decimal
	TransactionDate     whereHelpertime_Time
	CtpyDealCode        whereHelpernull_String
	CtpyFirmName        whereHelpernull_String
	Role                whereHelpernull_String
	Ccys                whereHelpernull_String
	DealType            whereHelpernull_String
	Side                whereHelpernull_String
	Tenor               whereHelpernull_String
	MakerDate           whereHelpertime_Time
	CheckerDate         whereHelpernull_Time
	MakerID             whereHelperstring
	CheckerID           whereHelpernull_String
	ModifiedBy          whereHelpernull_String
	ModifiedDate        whereHelpernull_Time
}{
	PaymentFXTradeID:    whereHelperint{field: `payment_fx_trade_id`},
	PaymentID:           whereHelperint{field: `payment_id`},
	TraderPartyID:       whereHelperint{field: `trader_party_id`},
	ValueDate:           whereHelpertime_Time{field: `value_date`},
	SourceCurrency:      whereHelperstring{field: `source_currency`},
	DestinationCurrency: whereHelperstring{field: `destination_currency`},
	Status:              whereHelpernull_String{field: `status`},
	ProductID:           whereHelpernull_Int{field: `product_id`},
	BankID:              whereHelperint{field: `bank_id`},
	SystemName:          whereHelpernull_String{field: `system_name`},
	ExchangeRate:        whereHelpertypes_Decimal{field: `exchange_rate`},
	SourceAmount:        whereHelpertypes_Decimal{field: `source_amount`},
	DestinationAmount:   whereHelpertypes_Decimal{field: `destination_amount`},
	TransactionDate:     whereHelpertime_Time{field: `transaction_date`},
	CtpyDealCode:        whereHelpernull_String{field: `ctpy_Deal_Code`},
	CtpyFirmName:        whereHelpernull_String{field: `ctpy_firm_name`},
	Role:                whereHelpernull_String{field: `role`},
	Ccys:                whereHelpernull_String{field: `ccys`},
	DealType:            whereHelpernull_String{field: `deal_type`},
	Side:                whereHelpernull_String{field: `side`},
	Tenor:               whereHelpernull_String{field: `tenor`},
	MakerDate:           whereHelpertime_Time{field: `maker_date`},
	CheckerDate:         whereHelpernull_Time{field: `checker_date`},
	MakerID:             whereHelperstring{field: `maker_id`},
	CheckerID:           whereHelpernull_String{field: `checker_id`},
	ModifiedBy:          whereHelpernull_String{field: `modified_by`},
	ModifiedDate:        whereHelpernull_Time{field: `modified_date`},
}

// PaymentFxTradeRels is where relationship names are stored.
var PaymentFxTradeRels = struct {
	Payment     string
	TraderParty string
	Bank        string
}{
	Payment:     "Payment",
	TraderParty: "TraderParty",
	Bank:        "Bank",
}

// paymentFxTradeR is where relationships are stored.
type paymentFxTradeR struct {
	Payment     *PaymentInitiation
	TraderParty *Party
	Bank        *Bank
}

// NewStruct creates a new relationship struct
func (*paymentFxTradeR) NewStruct() *paymentFxTradeR {
	return &paymentFxTradeR{}
}

// paymentFxTradeL is where Load methods for each relationship are stored.
type paymentFxTradeL struct{}

var (
	paymentFxTradeColumns               = []string{"payment_fx_trade_id", "payment_id", "trader_party_id", "value_date", "source_currency", "destination_currency", "status", "product_id", "bank_id", "system_name", "exchange_rate", "source_amount", "destination_amount", "transaction_date", "ctpy_Deal_Code", "ctpy_firm_name", "role", "ccys", "deal_type", "side", "tenor", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentFxTradeColumnsWithoutDefault = []string{"payment_id", "trader_party_id", "value_date", "source_currency", "destination_currency", "status", "product_id", "bank_id", "system_name", "exchange_rate", "source_amount", "destination_amount", "transaction_date", "ctpy_Deal_Code", "ctpy_firm_name", "role", "ccys", "deal_type", "side", "tenor", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentFxTradeColumnsWithDefault    = []string{"payment_fx_trade_id"}
	paymentFxTradePrimaryKeyColumns     = []string{"payment_fx_trade_id"}
)

type (
	// PaymentFxTradeSlice is an alias for a slice of pointers to PaymentFxTrade.
	// This should generally be used opposed to []PaymentFxTrade.
	PaymentFxTradeSlice []*PaymentFxTrade
	// PaymentFxTradeHook is the signature for custom PaymentFxTrade hook methods
	PaymentFxTradeHook func(context.Context, boil.ContextExecutor, *PaymentFxTrade) error

	paymentFxTradeQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	paymentFxTradeType                 = reflect.TypeOf(&PaymentFxTrade{})
	paymentFxTradeMapping              = queries.MakeStructMapping(paymentFxTradeType)
	paymentFxTradePrimaryKeyMapping, _ = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, paymentFxTradePrimaryKeyColumns)
	paymentFxTradeInsertCacheMut       sync.RWMutex
	paymentFxTradeInsertCache          = make(map[string]insertCache)
	paymentFxTradeUpdateCacheMut       sync.RWMutex
	paymentFxTradeUpdateCache          = make(map[string]updateCache)
	paymentFxTradeUpsertCacheMut       sync.RWMutex
	paymentFxTradeUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var paymentFxTradeBeforeInsertHooks []PaymentFxTradeHook
var paymentFxTradeBeforeUpdateHooks []PaymentFxTradeHook
var paymentFxTradeBeforeDeleteHooks []PaymentFxTradeHook
var paymentFxTradeBeforeUpsertHooks []PaymentFxTradeHook

var paymentFxTradeAfterInsertHooks []PaymentFxTradeHook
var paymentFxTradeAfterSelectHooks []PaymentFxTradeHook
var paymentFxTradeAfterUpdateHooks []PaymentFxTradeHook
var paymentFxTradeAfterDeleteHooks []PaymentFxTradeHook
var paymentFxTradeAfterUpsertHooks []PaymentFxTradeHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PaymentFxTrade) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PaymentFxTrade) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PaymentFxTrade) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PaymentFxTrade) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PaymentFxTrade) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PaymentFxTrade) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PaymentFxTrade) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PaymentFxTrade) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PaymentFxTrade) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentFxTradeAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPaymentFxTradeHook registers your hook function for all future operations.
func AddPaymentFxTradeHook(hookPoint boil.HookPoint, paymentFxTradeHook PaymentFxTradeHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		paymentFxTradeBeforeInsertHooks = append(paymentFxTradeBeforeInsertHooks, paymentFxTradeHook)
	case boil.BeforeUpdateHook:
		paymentFxTradeBeforeUpdateHooks = append(paymentFxTradeBeforeUpdateHooks, paymentFxTradeHook)
	case boil.BeforeDeleteHook:
		paymentFxTradeBeforeDeleteHooks = append(paymentFxTradeBeforeDeleteHooks, paymentFxTradeHook)
	case boil.BeforeUpsertHook:
		paymentFxTradeBeforeUpsertHooks = append(paymentFxTradeBeforeUpsertHooks, paymentFxTradeHook)
	case boil.AfterInsertHook:
		paymentFxTradeAfterInsertHooks = append(paymentFxTradeAfterInsertHooks, paymentFxTradeHook)
	case boil.AfterSelectHook:
		paymentFxTradeAfterSelectHooks = append(paymentFxTradeAfterSelectHooks, paymentFxTradeHook)
	case boil.AfterUpdateHook:
		paymentFxTradeAfterUpdateHooks = append(paymentFxTradeAfterUpdateHooks, paymentFxTradeHook)
	case boil.AfterDeleteHook:
		paymentFxTradeAfterDeleteHooks = append(paymentFxTradeAfterDeleteHooks, paymentFxTradeHook)
	case boil.AfterUpsertHook:
		paymentFxTradeAfterUpsertHooks = append(paymentFxTradeAfterUpsertHooks, paymentFxTradeHook)
	}
}

// One returns a single paymentFxTrade record from the query.
func (q paymentFxTradeQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PaymentFxTrade, error) {
	o := &PaymentFxTrade{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for PaymentFxTrade")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PaymentFxTrade records from the query.
func (q paymentFxTradeQuery) All(ctx context.Context, exec boil.ContextExecutor) (PaymentFxTradeSlice, error) {
	var o []*PaymentFxTrade

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to PaymentFxTrade slice")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PaymentFxTrade records in the query.
func (q paymentFxTradeQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count PaymentFxTrade rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q paymentFxTradeQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if PaymentFxTrade exists")
	}

	return count > 0, nil
}

// Payment pointed to by the foreign key.
func (o *PaymentFxTrade) Payment(mods ...qm.QueryMod) paymentInitiationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentInitiations(queryMods...)
	queries.SetFrom(query.Query, "`PaymentInitiation`")

	return query
}

// TraderParty pointed to by the foreign key.
func (o *PaymentFxTrade) TraderParty(mods ...qm.QueryMod) partyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.TraderPartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	return query
}

// Bank pointed to by the foreign key.
func (o *PaymentFxTrade) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// LoadPayment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (paymentFxTradeL) LoadPayment(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentFxTrade interface{}, mods queries.Applicator) error {
	var slice []*PaymentFxTrade
	var object *PaymentFxTrade

	if singular {
		object = maybePaymentFxTrade.(*PaymentFxTrade)
	} else {
		slice = *maybePaymentFxTrade.(*[]*PaymentFxTrade)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentFxTradeR{}
		}
		args = append(args, object.PaymentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentFxTradeR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentInitiation`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentInitiation")
	}

	var resultSlice []*PaymentInitiation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentInitiation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for PaymentInitiation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentInitiation")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Payment = foreign
		if foreign.R == nil {
			foreign.R = &paymentInitiationR{}
		}
		foreign.R.PaymentPaymentFxTrades = append(foreign.R.PaymentPaymentFxTrades, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentID == foreign.PaymentID {
				local.R.Payment = foreign
				if foreign.R == nil {
					foreign.R = &paymentInitiationR{}
				}
				foreign.R.PaymentPaymentFxTrades = append(foreign.R.PaymentPaymentFxTrades, local)
				break
			}
		}
	}

	return nil
}

// LoadTraderParty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (paymentFxTradeL) LoadTraderParty(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentFxTrade interface{}, mods queries.Applicator) error {
	var slice []*PaymentFxTrade
	var object *PaymentFxTrade

	if singular {
		object = maybePaymentFxTrade.(*PaymentFxTrade)
	} else {
		slice = *maybePaymentFxTrade.(*[]*PaymentFxTrade)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentFxTradeR{}
		}
		args = append(args, object.TraderPartyID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentFxTradeR{}
			}

			for _, a := range args {
				if a == obj.TraderPartyID {
					continue Outer
				}
			}

			args = append(args, obj.TraderPartyID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Party")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Party")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TraderParty = foreign
		if foreign.R == nil {
			foreign.R = &partyR{}
		}
		foreign.R.TraderPartyPaymentFxTrades = append(foreign.R.TraderPartyPaymentFxTrades, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TraderPartyID == foreign.PartyID {
				local.R.TraderParty = foreign
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.TraderPartyPaymentFxTrades = append(foreign.R.TraderPartyPaymentFxTrades, local)
				break
			}
		}
	}

	return nil
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (paymentFxTradeL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentFxTrade interface{}, mods queries.Applicator) error {
	var slice []*PaymentFxTrade
	var object *PaymentFxTrade

	if singular {
		object = maybePaymentFxTrade.(*PaymentFxTrade)
	} else {
		slice = *maybePaymentFxTrade.(*[]*PaymentFxTrade)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentFxTradeR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentFxTradeR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankPaymentFxTrades = append(foreign.R.BankPaymentFxTrades, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankPaymentFxTrades = append(foreign.R.BankPaymentFxTrades, local)
				break
			}
		}
	}

	return nil
}

// SetPayment of the paymentFxTrade to the related item.
// Sets o.R.Payment to related.
// Adds o to related.R.PaymentPaymentFxTrades.
func (o *PaymentFxTrade) SetPayment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentInitiation) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `PaymentFxTrade` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
		strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
	)
	values := []interface{}{related.PaymentID, o.PaymentFXTradeID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PaymentID = related.PaymentID
	if o.R == nil {
		o.R = &paymentFxTradeR{
			Payment: related,
		}
	} else {
		o.R.Payment = related
	}

	if related.R == nil {
		related.R = &paymentInitiationR{
			PaymentPaymentFxTrades: PaymentFxTradeSlice{o},
		}
	} else {
		related.R.PaymentPaymentFxTrades = append(related.R.PaymentPaymentFxTrades, o)
	}

	return nil
}

// SetTraderParty of the paymentFxTrade to the related item.
// Sets o.R.TraderParty to related.
// Adds o to related.R.TraderPartyPaymentFxTrades.
func (o *PaymentFxTrade) SetTraderParty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Party) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `PaymentFxTrade` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"trader_party_id"}),
		strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
	)
	values := []interface{}{related.PartyID, o.PaymentFXTradeID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TraderPartyID = related.PartyID
	if o.R == nil {
		o.R = &paymentFxTradeR{
			TraderParty: related,
		}
	} else {
		o.R.TraderParty = related
	}

	if related.R == nil {
		related.R = &partyR{
			TraderPartyPaymentFxTrades: PaymentFxTradeSlice{o},
		}
	} else {
		related.R.TraderPartyPaymentFxTrades = append(related.R.TraderPartyPaymentFxTrades, o)
	}

	return nil
}

// SetBank of the paymentFxTrade to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankPaymentFxTrades.
func (o *PaymentFxTrade) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `PaymentFxTrade` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.PaymentFXTradeID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &paymentFxTradeR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankPaymentFxTrades: PaymentFxTradeSlice{o},
		}
	} else {
		related.R.BankPaymentFxTrades = append(related.R.BankPaymentFxTrades, o)
	}

	return nil
}

// PaymentFxTrades retrieves all the records using an executor.
func PaymentFxTrades(mods ...qm.QueryMod) paymentFxTradeQuery {
	mods = append(mods, qm.From("`PaymentFxTrade`"))
	return paymentFxTradeQuery{NewQuery(mods...)}
}

// FindPaymentFxTrade retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPaymentFxTrade(ctx context.Context, exec boil.ContextExecutor, paymentFXTradeID int, selectCols ...string) (*PaymentFxTrade, error) {
	paymentFxTradeObj := &PaymentFxTrade{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `PaymentFxTrade` where `payment_fx_trade_id`=?", sel,
	)

	q := queries.Raw(query, paymentFXTradeID)

	err := q.Bind(ctx, exec, paymentFxTradeObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from PaymentFxTrade")
	}

	return paymentFxTradeObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PaymentFxTrade) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PaymentFxTrade provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentFxTradeColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	paymentFxTradeInsertCacheMut.RLock()
	cache, cached := paymentFxTradeInsertCache[key]
	paymentFxTradeInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			paymentFxTradeColumns,
			paymentFxTradeColumnsWithDefault,
			paymentFxTradeColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `PaymentFxTrade` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `PaymentFxTrade` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `PaymentFxTrade` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into PaymentFxTrade")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentFXTradeID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentFxTradeMapping["PaymentFXTradeID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PaymentFXTradeID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PaymentFxTrade")
	}

CacheNoHooks:
	if !cached {
		paymentFxTradeInsertCacheMut.Lock()
		paymentFxTradeInsertCache[key] = cache
		paymentFxTradeInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the PaymentFxTrade.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PaymentFxTrade) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	paymentFxTradeUpdateCacheMut.RLock()
	cache, cached := paymentFxTradeUpdateCache[key]
	paymentFxTradeUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			paymentFxTradeColumns,
			paymentFxTradePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update PaymentFxTrade, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `PaymentFxTrade` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, append(wl, paymentFxTradePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update PaymentFxTrade row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for PaymentFxTrade")
	}

	if !cached {
		paymentFxTradeUpdateCacheMut.Lock()
		paymentFxTradeUpdateCache[key] = cache
		paymentFxTradeUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q paymentFxTradeQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for PaymentFxTrade")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for PaymentFxTrade")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PaymentFxTradeSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentFxTradePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `PaymentFxTrade` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentFxTradePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in paymentFxTrade slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all paymentFxTrade")
	}
	return rowsAff, nil
}

var mySQLPaymentFxTradeUniqueColumns = []string{
	"payment_fx_trade_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PaymentFxTrade) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PaymentFxTrade provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentFxTradeColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPaymentFxTradeUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	paymentFxTradeUpsertCacheMut.RLock()
	cache, cached := paymentFxTradeUpsertCache[key]
	paymentFxTradeUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			paymentFxTradeColumns,
			paymentFxTradeColumnsWithDefault,
			paymentFxTradeColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			paymentFxTradeColumns,
			paymentFxTradePrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert PaymentFxTrade, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "PaymentFxTrade", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `PaymentFxTrade` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for PaymentFxTrade")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentFXTradeID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentFxTradeMapping["payment_fx_trade_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(paymentFxTradeType, paymentFxTradeMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for PaymentFxTrade")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PaymentFxTrade")
	}

CacheNoHooks:
	if !cached {
		paymentFxTradeUpsertCacheMut.Lock()
		paymentFxTradeUpsertCache[key] = cache
		paymentFxTradeUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single PaymentFxTrade record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PaymentFxTrade) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PaymentFxTrade provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), paymentFxTradePrimaryKeyMapping)
	sql := "DELETE FROM `PaymentFxTrade` WHERE `payment_fx_trade_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from PaymentFxTrade")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for PaymentFxTrade")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q paymentFxTradeQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no paymentFxTradeQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from PaymentFxTrade")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PaymentFxTrade")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PaymentFxTradeSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PaymentFxTrade slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(paymentFxTradeBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentFxTradePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `PaymentFxTrade` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentFxTradePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from paymentFxTrade slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PaymentFxTrade")
	}

	if len(paymentFxTradeAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PaymentFxTrade) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPaymentFxTrade(ctx, exec, o.PaymentFXTradeID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PaymentFxTradeSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PaymentFxTradeSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentFxTradePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `PaymentFxTrade`.* FROM `PaymentFxTrade` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentFxTradePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PaymentFxTradeSlice")
	}

	*o = slice

	return nil
}

// PaymentFxTradeExists checks if the PaymentFxTrade row exists.
func PaymentFxTradeExists(ctx context.Context, exec boil.ContextExecutor, paymentFXTradeID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `PaymentFxTrade` where `payment_fx_trade_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, paymentFXTradeID)
	}

	row := exec.QueryRowContext(ctx, sql, paymentFXTradeID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if PaymentFxTrade exists")
	}

	return exists, nil
}
