// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// PaymentInitiation is an object representing the database table.
type PaymentInitiation struct {
	PaymentID          int         `boil:"payment_id" json:"payment_id" toml:"payment_id" yaml:"payment_id"`
	PaymentType        null.String `boil:"payment_type" json:"payment_type,omitempty" toml:"payment_type" yaml:"payment_type,omitempty"`
	InitiationDateTime null.Time   `boil:"initiation_date_time" json:"initiation_date_time,omitempty" toml:"initiation_date_time" yaml:"initiation_date_time,omitempty"`
	Status             null.String `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	MakerDate          null.Time   `boil:"maker_date" json:"maker_date,omitempty" toml:"maker_date" yaml:"maker_date,omitempty"`
	CheckerDate        null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID            null.String `boil:"maker_id" json:"maker_id,omitempty" toml:"maker_id" yaml:"maker_id,omitempty"`
	CheckerID          null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy         null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate       null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *paymentInitiationR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L paymentInitiationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PaymentInitiationColumns = struct {
	PaymentID          string
	PaymentType        string
	InitiationDateTime string
	Status             string
	MakerDate          string
	CheckerDate        string
	MakerID            string
	CheckerID          string
	ModifiedBy         string
	ModifiedDate       string
}{
	PaymentID:          "payment_id",
	PaymentType:        "payment_type",
	InitiationDateTime: "initiation_date_time",
	Status:             "status",
	MakerDate:          "maker_date",
	CheckerDate:        "checker_date",
	MakerID:            "maker_id",
	CheckerID:          "checker_id",
	ModifiedBy:         "modified_by",
	ModifiedDate:       "modified_date",
}

// Generated where

var PaymentInitiationWhere = struct {
	PaymentID          whereHelperint
	PaymentType        whereHelpernull_String
	InitiationDateTime whereHelpernull_Time
	Status             whereHelpernull_String
	MakerDate          whereHelpernull_Time
	CheckerDate        whereHelpernull_Time
	MakerID            whereHelpernull_String
	CheckerID          whereHelpernull_String
	ModifiedBy         whereHelpernull_String
	ModifiedDate       whereHelpernull_Time
}{
	PaymentID:          whereHelperint{field: `payment_id`},
	PaymentType:        whereHelpernull_String{field: `payment_type`},
	InitiationDateTime: whereHelpernull_Time{field: `initiation_date_time`},
	Status:             whereHelpernull_String{field: `status`},
	MakerDate:          whereHelpernull_Time{field: `maker_date`},
	CheckerDate:        whereHelpernull_Time{field: `checker_date`},
	MakerID:            whereHelpernull_String{field: `maker_id`},
	CheckerID:          whereHelpernull_String{field: `checker_id`},
	ModifiedBy:         whereHelpernull_String{field: `modified_by`},
	ModifiedDate:       whereHelpernull_Time{field: `modified_date`},
}

// PaymentInitiationRels is where relationship names are stored.
var PaymentInitiationRels = struct {
	PaymentFilePayment        string
	PaymentFxPayment          string
	PaymentPaymentCharge      string
	PaymentOBPPaymentConsents string
	PaymentPaymentAches       string
	PaymentPaymentBills       string
	PaymentPaymentCheques     string
	PaymentPaymentFxTrades    string
	PaymentPaymentLoans       string
	PaymentPaymentMessages    string
	PaymentPaymentRtps        string
	PaymentPaymentWires       string
}{
	PaymentFilePayment:        "PaymentFilePayment",
	PaymentFxPayment:          "PaymentFxPayment",
	PaymentPaymentCharge:      "PaymentPaymentCharge",
	PaymentOBPPaymentConsents: "PaymentOBPPaymentConsents",
	PaymentPaymentAches:       "PaymentPaymentAches",
	PaymentPaymentBills:       "PaymentPaymentBills",
	PaymentPaymentCheques:     "PaymentPaymentCheques",
	PaymentPaymentFxTrades:    "PaymentPaymentFxTrades",
	PaymentPaymentLoans:       "PaymentPaymentLoans",
	PaymentPaymentMessages:    "PaymentPaymentMessages",
	PaymentPaymentRtps:        "PaymentPaymentRtps",
	PaymentPaymentWires:       "PaymentPaymentWires",
}

// paymentInitiationR is where relationships are stored.
type paymentInitiationR struct {
	PaymentFilePayment        *FilePayment
	PaymentFxPayment          *FxPayment
	PaymentPaymentCharge      *PaymentCharge
	PaymentOBPPaymentConsents OBPPaymentConsentSlice
	PaymentPaymentAches       PaymentAchSlice
	PaymentPaymentBills       PaymentBillSlice
	PaymentPaymentCheques     PaymentChequeSlice
	PaymentPaymentFxTrades    PaymentFxTradeSlice
	PaymentPaymentLoans       PaymentLoanSlice
	PaymentPaymentMessages    PaymentMessageSlice
	PaymentPaymentRtps        PaymentRtpSlice
	PaymentPaymentWires       PaymentWireSlice
}

// NewStruct creates a new relationship struct
func (*paymentInitiationR) NewStruct() *paymentInitiationR {
	return &paymentInitiationR{}
}

// paymentInitiationL is where Load methods for each relationship are stored.
type paymentInitiationL struct{}

var (
	paymentInitiationColumns               = []string{"payment_id", "payment_type", "initiation_date_time", "status", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentInitiationColumnsWithoutDefault = []string{"payment_type", "initiation_date_time", "status", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	paymentInitiationColumnsWithDefault    = []string{"payment_id"}
	paymentInitiationPrimaryKeyColumns     = []string{"payment_id"}
)

type (
	// PaymentInitiationSlice is an alias for a slice of pointers to PaymentInitiation.
	// This should generally be used opposed to []PaymentInitiation.
	PaymentInitiationSlice []*PaymentInitiation
	// PaymentInitiationHook is the signature for custom PaymentInitiation hook methods
	PaymentInitiationHook func(context.Context, boil.ContextExecutor, *PaymentInitiation) error

	paymentInitiationQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	paymentInitiationType                 = reflect.TypeOf(&PaymentInitiation{})
	paymentInitiationMapping              = queries.MakeStructMapping(paymentInitiationType)
	paymentInitiationPrimaryKeyMapping, _ = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, paymentInitiationPrimaryKeyColumns)
	paymentInitiationInsertCacheMut       sync.RWMutex
	paymentInitiationInsertCache          = make(map[string]insertCache)
	paymentInitiationUpdateCacheMut       sync.RWMutex
	paymentInitiationUpdateCache          = make(map[string]updateCache)
	paymentInitiationUpsertCacheMut       sync.RWMutex
	paymentInitiationUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var paymentInitiationBeforeInsertHooks []PaymentInitiationHook
var paymentInitiationBeforeUpdateHooks []PaymentInitiationHook
var paymentInitiationBeforeDeleteHooks []PaymentInitiationHook
var paymentInitiationBeforeUpsertHooks []PaymentInitiationHook

var paymentInitiationAfterInsertHooks []PaymentInitiationHook
var paymentInitiationAfterSelectHooks []PaymentInitiationHook
var paymentInitiationAfterUpdateHooks []PaymentInitiationHook
var paymentInitiationAfterDeleteHooks []PaymentInitiationHook
var paymentInitiationAfterUpsertHooks []PaymentInitiationHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PaymentInitiation) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PaymentInitiation) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PaymentInitiation) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PaymentInitiation) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PaymentInitiation) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PaymentInitiation) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PaymentInitiation) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PaymentInitiation) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PaymentInitiation) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range paymentInitiationAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPaymentInitiationHook registers your hook function for all future operations.
func AddPaymentInitiationHook(hookPoint boil.HookPoint, paymentInitiationHook PaymentInitiationHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		paymentInitiationBeforeInsertHooks = append(paymentInitiationBeforeInsertHooks, paymentInitiationHook)
	case boil.BeforeUpdateHook:
		paymentInitiationBeforeUpdateHooks = append(paymentInitiationBeforeUpdateHooks, paymentInitiationHook)
	case boil.BeforeDeleteHook:
		paymentInitiationBeforeDeleteHooks = append(paymentInitiationBeforeDeleteHooks, paymentInitiationHook)
	case boil.BeforeUpsertHook:
		paymentInitiationBeforeUpsertHooks = append(paymentInitiationBeforeUpsertHooks, paymentInitiationHook)
	case boil.AfterInsertHook:
		paymentInitiationAfterInsertHooks = append(paymentInitiationAfterInsertHooks, paymentInitiationHook)
	case boil.AfterSelectHook:
		paymentInitiationAfterSelectHooks = append(paymentInitiationAfterSelectHooks, paymentInitiationHook)
	case boil.AfterUpdateHook:
		paymentInitiationAfterUpdateHooks = append(paymentInitiationAfterUpdateHooks, paymentInitiationHook)
	case boil.AfterDeleteHook:
		paymentInitiationAfterDeleteHooks = append(paymentInitiationAfterDeleteHooks, paymentInitiationHook)
	case boil.AfterUpsertHook:
		paymentInitiationAfterUpsertHooks = append(paymentInitiationAfterUpsertHooks, paymentInitiationHook)
	}
}

// One returns a single paymentInitiation record from the query.
func (q paymentInitiationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PaymentInitiation, error) {
	o := &PaymentInitiation{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for PaymentInitiation")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PaymentInitiation records from the query.
func (q paymentInitiationQuery) All(ctx context.Context, exec boil.ContextExecutor) (PaymentInitiationSlice, error) {
	var o []*PaymentInitiation

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to PaymentInitiation slice")
	}

	if len(paymentInitiationAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PaymentInitiation records in the query.
func (q paymentInitiationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count PaymentInitiation rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q paymentInitiationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if PaymentInitiation exists")
	}

	return count > 0, nil
}

// PaymentFilePayment pointed to by the foreign key.
func (o *PaymentInitiation) PaymentFilePayment(mods ...qm.QueryMod) filePaymentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := FilePayments(queryMods...)
	queries.SetFrom(query.Query, "`FilePayment`")

	return query
}

// PaymentFxPayment pointed to by the foreign key.
func (o *PaymentInitiation) PaymentFxPayment(mods ...qm.QueryMod) fxPaymentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := FxPayments(queryMods...)
	queries.SetFrom(query.Query, "`FxPayment`")

	return query
}

// PaymentPaymentCharge pointed to by the foreign key.
func (o *PaymentInitiation) PaymentPaymentCharge(mods ...qm.QueryMod) paymentChargeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentCharges(queryMods...)
	queries.SetFrom(query.Query, "`PaymentCharges`")

	return query
}

// PaymentOBPPaymentConsents retrieves all the OBPPaymentConsent's OBPPaymentConsents with an executor via payment_id column.
func (o *PaymentInitiation) PaymentOBPPaymentConsents(mods ...qm.QueryMod) oBPPaymentConsentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`OBPPaymentConsent`.`payment_id`=?", o.PaymentID),
	)

	query := OBPPaymentConsents(queryMods...)
	queries.SetFrom(query.Query, "`OBPPaymentConsent`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`OBPPaymentConsent`.*"})
	}

	return query
}

// PaymentPaymentAches retrieves all the PaymentAch's PaymentAches with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentAches(mods ...qm.QueryMod) paymentAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentAch`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentAches(queryMods...)
	queries.SetFrom(query.Query, "`PaymentAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentAch`.*"})
	}

	return query
}

// PaymentPaymentBills retrieves all the PaymentBill's PaymentBills with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentBills(mods ...qm.QueryMod) paymentBillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentBill`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentBills(queryMods...)
	queries.SetFrom(query.Query, "`PaymentBill`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentBill`.*"})
	}

	return query
}

// PaymentPaymentCheques retrieves all the PaymentCheque's PaymentCheques with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentCheques(mods ...qm.QueryMod) paymentChequeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentCheque`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentCheques(queryMods...)
	queries.SetFrom(query.Query, "`PaymentCheque`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentCheque`.*"})
	}

	return query
}

// PaymentPaymentFxTrades retrieves all the PaymentFxTrade's PaymentFxTrades with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentFxTrades(mods ...qm.QueryMod) paymentFxTradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentFxTrade`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentFxTrades(queryMods...)
	queries.SetFrom(query.Query, "`PaymentFxTrade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentFxTrade`.*"})
	}

	return query
}

// PaymentPaymentLoans retrieves all the PaymentLoan's PaymentLoans with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentLoans(mods ...qm.QueryMod) paymentLoanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentLoan`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentLoans(queryMods...)
	queries.SetFrom(query.Query, "`PaymentLoan`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentLoan`.*"})
	}

	return query
}

// PaymentPaymentMessages retrieves all the PaymentMessage's PaymentMessages with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentMessages(mods ...qm.QueryMod) paymentMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentMessage`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentMessages(queryMods...)
	queries.SetFrom(query.Query, "`PaymentMessage`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentMessage`.*"})
	}

	return query
}

// PaymentPaymentRtps retrieves all the PaymentRtp's PaymentRtps with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentRtps(mods ...qm.QueryMod) paymentRtpQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentRtp`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentRtps(queryMods...)
	queries.SetFrom(query.Query, "`PaymentRtp`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentRtp`.*"})
	}

	return query
}

// PaymentPaymentWires retrieves all the PaymentWire's PaymentWires with an executor via payment_id column.
func (o *PaymentInitiation) PaymentPaymentWires(mods ...qm.QueryMod) paymentWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentWire`.`payment_id`=?", o.PaymentID),
	)

	query := PaymentWires(queryMods...)
	queries.SetFrom(query.Query, "`PaymentWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentWire`.*"})
	}

	return query
}

// LoadPaymentFilePayment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (paymentInitiationL) LoadPaymentFilePayment(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`FilePayment`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FilePayment")
	}

	var resultSlice []*FilePayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FilePayment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for FilePayment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for FilePayment")
	}

	if len(paymentInitiationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentFilePayment = foreign
		if foreign.R == nil {
			foreign.R = &filePaymentR{}
		}
		foreign.R.Payment = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentFilePayment = foreign
				if foreign.R == nil {
					foreign.R = &filePaymentR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentFxPayment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (paymentInitiationL) LoadPaymentFxPayment(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`FxPayment`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FxPayment")
	}

	var resultSlice []*FxPayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FxPayment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for FxPayment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for FxPayment")
	}

	if len(paymentInitiationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentFxPayment = foreign
		if foreign.R == nil {
			foreign.R = &fxPaymentR{}
		}
		foreign.R.Payment = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentFxPayment = foreign
				if foreign.R == nil {
					foreign.R = &fxPaymentR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentCharge allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (paymentInitiationL) LoadPaymentPaymentCharge(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentCharges`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentCharge")
	}

	var resultSlice []*PaymentCharge
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentCharge")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for PaymentCharges")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentCharges")
	}

	if len(paymentInitiationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentPaymentCharge = foreign
		if foreign.R == nil {
			foreign.R = &paymentChargeR{}
		}
		foreign.R.Payment = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentCharge = foreign
				if foreign.R == nil {
					foreign.R = &paymentChargeR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentOBPPaymentConsents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentOBPPaymentConsents(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`OBPPaymentConsent`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OBPPaymentConsent")
	}

	var resultSlice []*OBPPaymentConsent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OBPPaymentConsent")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on OBPPaymentConsent")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for OBPPaymentConsent")
	}

	if len(oBPPaymentConsentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentOBPPaymentConsents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &oBPPaymentConsentR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentOBPPaymentConsents = append(local.R.PaymentOBPPaymentConsents, foreign)
				if foreign.R == nil {
					foreign.R = &oBPPaymentConsentR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentAch`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentAch")
	}

	var resultSlice []*PaymentAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentAch")
	}

	if len(paymentAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAchR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentAches = append(local.R.PaymentPaymentAches, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAchR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentBills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentBills(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentBill`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentBill")
	}

	var resultSlice []*PaymentBill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentBill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentBill")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentBill")
	}

	if len(paymentBillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentBills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentBillR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentBills = append(local.R.PaymentPaymentBills, foreign)
				if foreign.R == nil {
					foreign.R = &paymentBillR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentCheques allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentCheques(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentCheque`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentCheque")
	}

	var resultSlice []*PaymentCheque
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentCheque")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentCheque")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentCheque")
	}

	if len(paymentChequeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentCheques = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentChequeR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentCheques = append(local.R.PaymentPaymentCheques, foreign)
				if foreign.R == nil {
					foreign.R = &paymentChequeR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentFxTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentFxTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentFxTrade`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentFxTrade")
	}

	var resultSlice []*PaymentFxTrade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentFxTrade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentFxTrade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentFxTrade")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentFxTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentFxTradeR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentFxTrades = append(local.R.PaymentPaymentFxTrades, foreign)
				if foreign.R == nil {
					foreign.R = &paymentFxTradeR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentLoans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentLoans(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentLoan`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentLoan")
	}

	var resultSlice []*PaymentLoan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentLoan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentLoan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentLoan")
	}

	if len(paymentLoanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentLoans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentLoanR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentLoans = append(local.R.PaymentPaymentLoans, foreign)
				if foreign.R == nil {
					foreign.R = &paymentLoanR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentMessages(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentMessage`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentMessage")
	}

	var resultSlice []*PaymentMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentMessage")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentMessage")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentMessage")
	}

	if len(paymentMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentMessageR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentMessages = append(local.R.PaymentPaymentMessages, foreign)
				if foreign.R == nil {
					foreign.R = &paymentMessageR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentRtps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentRtps(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentRtp`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentRtp")
	}

	var resultSlice []*PaymentRtp
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentRtp")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentRtp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentRtp")
	}

	if len(paymentRtpAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentRtps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentRtpR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PaymentID == foreign.PaymentID {
				local.R.PaymentPaymentRtps = append(local.R.PaymentPaymentRtps, foreign)
				if foreign.R == nil {
					foreign.R = &paymentRtpR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentPaymentWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (paymentInitiationL) LoadPaymentPaymentWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybePaymentInitiation interface{}, mods queries.Applicator) error {
	var slice []*PaymentInitiation
	var object *PaymentInitiation

	if singular {
		object = maybePaymentInitiation.(*PaymentInitiation)
	} else {
		slice = *maybePaymentInitiation.(*[]*PaymentInitiation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &paymentInitiationR{}
		}
		args = append(args, object.PaymentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &paymentInitiationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentWire`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentWire")
	}

	var resultSlice []*PaymentWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentWire")
	}

	if len(paymentWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaymentPaymentWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentWireR{}
			}
			foreign.R.Payment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.PaymentID, foreign.PaymentID) {
				local.R.PaymentPaymentWires = append(local.R.PaymentPaymentWires, foreign)
				if foreign.R == nil {
					foreign.R = &paymentWireR{}
				}
				foreign.R.Payment = local
				break
			}
		}
	}

	return nil
}

// SetPaymentFilePayment of the paymentInitiation to the related item.
// Sets o.R.PaymentFilePayment to related.
// Adds o to related.R.Payment.
func (o *PaymentInitiation) SetPaymentFilePayment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *FilePayment) error {
	var err error

	if insert {
		related.PaymentID = o.PaymentID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `FilePayment` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
			strmangle.WhereClause("`", "`", 0, filePaymentPrimaryKeyColumns),
		)
		values := []interface{}{o.PaymentID, related.PaymentID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PaymentID = o.PaymentID

	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentFilePayment: related,
		}
	} else {
		o.R.PaymentFilePayment = related
	}

	if related.R == nil {
		related.R = &filePaymentR{
			Payment: o,
		}
	} else {
		related.R.Payment = o
	}
	return nil
}

// SetPaymentFxPayment of the paymentInitiation to the related item.
// Sets o.R.PaymentFxPayment to related.
// Adds o to related.R.Payment.
func (o *PaymentInitiation) SetPaymentFxPayment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *FxPayment) error {
	var err error

	if insert {
		related.PaymentID = o.PaymentID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `FxPayment` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
			strmangle.WhereClause("`", "`", 0, fxPaymentPrimaryKeyColumns),
		)
		values := []interface{}{o.PaymentID, related.PaymentID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PaymentID = o.PaymentID

	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentFxPayment: related,
		}
	} else {
		o.R.PaymentFxPayment = related
	}

	if related.R == nil {
		related.R = &fxPaymentR{
			Payment: o,
		}
	} else {
		related.R.Payment = o
	}
	return nil
}

// SetPaymentPaymentCharge of the paymentInitiation to the related item.
// Sets o.R.PaymentPaymentCharge to related.
// Adds o to related.R.Payment.
func (o *PaymentInitiation) SetPaymentPaymentCharge(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentCharge) error {
	var err error

	if insert {
		related.PaymentID = o.PaymentID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `PaymentCharges` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
			strmangle.WhereClause("`", "`", 0, paymentChargePrimaryKeyColumns),
		)
		values := []interface{}{o.PaymentID, related.PaymentID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PaymentID = o.PaymentID

	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentCharge: related,
		}
	} else {
		o.R.PaymentPaymentCharge = related
	}

	if related.R == nil {
		related.R = &paymentChargeR{
			Payment: o,
		}
	} else {
		related.R.Payment = o
	}
	return nil
}

// AddPaymentOBPPaymentConsents adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentOBPPaymentConsents.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentOBPPaymentConsents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OBPPaymentConsent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `OBPPaymentConsent` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, oBPPaymentConsentPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.ObppaymentconsentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentOBPPaymentConsents: related,
		}
	} else {
		o.R.PaymentOBPPaymentConsents = append(o.R.PaymentOBPPaymentConsents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &oBPPaymentConsentR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentAches adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentAches.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentAchPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentAches: related,
		}
	} else {
		o.R.PaymentPaymentAches = append(o.R.PaymentPaymentAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAchR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentAches removes all previously related items of the
// PaymentInitiation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentAches accordingly.
// Replaces o.R.PaymentPaymentAches with related.
// Sets related.R.Payment's PaymentPaymentAches accordingly.
func (o *PaymentInitiation) SetPaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	query := "update `PaymentAch` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentAches {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentAches = nil
	}
	return o.AddPaymentPaymentAches(ctx, exec, insert, related...)
}

// RemovePaymentPaymentAches relationships from objects passed in.
// Removes related items from R.PaymentPaymentAches (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *PaymentInitiation) RemovePaymentPaymentAches(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentAches {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentAches)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentAches[i] = o.R.PaymentPaymentAches[ln-1]
			}
			o.R.PaymentPaymentAches = o.R.PaymentPaymentAches[:ln-1]
			break
		}
	}

	return nil
}

// AddPaymentPaymentBills adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentBills.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentBills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentBill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentBill` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentBillPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentBillID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentBills: related,
		}
	} else {
		o.R.PaymentPaymentBills = append(o.R.PaymentPaymentBills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentBillR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentCheques adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentCheques.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentCheques(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentCheque) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentCheque` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentChequePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentChequeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentCheques: related,
		}
	} else {
		o.R.PaymentPaymentCheques = append(o.R.PaymentPaymentCheques, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentChequeR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentFxTrades adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentFxTrades.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentFxTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentFxTrade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentFxTrade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentFXTradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentFxTrades: related,
		}
	} else {
		o.R.PaymentPaymentFxTrades = append(o.R.PaymentPaymentFxTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentFxTradeR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentLoans adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentLoans.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentLoans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLoan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentLoan` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentLoanPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentLoanID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentLoans: related,
		}
	} else {
		o.R.PaymentPaymentLoans = append(o.R.PaymentPaymentLoans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentLoanR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentMessages adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentMessages.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentMessage` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentMessageID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentMessages: related,
		}
	} else {
		o.R.PaymentPaymentMessages = append(o.R.PaymentPaymentMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentMessageR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentMessages removes all previously related items of the
// PaymentInitiation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentMessages accordingly.
// Replaces o.R.PaymentPaymentMessages with related.
// Sets related.R.Payment's PaymentPaymentMessages accordingly.
func (o *PaymentInitiation) SetPaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentMessage) error {
	query := "update `PaymentMessage` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentMessages {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentMessages = nil
	}
	return o.AddPaymentPaymentMessages(ctx, exec, insert, related...)
}

// RemovePaymentPaymentMessages relationships from objects passed in.
// Removes related items from R.PaymentPaymentMessages (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *PaymentInitiation) RemovePaymentPaymentMessages(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentMessage) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentMessages {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentMessages)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentMessages[i] = o.R.PaymentPaymentMessages[ln-1]
			}
			o.R.PaymentPaymentMessages = o.R.PaymentPaymentMessages[:ln-1]
			break
		}
	}

	return nil
}

// AddPaymentPaymentRtps adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentRtps.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentRtps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentRtp) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaymentID = o.PaymentID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentRtp` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentRtpPrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentRTPID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaymentID = o.PaymentID
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentRtps: related,
		}
	} else {
		o.R.PaymentPaymentRtps = append(o.R.PaymentPaymentRtps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentRtpR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// AddPaymentPaymentWires adds the given related objects to the existing relationships
// of the PaymentInitiation, optionally inserting them as new records.
// Appends related to o.R.PaymentPaymentWires.
// Sets related.R.Payment appropriately.
func (o *PaymentInitiation) AddPaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PaymentID, o.PaymentID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
				strmangle.WhereClause("`", "`", 0, paymentWirePrimaryKeyColumns),
			)
			values := []interface{}{o.PaymentID, rel.PaymentWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PaymentID, o.PaymentID)
		}
	}

	if o.R == nil {
		o.R = &paymentInitiationR{
			PaymentPaymentWires: related,
		}
	} else {
		o.R.PaymentPaymentWires = append(o.R.PaymentPaymentWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentWireR{
				Payment: o,
			}
		} else {
			rel.R.Payment = o
		}
	}
	return nil
}

// SetPaymentPaymentWires removes all previously related items of the
// PaymentInitiation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Payment's PaymentPaymentWires accordingly.
// Replaces o.R.PaymentPaymentWires with related.
// Sets related.R.Payment's PaymentPaymentWires accordingly.
func (o *PaymentInitiation) SetPaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	query := "update `PaymentWire` set `payment_id` = null where `payment_id` = ?"
	values := []interface{}{o.PaymentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentPaymentWires {
			queries.SetScanner(&rel.PaymentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Payment = nil
		}

		o.R.PaymentPaymentWires = nil
	}
	return o.AddPaymentPaymentWires(ctx, exec, insert, related...)
}

// RemovePaymentPaymentWires relationships from objects passed in.
// Removes related items from R.PaymentPaymentWires (uses pointer comparison, removal does not keep order)
// Sets related.R.Payment.
func (o *PaymentInitiation) RemovePaymentPaymentWires(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PaymentID, nil)
		if rel.R != nil {
			rel.R.Payment = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentPaymentWires {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentPaymentWires)
			if ln > 1 && i < ln-1 {
				o.R.PaymentPaymentWires[i] = o.R.PaymentPaymentWires[ln-1]
			}
			o.R.PaymentPaymentWires = o.R.PaymentPaymentWires[:ln-1]
			break
		}
	}

	return nil
}

// PaymentInitiations retrieves all the records using an executor.
func PaymentInitiations(mods ...qm.QueryMod) paymentInitiationQuery {
	mods = append(mods, qm.From("`PaymentInitiation`"))
	return paymentInitiationQuery{NewQuery(mods...)}
}

// FindPaymentInitiation retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPaymentInitiation(ctx context.Context, exec boil.ContextExecutor, paymentID int, selectCols ...string) (*PaymentInitiation, error) {
	paymentInitiationObj := &PaymentInitiation{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `PaymentInitiation` where `payment_id`=?", sel,
	)

	q := queries.Raw(query, paymentID)

	err := q.Bind(ctx, exec, paymentInitiationObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from PaymentInitiation")
	}

	return paymentInitiationObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PaymentInitiation) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PaymentInitiation provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentInitiationColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	paymentInitiationInsertCacheMut.RLock()
	cache, cached := paymentInitiationInsertCache[key]
	paymentInitiationInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			paymentInitiationColumns,
			paymentInitiationColumnsWithDefault,
			paymentInitiationColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `PaymentInitiation` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `PaymentInitiation` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `PaymentInitiation` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, paymentInitiationPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into PaymentInitiation")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentInitiationMapping["PaymentID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PaymentID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PaymentInitiation")
	}

CacheNoHooks:
	if !cached {
		paymentInitiationInsertCacheMut.Lock()
		paymentInitiationInsertCache[key] = cache
		paymentInitiationInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the PaymentInitiation.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PaymentInitiation) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	paymentInitiationUpdateCacheMut.RLock()
	cache, cached := paymentInitiationUpdateCache[key]
	paymentInitiationUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			paymentInitiationColumns,
			paymentInitiationPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update PaymentInitiation, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `PaymentInitiation` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, paymentInitiationPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, append(wl, paymentInitiationPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update PaymentInitiation row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for PaymentInitiation")
	}

	if !cached {
		paymentInitiationUpdateCacheMut.Lock()
		paymentInitiationUpdateCache[key] = cache
		paymentInitiationUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q paymentInitiationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for PaymentInitiation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for PaymentInitiation")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PaymentInitiationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentInitiationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `PaymentInitiation` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentInitiationPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in paymentInitiation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all paymentInitiation")
	}
	return rowsAff, nil
}

var mySQLPaymentInitiationUniqueColumns = []string{
	"payment_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PaymentInitiation) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PaymentInitiation provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(paymentInitiationColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPaymentInitiationUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	paymentInitiationUpsertCacheMut.RLock()
	cache, cached := paymentInitiationUpsertCache[key]
	paymentInitiationUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			paymentInitiationColumns,
			paymentInitiationColumnsWithDefault,
			paymentInitiationColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			paymentInitiationColumns,
			paymentInitiationPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert PaymentInitiation, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "PaymentInitiation", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `PaymentInitiation` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for PaymentInitiation")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PaymentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == paymentInitiationMapping["payment_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(paymentInitiationType, paymentInitiationMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for PaymentInitiation")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PaymentInitiation")
	}

CacheNoHooks:
	if !cached {
		paymentInitiationUpsertCacheMut.Lock()
		paymentInitiationUpsertCache[key] = cache
		paymentInitiationUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single PaymentInitiation record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PaymentInitiation) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PaymentInitiation provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), paymentInitiationPrimaryKeyMapping)
	sql := "DELETE FROM `PaymentInitiation` WHERE `payment_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from PaymentInitiation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for PaymentInitiation")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q paymentInitiationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no paymentInitiationQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from PaymentInitiation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PaymentInitiation")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PaymentInitiationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PaymentInitiation slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(paymentInitiationBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentInitiationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `PaymentInitiation` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentInitiationPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from paymentInitiation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PaymentInitiation")
	}

	if len(paymentInitiationAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PaymentInitiation) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPaymentInitiation(ctx, exec, o.PaymentID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PaymentInitiationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PaymentInitiationSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), paymentInitiationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `PaymentInitiation`.* FROM `PaymentInitiation` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, paymentInitiationPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PaymentInitiationSlice")
	}

	*o = slice

	return nil
}

// PaymentInitiationExists checks if the PaymentInitiation row exists.
func PaymentInitiationExists(ctx context.Context, exec boil.ContextExecutor, paymentID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `PaymentInitiation` where `payment_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, paymentID)
	}

	row := exec.QueryRowContext(ctx, sql, paymentID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if PaymentInitiation exists")
	}

	return exists, nil
}
