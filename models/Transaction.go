// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Transaction is an object representing the database table.
type Transaction struct {
	TransactionID                              int               `boil:"transaction_id" json:"transaction_id" toml:"transaction_id" yaml:"transaction_id"`
	TransactionReference                       string            `boil:"transaction_reference" json:"transaction_reference" toml:"transaction_reference" yaml:"transaction_reference"`
	StatementRefID                             null.String       `boil:"statement_ref_id" json:"statement_ref_id,omitempty" toml:"statement_ref_id" yaml:"statement_ref_id,omitempty"`
	BankID                                     int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	AccountID                                  int               `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	CreditDebitIndicator                       string            `boil:"credit_debit_indicator" json:"credit_debit_indicator" toml:"credit_debit_indicator" yaml:"credit_debit_indicator"`
	PaymentID                                  null.Int          `boil:"payment_id" json:"payment_id,omitempty" toml:"payment_id" yaml:"payment_id,omitempty"`
	TransferID                                 null.Int          `boil:"transfer_id" json:"transfer_id,omitempty" toml:"transfer_id" yaml:"transfer_id,omitempty"`
	PaymentRefID                               null.String       `boil:"payment_ref_id" json:"payment_ref_id,omitempty" toml:"payment_ref_id" yaml:"payment_ref_id,omitempty"`
	CounterpartyAccountID                      null.Int          `boil:"counterparty_account_id" json:"counterparty_account_id,omitempty" toml:"counterparty_account_id" yaml:"counterparty_account_id,omitempty"`
	TransactionAmount                          types.Decimal     `boil:"transaction_amount" json:"transaction_amount" toml:"transaction_amount" yaml:"transaction_amount"`
	CurrencyCode                               null.String       `boil:"currency_code" json:"currency_code,omitempty" toml:"currency_code" yaml:"currency_code,omitempty"`
	ChargeAmount                               types.NullDecimal `boil:"charge_amount" json:"charge_amount,omitempty" toml:"charge_amount" yaml:"charge_amount,omitempty"`
	ChargeCurrency                             null.String       `boil:"charge_currency" json:"charge_currency,omitempty" toml:"charge_currency" yaml:"charge_currency,omitempty"`
	CounterpartyBankID                         null.Int          `boil:"counterparty_bank_id" json:"counterparty_bank_id,omitempty" toml:"counterparty_bank_id" yaml:"counterparty_bank_id,omitempty"`
	BankLocation                               null.String       `boil:"bank_location" json:"bank_location,omitempty" toml:"bank_location" yaml:"bank_location,omitempty"`
	CounterpartyBankLocation                   null.String       `boil:"counterparty_bank_location" json:"counterparty_bank_location,omitempty" toml:"counterparty_bank_location" yaml:"counterparty_bank_location,omitempty"`
	SwiftCode                                  null.String       `boil:"swift_code" json:"swift_code,omitempty" toml:"swift_code" yaml:"swift_code,omitempty"`
	SwiftCodeTrace                             null.String       `boil:"swift_code_trace" json:"swift_code_trace,omitempty" toml:"swift_code_trace" yaml:"swift_code_trace,omitempty"`
	Purpose                                    null.String       `boil:"purpose" json:"purpose,omitempty" toml:"purpose" yaml:"purpose,omitempty"`
	Status                                     null.String       `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	Balance                                    types.NullDecimal `boil:"balance" json:"balance,omitempty" toml:"balance" yaml:"balance,omitempty"`
	BalanceType                                string            `boil:"balance_type" json:"balance_type" toml:"balance_type" yaml:"balance_type"`
	BalanceCreditDebitIndicator                string            `boil:"balance_credit_debit_indicator" json:"balance_credit_debit_indicator" toml:"balance_credit_debit_indicator" yaml:"balance_credit_debit_indicator"`
	ObTransactionType                          null.String       `boil:"ob_transaction_type" json:"ob_transaction_type,omitempty" toml:"ob_transaction_type" yaml:"ob_transaction_type,omitempty"`
	OverdraftFeesAmount                        types.NullDecimal `boil:"overdraft_fees_amount" json:"overdraft_fees_amount,omitempty" toml:"overdraft_fees_amount" yaml:"overdraft_fees_amount,omitempty"`
	InterestAmount                             types.NullDecimal `boil:"interest_amount" json:"interest_amount,omitempty" toml:"interest_amount" yaml:"interest_amount,omitempty"`
	FeesAmount                                 types.NullDecimal `boil:"fees_amount" json:"fees_amount,omitempty" toml:"fees_amount" yaml:"fees_amount,omitempty"`
	OverdraftAmount                            types.NullDecimal `boil:"overdraft_amount" json:"overdraft_amount,omitempty" toml:"overdraft_amount" yaml:"overdraft_amount,omitempty"`
	FundsAmount                                types.NullDecimal `boil:"funds_amount" json:"funds_amount,omitempty" toml:"funds_amount" yaml:"funds_amount,omitempty"`
	OverdraftInterestAmount                    types.NullDecimal `boil:"overdraft_interest_amount" json:"overdraft_interest_amount,omitempty" toml:"overdraft_interest_amount" yaml:"overdraft_interest_amount,omitempty"`
	InterestRate                               types.NullDecimal `boil:"interest_rate" json:"interest_rate,omitempty" toml:"interest_rate" yaml:"interest_rate,omitempty"`
	OverdraftInterestRate                      types.NullDecimal `boil:"overdraft_interest_rate" json:"overdraft_interest_rate,omitempty" toml:"overdraft_interest_rate" yaml:"overdraft_interest_rate,omitempty"`
	Comment                                    null.String       `boil:"comment" json:"comment,omitempty" toml:"comment" yaml:"comment,omitempty"`
	AddressLine                                null.String       `boil:"address_line" json:"address_line,omitempty" toml:"address_line" yaml:"address_line,omitempty"`
	TransactionName                            string            `boil:"transaction_name" json:"transaction_name" toml:"transaction_name" yaml:"transaction_name"`
	ExpectedDisbursementDate                   null.Time         `boil:"expected_disbursement_date" json:"expected_disbursement_date,omitempty" toml:"expected_disbursement_date" yaml:"expected_disbursement_date,omitempty"`
	ExpectedDisbursementTime                   null.String       `boil:"expected_disbursement_time" json:"expected_disbursement_time,omitempty" toml:"expected_disbursement_time" yaml:"expected_disbursement_time,omitempty"`
	BookingDateTime                            null.Time         `boil:"booking_date_time" json:"booking_date_time,omitempty" toml:"booking_date_time" yaml:"booking_date_time,omitempty"`
	ValueDateTime                              null.Time         `boil:"value_date_time" json:"value_date_time,omitempty" toml:"value_date_time" yaml:"value_date_time,omitempty"`
	CounterpartyBankCode                       null.String       `boil:"counterparty_bank_code" json:"counterparty_bank_code,omitempty" toml:"counterparty_bank_code" yaml:"counterparty_bank_code,omitempty"`
	CounterpartyBankName                       null.String       `boil:"counterparty_bank_name" json:"counterparty_bank_name,omitempty" toml:"counterparty_bank_name" yaml:"counterparty_bank_name,omitempty"`
	BankTransactionCode                        null.String       `boil:"bank_transaction_code" json:"bank_transaction_code,omitempty" toml:"bank_transaction_code" yaml:"bank_transaction_code,omitempty"`
	BankTransactionSubcode                     null.String       `boil:"bank_transaction_subcode" json:"bank_transaction_subcode,omitempty" toml:"bank_transaction_subcode" yaml:"bank_transaction_subcode,omitempty"`
	ProprietaryBankTransactionCode             null.String       `boil:"proprietary_bank_transaction_code" json:"proprietary_bank_transaction_code,omitempty" toml:"proprietary_bank_transaction_code" yaml:"proprietary_bank_transaction_code,omitempty"`
	ProprietaryBankTransactionIssuer           null.String       `boil:"proprietary_bank_transaction_issuer" json:"proprietary_bank_transaction_issuer,omitempty" toml:"proprietary_bank_transaction_issuer" yaml:"proprietary_bank_transaction_issuer,omitempty"`
	IssuerBank                                 null.String       `boil:"issuer_bank" json:"issuer_bank,omitempty" toml:"issuer_bank" yaml:"issuer_bank,omitempty"`
	MerchantName                               null.String       `boil:"merchant_name" json:"merchant_name,omitempty" toml:"merchant_name" yaml:"merchant_name,omitempty"`
	MerchantCategoryCode                       null.String       `boil:"merchant_category_code" json:"merchant_category_code,omitempty" toml:"merchant_category_code" yaml:"merchant_category_code,omitempty"`
	MakerDate                                  time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                                null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                                    string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                                  null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                                 null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate                               null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`
	TransactionTypeID                          int               `boil:"transaction_type_id" json:"transaction_type_id" toml:"transaction_type_id" yaml:"transaction_type_id"`
	CounterpartyAgentSchemename                null.String       `boil:"counterparty_agent_schemename" json:"counterparty_agent_schemename,omitempty" toml:"counterparty_agent_schemename" yaml:"counterparty_agent_schemename,omitempty"`
	CounterpartyAgentIdentification            null.String       `boil:"counterparty_agent_identification" json:"counterparty_agent_identification,omitempty" toml:"counterparty_agent_identification" yaml:"counterparty_agent_identification,omitempty"`
	CounterpartyAccountSchemename              null.String       `boil:"counterparty_account_schemename" json:"counterparty_account_schemename,omitempty" toml:"counterparty_account_schemename" yaml:"counterparty_account_schemename,omitempty"`
	CounterpartyAccountIdentification          null.String       `boil:"counterparty_account_identification" json:"counterparty_account_identification,omitempty" toml:"counterparty_account_identification" yaml:"counterparty_account_identification,omitempty"`
	CounterpartyAccountName                    null.String       `boil:"counterparty_account_name" json:"counterparty_account_name,omitempty" toml:"counterparty_account_name" yaml:"counterparty_account_name,omitempty"`
	CounterpartyAccountSecondaryIdentification null.String       `boil:"counterparty_account_secondary_identification" json:"counterparty_account_secondary_identification,omitempty" toml:"counterparty_account_secondary_identification" yaml:"counterparty_account_secondary_identification,omitempty"`
	CounterpartyReference                      null.String       `boil:"counterparty_reference" json:"counterparty_reference,omitempty" toml:"counterparty_reference" yaml:"counterparty_reference,omitempty"`
	CounterpartyAgentName                      null.String       `boil:"counterparty_agent_name" json:"counterparty_agent_name,omitempty" toml:"counterparty_agent_name" yaml:"counterparty_agent_name,omitempty"`
	CounterpartyAgentAddressType               null.String       `boil:"counterparty_agent_address_type" json:"counterparty_agent_address_type,omitempty" toml:"counterparty_agent_address_type" yaml:"counterparty_agent_address_type,omitempty"`
	CounterpartyAgentDepartment                null.String       `boil:"counterparty_agent_department" json:"counterparty_agent_department,omitempty" toml:"counterparty_agent_department" yaml:"counterparty_agent_department,omitempty"`
	CounterpartyAgentSubdepartment             null.String       `boil:"counterparty_agent_subdepartment" json:"counterparty_agent_subdepartment,omitempty" toml:"counterparty_agent_subdepartment" yaml:"counterparty_agent_subdepartment,omitempty"`
	CounterpartyAgentStreetName                null.String       `boil:"counterparty_agent_street_name" json:"counterparty_agent_street_name,omitempty" toml:"counterparty_agent_street_name" yaml:"counterparty_agent_street_name,omitempty"`
	CounterpartyAgentBuildingNumber            null.String       `boil:"counterparty_agent_building_number" json:"counterparty_agent_building_number,omitempty" toml:"counterparty_agent_building_number" yaml:"counterparty_agent_building_number,omitempty"`
	CounterpartyAgentTownName                  null.String       `boil:"counterparty_agent_town_name" json:"counterparty_agent_town_name,omitempty" toml:"counterparty_agent_town_name" yaml:"counterparty_agent_town_name,omitempty"`
	CounterpartyAgentAddressline1              null.String       `boil:"counterparty_agent_addressline1" json:"counterparty_agent_addressline1,omitempty" toml:"counterparty_agent_addressline1" yaml:"counterparty_agent_addressline1,omitempty"`
	CounterpartyAgentPostalcode                null.String       `boil:"counterparty_agent_postalcode" json:"counterparty_agent_postalcode,omitempty" toml:"counterparty_agent_postalcode" yaml:"counterparty_agent_postalcode,omitempty"`
	CounterpartyAgentCountrysubdivision        null.String       `boil:"counterparty_agent_countrysubdivision" json:"counterparty_agent_countrysubdivision,omitempty" toml:"counterparty_agent_countrysubdivision" yaml:"counterparty_agent_countrysubdivision,omitempty"`
	CounterpartyAgnetCountry                   null.String       `boil:"counterparty_agnet_country" json:"counterparty_agnet_country,omitempty" toml:"counterparty_agnet_country" yaml:"counterparty_agnet_country,omitempty"`
	TransactionInformation                     null.String       `boil:"transaction_information" json:"transaction_information,omitempty" toml:"transaction_information" yaml:"transaction_information,omitempty"`
	CardSchemename                             null.String       `boil:"card_schemename" json:"card_schemename,omitempty" toml:"card_schemename" yaml:"card_schemename,omitempty"`
	CardAuthorizationType                      null.String       `boil:"card_authorization_type" json:"card_authorization_type,omitempty" toml:"card_authorization_type" yaml:"card_authorization_type,omitempty"`
	CardName                                   null.String       `boil:"card_name" json:"card_name,omitempty" toml:"card_name" yaml:"card_name,omitempty"`
	CardIdentification                         null.String       `boil:"card_identification" json:"card_identification,omitempty" toml:"card_identification" yaml:"card_identification,omitempty"`
	SupplementaryData                          null.String       `boil:"supplementary_data" json:"supplementary_data,omitempty" toml:"supplementary_data" yaml:"supplementary_data,omitempty"`

	R *transactionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L transactionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TransactionColumns = struct {
	TransactionID                              string
	TransactionReference                       string
	StatementRefID                             string
	BankID                                     string
	AccountID                                  string
	CreditDebitIndicator                       string
	PaymentID                                  string
	TransferID                                 string
	PaymentRefID                               string
	CounterpartyAccountID                      string
	TransactionAmount                          string
	CurrencyCode                               string
	ChargeAmount                               string
	ChargeCurrency                             string
	CounterpartyBankID                         string
	BankLocation                               string
	CounterpartyBankLocation                   string
	SwiftCode                                  string
	SwiftCodeTrace                             string
	Purpose                                    string
	Status                                     string
	Balance                                    string
	BalanceType                                string
	BalanceCreditDebitIndicator                string
	ObTransactionType                          string
	OverdraftFeesAmount                        string
	InterestAmount                             string
	FeesAmount                                 string
	OverdraftAmount                            string
	FundsAmount                                string
	OverdraftInterestAmount                    string
	InterestRate                               string
	OverdraftInterestRate                      string
	Comment                                    string
	AddressLine                                string
	TransactionName                            string
	ExpectedDisbursementDate                   string
	ExpectedDisbursementTime                   string
	BookingDateTime                            string
	ValueDateTime                              string
	CounterpartyBankCode                       string
	CounterpartyBankName                       string
	BankTransactionCode                        string
	BankTransactionSubcode                     string
	ProprietaryBankTransactionCode             string
	ProprietaryBankTransactionIssuer           string
	IssuerBank                                 string
	MerchantName                               string
	MerchantCategoryCode                       string
	MakerDate                                  string
	CheckerDate                                string
	MakerID                                    string
	CheckerID                                  string
	ModifiedBy                                 string
	ModifiedDate                               string
	TransactionTypeID                          string
	CounterpartyAgentSchemename                string
	CounterpartyAgentIdentification            string
	CounterpartyAccountSchemename              string
	CounterpartyAccountIdentification          string
	CounterpartyAccountName                    string
	CounterpartyAccountSecondaryIdentification string
	CounterpartyReference                      string
	CounterpartyAgentName                      string
	CounterpartyAgentAddressType               string
	CounterpartyAgentDepartment                string
	CounterpartyAgentSubdepartment             string
	CounterpartyAgentStreetName                string
	CounterpartyAgentBuildingNumber            string
	CounterpartyAgentTownName                  string
	CounterpartyAgentAddressline1              string
	CounterpartyAgentPostalcode                string
	CounterpartyAgentCountrysubdivision        string
	CounterpartyAgnetCountry                   string
	TransactionInformation                     string
	CardSchemename                             string
	CardAuthorizationType                      string
	CardName                                   string
	CardIdentification                         string
	SupplementaryData                          string
}{
	TransactionID:                     "transaction_id",
	TransactionReference:              "transaction_reference",
	StatementRefID:                    "statement_ref_id",
	BankID:                            "bank_id",
	AccountID:                         "account_id",
	CreditDebitIndicator:              "credit_debit_indicator",
	PaymentID:                         "payment_id",
	TransferID:                        "transfer_id",
	PaymentRefID:                      "payment_ref_id",
	CounterpartyAccountID:             "counterparty_account_id",
	TransactionAmount:                 "transaction_amount",
	CurrencyCode:                      "currency_code",
	ChargeAmount:                      "charge_amount",
	ChargeCurrency:                    "charge_currency",
	CounterpartyBankID:                "counterparty_bank_id",
	BankLocation:                      "bank_location",
	CounterpartyBankLocation:          "counterparty_bank_location",
	SwiftCode:                         "swift_code",
	SwiftCodeTrace:                    "swift_code_trace",
	Purpose:                           "purpose",
	Status:                            "status",
	Balance:                           "balance",
	BalanceType:                       "balance_type",
	BalanceCreditDebitIndicator:       "balance_credit_debit_indicator",
	ObTransactionType:                 "ob_transaction_type",
	OverdraftFeesAmount:               "overdraft_fees_amount",
	InterestAmount:                    "interest_amount",
	FeesAmount:                        "fees_amount",
	OverdraftAmount:                   "overdraft_amount",
	FundsAmount:                       "funds_amount",
	OverdraftInterestAmount:           "overdraft_interest_amount",
	InterestRate:                      "interest_rate",
	OverdraftInterestRate:             "overdraft_interest_rate",
	Comment:                           "comment",
	AddressLine:                       "address_line",
	TransactionName:                   "transaction_name",
	ExpectedDisbursementDate:          "expected_disbursement_date",
	ExpectedDisbursementTime:          "expected_disbursement_time",
	BookingDateTime:                   "booking_date_time",
	ValueDateTime:                     "value_date_time",
	CounterpartyBankCode:              "counterparty_bank_code",
	CounterpartyBankName:              "counterparty_bank_name",
	BankTransactionCode:               "bank_transaction_code",
	BankTransactionSubcode:            "bank_transaction_subcode",
	ProprietaryBankTransactionCode:    "proprietary_bank_transaction_code",
	ProprietaryBankTransactionIssuer:  "proprietary_bank_transaction_issuer",
	IssuerBank:                        "issuer_bank",
	MerchantName:                      "merchant_name",
	MerchantCategoryCode:              "merchant_category_code",
	MakerDate:                         "maker_date",
	CheckerDate:                       "checker_date",
	MakerID:                           "maker_id",
	CheckerID:                         "checker_id",
	ModifiedBy:                        "modified_by",
	ModifiedDate:                      "modified_date",
	TransactionTypeID:                 "transaction_type_id",
	CounterpartyAgentSchemename:       "counterparty_agent_schemename",
	CounterpartyAgentIdentification:   "counterparty_agent_identification",
	CounterpartyAccountSchemename:     "counterparty_account_schemename",
	CounterpartyAccountIdentification: "counterparty_account_identification",
	CounterpartyAccountName:           "counterparty_account_name",
	CounterpartyAccountSecondaryIdentification: "counterparty_account_secondary_identification",
	CounterpartyReference:                      "counterparty_reference",
	CounterpartyAgentName:                      "counterparty_agent_name",
	CounterpartyAgentAddressType:               "counterparty_agent_address_type",
	CounterpartyAgentDepartment:                "counterparty_agent_department",
	CounterpartyAgentSubdepartment:             "counterparty_agent_subdepartment",
	CounterpartyAgentStreetName:                "counterparty_agent_street_name",
	CounterpartyAgentBuildingNumber:            "counterparty_agent_building_number",
	CounterpartyAgentTownName:                  "counterparty_agent_town_name",
	CounterpartyAgentAddressline1:              "counterparty_agent_addressline1",
	CounterpartyAgentPostalcode:                "counterparty_agent_postalcode",
	CounterpartyAgentCountrysubdivision:        "counterparty_agent_countrysubdivision",
	CounterpartyAgnetCountry:                   "counterparty_agnet_country",
	TransactionInformation:                     "transaction_information",
	CardSchemename:                             "card_schemename",
	CardAuthorizationType:                      "card_authorization_type",
	CardName:                                   "card_name",
	CardIdentification:                         "card_identification",
	SupplementaryData:                          "supplementary_data",
}

// Generated where

var TransactionWhere = struct {
	TransactionID                              whereHelperint
	TransactionReference                       whereHelperstring
	StatementRefID                             whereHelpernull_String
	BankID                                     whereHelperint
	AccountID                                  whereHelperint
	CreditDebitIndicator                       whereHelperstring
	PaymentID                                  whereHelpernull_Int
	TransferID                                 whereHelpernull_Int
	PaymentRefID                               whereHelpernull_String
	CounterpartyAccountID                      whereHelpernull_Int
	TransactionAmount                          whereHelpertypes_Decimal
	CurrencyCode                               whereHelpernull_String
	ChargeAmount                               whereHelpertypes_NullDecimal
	ChargeCurrency                             whereHelpernull_String
	CounterpartyBankID                         whereHelpernull_Int
	BankLocation                               whereHelpernull_String
	CounterpartyBankLocation                   whereHelpernull_String
	SwiftCode                                  whereHelpernull_String
	SwiftCodeTrace                             whereHelpernull_String
	Purpose                                    whereHelpernull_String
	Status                                     whereHelpernull_String
	Balance                                    whereHelpertypes_NullDecimal
	BalanceType                                whereHelperstring
	BalanceCreditDebitIndicator                whereHelperstring
	ObTransactionType                          whereHelpernull_String
	OverdraftFeesAmount                        whereHelpertypes_NullDecimal
	InterestAmount                             whereHelpertypes_NullDecimal
	FeesAmount                                 whereHelpertypes_NullDecimal
	OverdraftAmount                            whereHelpertypes_NullDecimal
	FundsAmount                                whereHelpertypes_NullDecimal
	OverdraftInterestAmount                    whereHelpertypes_NullDecimal
	InterestRate                               whereHelpertypes_NullDecimal
	OverdraftInterestRate                      whereHelpertypes_NullDecimal
	Comment                                    whereHelpernull_String
	AddressLine                                whereHelpernull_String
	TransactionName                            whereHelperstring
	ExpectedDisbursementDate                   whereHelpernull_Time
	ExpectedDisbursementTime                   whereHelpernull_String
	BookingDateTime                            whereHelpernull_Time
	ValueDateTime                              whereHelpernull_Time
	CounterpartyBankCode                       whereHelpernull_String
	CounterpartyBankName                       whereHelpernull_String
	BankTransactionCode                        whereHelpernull_String
	BankTransactionSubcode                     whereHelpernull_String
	ProprietaryBankTransactionCode             whereHelpernull_String
	ProprietaryBankTransactionIssuer           whereHelpernull_String
	IssuerBank                                 whereHelpernull_String
	MerchantName                               whereHelpernull_String
	MerchantCategoryCode                       whereHelpernull_String
	MakerDate                                  whereHelpertime_Time
	CheckerDate                                whereHelpernull_Time
	MakerID                                    whereHelperstring
	CheckerID                                  whereHelpernull_String
	ModifiedBy                                 whereHelpernull_String
	ModifiedDate                               whereHelpernull_Time
	TransactionTypeID                          whereHelperint
	CounterpartyAgentSchemename                whereHelpernull_String
	CounterpartyAgentIdentification            whereHelpernull_String
	CounterpartyAccountSchemename              whereHelpernull_String
	CounterpartyAccountIdentification          whereHelpernull_String
	CounterpartyAccountName                    whereHelpernull_String
	CounterpartyAccountSecondaryIdentification whereHelpernull_String
	CounterpartyReference                      whereHelpernull_String
	CounterpartyAgentName                      whereHelpernull_String
	CounterpartyAgentAddressType               whereHelpernull_String
	CounterpartyAgentDepartment                whereHelpernull_String
	CounterpartyAgentSubdepartment             whereHelpernull_String
	CounterpartyAgentStreetName                whereHelpernull_String
	CounterpartyAgentBuildingNumber            whereHelpernull_String
	CounterpartyAgentTownName                  whereHelpernull_String
	CounterpartyAgentAddressline1              whereHelpernull_String
	CounterpartyAgentPostalcode                whereHelpernull_String
	CounterpartyAgentCountrysubdivision        whereHelpernull_String
	CounterpartyAgnetCountry                   whereHelpernull_String
	TransactionInformation                     whereHelpernull_String
	CardSchemename                             whereHelpernull_String
	CardAuthorizationType                      whereHelpernull_String
	CardName                                   whereHelpernull_String
	CardIdentification                         whereHelpernull_String
	SupplementaryData                          whereHelpernull_String
}{
	TransactionID:                     whereHelperint{field: `transaction_id`},
	TransactionReference:              whereHelperstring{field: `transaction_reference`},
	StatementRefID:                    whereHelpernull_String{field: `statement_ref_id`},
	BankID:                            whereHelperint{field: `bank_id`},
	AccountID:                         whereHelperint{field: `account_id`},
	CreditDebitIndicator:              whereHelperstring{field: `credit_debit_indicator`},
	PaymentID:                         whereHelpernull_Int{field: `payment_id`},
	TransferID:                        whereHelpernull_Int{field: `transfer_id`},
	PaymentRefID:                      whereHelpernull_String{field: `payment_ref_id`},
	CounterpartyAccountID:             whereHelpernull_Int{field: `counterparty_account_id`},
	TransactionAmount:                 whereHelpertypes_Decimal{field: `transaction_amount`},
	CurrencyCode:                      whereHelpernull_String{field: `currency_code`},
	ChargeAmount:                      whereHelpertypes_NullDecimal{field: `charge_amount`},
	ChargeCurrency:                    whereHelpernull_String{field: `charge_currency`},
	CounterpartyBankID:                whereHelpernull_Int{field: `counterparty_bank_id`},
	BankLocation:                      whereHelpernull_String{field: `bank_location`},
	CounterpartyBankLocation:          whereHelpernull_String{field: `counterparty_bank_location`},
	SwiftCode:                         whereHelpernull_String{field: `swift_code`},
	SwiftCodeTrace:                    whereHelpernull_String{field: `swift_code_trace`},
	Purpose:                           whereHelpernull_String{field: `purpose`},
	Status:                            whereHelpernull_String{field: `status`},
	Balance:                           whereHelpertypes_NullDecimal{field: `balance`},
	BalanceType:                       whereHelperstring{field: `balance_type`},
	BalanceCreditDebitIndicator:       whereHelperstring{field: `balance_credit_debit_indicator`},
	ObTransactionType:                 whereHelpernull_String{field: `ob_transaction_type`},
	OverdraftFeesAmount:               whereHelpertypes_NullDecimal{field: `overdraft_fees_amount`},
	InterestAmount:                    whereHelpertypes_NullDecimal{field: `interest_amount`},
	FeesAmount:                        whereHelpertypes_NullDecimal{field: `fees_amount`},
	OverdraftAmount:                   whereHelpertypes_NullDecimal{field: `overdraft_amount`},
	FundsAmount:                       whereHelpertypes_NullDecimal{field: `funds_amount`},
	OverdraftInterestAmount:           whereHelpertypes_NullDecimal{field: `overdraft_interest_amount`},
	InterestRate:                      whereHelpertypes_NullDecimal{field: `interest_rate`},
	OverdraftInterestRate:             whereHelpertypes_NullDecimal{field: `overdraft_interest_rate`},
	Comment:                           whereHelpernull_String{field: `comment`},
	AddressLine:                       whereHelpernull_String{field: `address_line`},
	TransactionName:                   whereHelperstring{field: `transaction_name`},
	ExpectedDisbursementDate:          whereHelpernull_Time{field: `expected_disbursement_date`},
	ExpectedDisbursementTime:          whereHelpernull_String{field: `expected_disbursement_time`},
	BookingDateTime:                   whereHelpernull_Time{field: `booking_date_time`},
	ValueDateTime:                     whereHelpernull_Time{field: `value_date_time`},
	CounterpartyBankCode:              whereHelpernull_String{field: `counterparty_bank_code`},
	CounterpartyBankName:              whereHelpernull_String{field: `counterparty_bank_name`},
	BankTransactionCode:               whereHelpernull_String{field: `bank_transaction_code`},
	BankTransactionSubcode:            whereHelpernull_String{field: `bank_transaction_subcode`},
	ProprietaryBankTransactionCode:    whereHelpernull_String{field: `proprietary_bank_transaction_code`},
	ProprietaryBankTransactionIssuer:  whereHelpernull_String{field: `proprietary_bank_transaction_issuer`},
	IssuerBank:                        whereHelpernull_String{field: `issuer_bank`},
	MerchantName:                      whereHelpernull_String{field: `merchant_name`},
	MerchantCategoryCode:              whereHelpernull_String{field: `merchant_category_code`},
	MakerDate:                         whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                       whereHelpernull_Time{field: `checker_date`},
	MakerID:                           whereHelperstring{field: `maker_id`},
	CheckerID:                         whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                        whereHelpernull_String{field: `modified_by`},
	ModifiedDate:                      whereHelpernull_Time{field: `modified_date`},
	TransactionTypeID:                 whereHelperint{field: `transaction_type_id`},
	CounterpartyAgentSchemename:       whereHelpernull_String{field: `counterparty_agent_schemename`},
	CounterpartyAgentIdentification:   whereHelpernull_String{field: `counterparty_agent_identification`},
	CounterpartyAccountSchemename:     whereHelpernull_String{field: `counterparty_account_schemename`},
	CounterpartyAccountIdentification: whereHelpernull_String{field: `counterparty_account_identification`},
	CounterpartyAccountName:           whereHelpernull_String{field: `counterparty_account_name`},
	CounterpartyAccountSecondaryIdentification: whereHelpernull_String{field: `counterparty_account_secondary_identification`},
	CounterpartyReference:                      whereHelpernull_String{field: `counterparty_reference`},
	CounterpartyAgentName:                      whereHelpernull_String{field: `counterparty_agent_name`},
	CounterpartyAgentAddressType:               whereHelpernull_String{field: `counterparty_agent_address_type`},
	CounterpartyAgentDepartment:                whereHelpernull_String{field: `counterparty_agent_department`},
	CounterpartyAgentSubdepartment:             whereHelpernull_String{field: `counterparty_agent_subdepartment`},
	CounterpartyAgentStreetName:                whereHelpernull_String{field: `counterparty_agent_street_name`},
	CounterpartyAgentBuildingNumber:            whereHelpernull_String{field: `counterparty_agent_building_number`},
	CounterpartyAgentTownName:                  whereHelpernull_String{field: `counterparty_agent_town_name`},
	CounterpartyAgentAddressline1:              whereHelpernull_String{field: `counterparty_agent_addressline1`},
	CounterpartyAgentPostalcode:                whereHelpernull_String{field: `counterparty_agent_postalcode`},
	CounterpartyAgentCountrysubdivision:        whereHelpernull_String{field: `counterparty_agent_countrysubdivision`},
	CounterpartyAgnetCountry:                   whereHelpernull_String{field: `counterparty_agnet_country`},
	TransactionInformation:                     whereHelpernull_String{field: `transaction_information`},
	CardSchemename:                             whereHelpernull_String{field: `card_schemename`},
	CardAuthorizationType:                      whereHelpernull_String{field: `card_authorization_type`},
	CardName:                                   whereHelpernull_String{field: `card_name`},
	CardIdentification:                         whereHelpernull_String{field: `card_identification`},
	SupplementaryData:                          whereHelpernull_String{field: `supplementary_data`},
}

// TransactionRels is where relationship names are stored.
var TransactionRels = struct {
	Account                      string
	Bank                         string
	CurrencyCode                 string
	TransactionJournalEntryLines string
}{
	Account:                      "Account",
	Bank:                         "Bank",
	CurrencyCode:                 "CurrencyCode",
	TransactionJournalEntryLines: "TransactionJournalEntryLines",
}

// transactionR is where relationships are stored.
type transactionR struct {
	Account                      *Account
	Bank                         *Bank
	CurrencyCode                 *CurrencyMaster
	TransactionJournalEntryLines JournalEntryLineSlice
}

// NewStruct creates a new relationship struct
func (*transactionR) NewStruct() *transactionR {
	return &transactionR{}
}

// transactionL is where Load methods for each relationship are stored.
type transactionL struct{}

var (
	transactionColumns               = []string{"transaction_id", "transaction_reference", "statement_ref_id", "bank_id", "account_id", "credit_debit_indicator", "payment_id", "transfer_id", "payment_ref_id", "counterparty_account_id", "transaction_amount", "currency_code", "charge_amount", "charge_currency", "counterparty_bank_id", "bank_location", "counterparty_bank_location", "swift_code", "swift_code_trace", "purpose", "status", "balance", "balance_type", "balance_credit_debit_indicator", "ob_transaction_type", "overdraft_fees_amount", "interest_amount", "fees_amount", "overdraft_amount", "funds_amount", "overdraft_interest_amount", "interest_rate", "overdraft_interest_rate", "comment", "address_line", "transaction_name", "expected_disbursement_date", "expected_disbursement_time", "booking_date_time", "value_date_time", "counterparty_bank_code", "counterparty_bank_name", "bank_transaction_code", "bank_transaction_subcode", "proprietary_bank_transaction_code", "proprietary_bank_transaction_issuer", "issuer_bank", "merchant_name", "merchant_category_code", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "transaction_type_id", "counterparty_agent_schemename", "counterparty_agent_identification", "counterparty_account_schemename", "counterparty_account_identification", "counterparty_account_name", "counterparty_account_secondary_identification", "counterparty_reference", "counterparty_agent_name", "counterparty_agent_address_type", "counterparty_agent_department", "counterparty_agent_subdepartment", "counterparty_agent_street_name", "counterparty_agent_building_number", "counterparty_agent_town_name", "counterparty_agent_addressline1", "counterparty_agent_postalcode", "counterparty_agent_countrysubdivision", "counterparty_agnet_country", "transaction_information", "card_schemename", "card_authorization_type", "card_name", "card_identification", "supplementary_data"}
	transactionColumnsWithoutDefault = []string{"transaction_reference", "statement_ref_id", "bank_id", "account_id", "credit_debit_indicator", "payment_id", "transfer_id", "payment_ref_id", "counterparty_account_id", "transaction_amount", "currency_code", "charge_amount", "charge_currency", "counterparty_bank_id", "bank_location", "counterparty_bank_location", "swift_code", "swift_code_trace", "purpose", "status", "balance", "balance_type", "balance_credit_debit_indicator", "ob_transaction_type", "overdraft_fees_amount", "interest_amount", "fees_amount", "overdraft_amount", "funds_amount", "overdraft_interest_amount", "interest_rate", "overdraft_interest_rate", "comment", "address_line", "transaction_name", "expected_disbursement_date", "expected_disbursement_time", "booking_date_time", "value_date_time", "counterparty_bank_code", "counterparty_bank_name", "bank_transaction_code", "bank_transaction_subcode", "proprietary_bank_transaction_code", "proprietary_bank_transaction_issuer", "issuer_bank", "merchant_name", "merchant_category_code", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "transaction_type_id", "counterparty_agent_schemename", "counterparty_agent_identification", "counterparty_account_schemename", "counterparty_account_identification", "counterparty_account_name", "counterparty_account_secondary_identification", "counterparty_reference", "counterparty_agent_name", "counterparty_agent_address_type", "counterparty_agent_department", "counterparty_agent_subdepartment", "counterparty_agent_street_name", "counterparty_agent_building_number", "counterparty_agent_town_name", "counterparty_agent_addressline1", "counterparty_agent_postalcode", "counterparty_agent_countrysubdivision", "counterparty_agnet_country", "transaction_information", "card_schemename", "card_authorization_type", "card_name", "card_identification", "supplementary_data"}
	transactionColumnsWithDefault    = []string{"transaction_id"}
	transactionPrimaryKeyColumns     = []string{"transaction_id"}
)

type (
	// TransactionSlice is an alias for a slice of pointers to Transaction.
	// This should generally be used opposed to []Transaction.
	TransactionSlice []*Transaction
	// TransactionHook is the signature for custom Transaction hook methods
	TransactionHook func(context.Context, boil.ContextExecutor, *Transaction) error

	transactionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	transactionType                 = reflect.TypeOf(&Transaction{})
	transactionMapping              = queries.MakeStructMapping(transactionType)
	transactionPrimaryKeyMapping, _ = queries.BindMapping(transactionType, transactionMapping, transactionPrimaryKeyColumns)
	transactionInsertCacheMut       sync.RWMutex
	transactionInsertCache          = make(map[string]insertCache)
	transactionUpdateCacheMut       sync.RWMutex
	transactionUpdateCache          = make(map[string]updateCache)
	transactionUpsertCacheMut       sync.RWMutex
	transactionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var transactionBeforeInsertHooks []TransactionHook
var transactionBeforeUpdateHooks []TransactionHook
var transactionBeforeDeleteHooks []TransactionHook
var transactionBeforeUpsertHooks []TransactionHook

var transactionAfterInsertHooks []TransactionHook
var transactionAfterSelectHooks []TransactionHook
var transactionAfterUpdateHooks []TransactionHook
var transactionAfterDeleteHooks []TransactionHook
var transactionAfterUpsertHooks []TransactionHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Transaction) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Transaction) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Transaction) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Transaction) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Transaction) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Transaction) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Transaction) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Transaction) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Transaction) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range transactionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTransactionHook registers your hook function for all future operations.
func AddTransactionHook(hookPoint boil.HookPoint, transactionHook TransactionHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		transactionBeforeInsertHooks = append(transactionBeforeInsertHooks, transactionHook)
	case boil.BeforeUpdateHook:
		transactionBeforeUpdateHooks = append(transactionBeforeUpdateHooks, transactionHook)
	case boil.BeforeDeleteHook:
		transactionBeforeDeleteHooks = append(transactionBeforeDeleteHooks, transactionHook)
	case boil.BeforeUpsertHook:
		transactionBeforeUpsertHooks = append(transactionBeforeUpsertHooks, transactionHook)
	case boil.AfterInsertHook:
		transactionAfterInsertHooks = append(transactionAfterInsertHooks, transactionHook)
	case boil.AfterSelectHook:
		transactionAfterSelectHooks = append(transactionAfterSelectHooks, transactionHook)
	case boil.AfterUpdateHook:
		transactionAfterUpdateHooks = append(transactionAfterUpdateHooks, transactionHook)
	case boil.AfterDeleteHook:
		transactionAfterDeleteHooks = append(transactionAfterDeleteHooks, transactionHook)
	case boil.AfterUpsertHook:
		transactionAfterUpsertHooks = append(transactionAfterUpsertHooks, transactionHook)
	}
}

// One returns a single transaction record from the query.
func (q transactionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Transaction, error) {
	o := &Transaction{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Transaction")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Transaction records from the query.
func (q transactionQuery) All(ctx context.Context, exec boil.ContextExecutor) (TransactionSlice, error) {
	var o []*Transaction

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Transaction slice")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Transaction records in the query.
func (q transactionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Transaction rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q transactionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Transaction exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *Transaction) Account(mods ...qm.QueryMod) accountQuery {
	queryMods := []qm.QueryMod{
		qm.Where("account_id=?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	query := Accounts(queryMods...)
	queries.SetFrom(query.Query, "`Account`")

	return query
}

// Bank pointed to by the foreign key.
func (o *Transaction) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// CurrencyCode pointed to by the foreign key.
func (o *Transaction) CurrencyCode1(mods ...qm.QueryMod) currencyMasterQuery {
	queryMods := []qm.QueryMod{
		qm.Where("currency_id=?", o.CurrencyCode),
	}

	queryMods = append(queryMods, mods...)

	query := CurrencyMasters(queryMods...)
	queries.SetFrom(query.Query, "`CurrencyMaster`")

	return query
}

// TransactionJournalEntryLines retrieves all the JournalEntryLine's JournalEntryLines with an executor via transaction_id column.
func (o *Transaction) TransactionJournalEntryLines(mods ...qm.QueryMod) journalEntryLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JournalEntryLine`.`transaction_id`=?", o.TransactionID),
	)

	query := JournalEntryLines(queryMods...)
	queries.SetFrom(query.Query, "`JournalEntryLine`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JournalEntryLine`.*"})
	}

	return query
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args = append(args, object.AccountID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Account`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Account")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Account")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &accountR{}
		}
		foreign.R.AccountTransactions = append(foreign.R.AccountTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AccountID == foreign.AccountID {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.AccountTransactions = append(foreign.R.AccountTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankTransactions = append(foreign.R.BankTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankTransactions = append(foreign.R.BankTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadCurrencyCode allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadCurrencyCode(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.CurrencyCode) {
			args = append(args, object.CurrencyCode)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CurrencyCode) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CurrencyCode) {
				args = append(args, obj.CurrencyCode)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CurrencyMaster`), qm.WhereIn(`currency_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CurrencyMaster")
	}

	var resultSlice []*CurrencyMaster
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CurrencyMaster")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for CurrencyMaster")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CurrencyMaster")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CurrencyCode = foreign
		if foreign.R == nil {
			foreign.R = &currencyMasterR{}
		}
		foreign.R.CurrencyCodeTransactions = append(foreign.R.CurrencyCodeTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CurrencyCode, foreign.CurrencyID) {
				local.R.CurrencyCode = foreign
				if foreign.R == nil {
					foreign.R = &currencyMasterR{}
				}
				foreign.R.CurrencyCodeTransactions = append(foreign.R.CurrencyCodeTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadTransactionJournalEntryLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (transactionL) LoadTransactionJournalEntryLines(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args = append(args, object.TransactionID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if a == obj.TransactionID {
					continue Outer
				}
			}

			args = append(args, obj.TransactionID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JournalEntryLine`), qm.WhereIn(`transaction_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JournalEntryLine")
	}

	var resultSlice []*JournalEntryLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JournalEntryLine")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JournalEntryLine")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JournalEntryLine")
	}

	if len(journalEntryLineAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TransactionJournalEntryLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &journalEntryLineR{}
			}
			foreign.R.Transaction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.TransactionID == foreign.TransactionID {
				local.R.TransactionJournalEntryLines = append(local.R.TransactionJournalEntryLines, foreign)
				if foreign.R == nil {
					foreign.R = &journalEntryLineR{}
				}
				foreign.R.Transaction = local
				break
			}
		}
	}

	return nil
}

// SetAccount of the transaction to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountTransactions.
func (o *Transaction) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Account) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Transaction` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
		strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.AccountID, o.TransactionID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AccountID = related.AccountID
	if o.R == nil {
		o.R = &transactionR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &accountR{
			AccountTransactions: TransactionSlice{o},
		}
	} else {
		related.R.AccountTransactions = append(related.R.AccountTransactions, o)
	}

	return nil
}

// SetBank of the transaction to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankTransactions.
func (o *Transaction) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Transaction` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.TransactionID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &transactionR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankTransactions: TransactionSlice{o},
		}
	} else {
		related.R.BankTransactions = append(related.R.BankTransactions, o)
	}

	return nil
}

// SetCurrencyCode of the transaction to the related item.
// Sets o.R.CurrencyCode to related.
// Adds o to related.R.CurrencyCodeTransactions.
func (o *Transaction) SetCurrencyCode(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CurrencyMaster) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Transaction` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"currency_code"}),
		strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.CurrencyID, o.TransactionID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CurrencyCode, related.CurrencyID)
	if o.R == nil {
		o.R = &transactionR{
			CurrencyCode: related,
		}
	} else {
		o.R.CurrencyCode = related
	}

	if related.R == nil {
		related.R = &currencyMasterR{
			CurrencyCodeTransactions: TransactionSlice{o},
		}
	} else {
		related.R.CurrencyCodeTransactions = append(related.R.CurrencyCodeTransactions, o)
	}

	return nil
}

// RemoveCurrencyCode relationship.
// Sets o.R.CurrencyCode to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveCurrencyCode(ctx context.Context, exec boil.ContextExecutor, related *CurrencyMaster) error {
	var err error

	queries.SetScanner(&o.CurrencyCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("currency_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.CurrencyCode = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CurrencyCodeTransactions {
		if queries.Equal(o.CurrencyCode, ri.CurrencyCode) {
			continue
		}

		ln := len(related.R.CurrencyCodeTransactions)
		if ln > 1 && i < ln-1 {
			related.R.CurrencyCodeTransactions[i] = related.R.CurrencyCodeTransactions[ln-1]
		}
		related.R.CurrencyCodeTransactions = related.R.CurrencyCodeTransactions[:ln-1]
		break
	}
	return nil
}

// AddTransactionJournalEntryLines adds the given related objects to the existing relationships
// of the Transaction, optionally inserting them as new records.
// Appends related to o.R.TransactionJournalEntryLines.
// Sets related.R.Transaction appropriately.
func (o *Transaction) AddTransactionJournalEntryLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JournalEntryLine) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.TransactionID = o.TransactionID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JournalEntryLine` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"transaction_id"}),
				strmangle.WhereClause("`", "`", 0, journalEntryLinePrimaryKeyColumns),
			)
			values := []interface{}{o.TransactionID, rel.JournalEntryLineID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.TransactionID = o.TransactionID
		}
	}

	if o.R == nil {
		o.R = &transactionR{
			TransactionJournalEntryLines: related,
		}
	} else {
		o.R.TransactionJournalEntryLines = append(o.R.TransactionJournalEntryLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &journalEntryLineR{
				Transaction: o,
			}
		} else {
			rel.R.Transaction = o
		}
	}
	return nil
}

// Transactions retrieves all the records using an executor.
func Transactions(mods ...qm.QueryMod) transactionQuery {
	mods = append(mods, qm.From("`Transaction`"))
	return transactionQuery{NewQuery(mods...)}
}

// FindTransaction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTransaction(ctx context.Context, exec boil.ContextExecutor, transactionID int, selectCols ...string) (*Transaction, error) {
	transactionObj := &Transaction{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Transaction` where `transaction_id`=?", sel,
	)

	q := queries.Raw(query, transactionID)

	err := q.Bind(ctx, exec, transactionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Transaction")
	}

	return transactionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Transaction) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Transaction provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	transactionInsertCacheMut.RLock()
	cache, cached := transactionInsertCache[key]
	transactionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			transactionColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Transaction` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Transaction` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Transaction` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Transaction")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.TransactionID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == transactionMapping["TransactionID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.TransactionID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Transaction")
	}

CacheNoHooks:
	if !cached {
		transactionInsertCacheMut.Lock()
		transactionInsertCache[key] = cache
		transactionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Transaction.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Transaction) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	transactionUpdateCacheMut.RLock()
	cache, cached := transactionUpdateCache[key]
	transactionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			transactionColumns,
			transactionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Transaction, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Transaction` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, append(wl, transactionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Transaction row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Transaction")
	}

	if !cached {
		transactionUpdateCacheMut.Lock()
		transactionUpdateCache[key] = cache
		transactionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q transactionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Transaction")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Transaction")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TransactionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Transaction` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, transactionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all transaction")
	}
	return rowsAff, nil
}

var mySQLTransactionUniqueColumns = []string{
	"transaction_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Transaction) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Transaction provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLTransactionUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	transactionUpsertCacheMut.RLock()
	cache, cached := transactionUpsertCache[key]
	transactionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			transactionColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			transactionColumns,
			transactionPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Transaction, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Transaction", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Transaction` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Transaction")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.TransactionID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == transactionMapping["transaction_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(transactionType, transactionMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Transaction")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Transaction")
	}

CacheNoHooks:
	if !cached {
		transactionUpsertCacheMut.Lock()
		transactionUpsertCache[key] = cache
		transactionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Transaction record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Transaction) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Transaction provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), transactionPrimaryKeyMapping)
	sql := "DELETE FROM `Transaction` WHERE `transaction_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Transaction")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Transaction")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q transactionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no transactionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Transaction")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Transaction")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TransactionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Transaction slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(transactionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Transaction` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, transactionPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Transaction")
	}

	if len(transactionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Transaction) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTransaction(ctx, exec, o.TransactionID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TransactionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TransactionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Transaction`.* FROM `Transaction` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, transactionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in TransactionSlice")
	}

	*o = slice

	return nil
}

// TransactionExists checks if the Transaction row exists.
func TransactionExists(ctx context.Context, exec boil.ContextExecutor, transactionID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Transaction` where `transaction_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, transactionID)
	}

	row := exec.QueryRowContext(ctx, sql, transactionID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Transaction exists")
	}

	return exists, nil
}
