// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// RtpRequest is an object representing the database table.
type RtpRequest struct {
	RTPRequestID         int               `boil:"rtp_request_id" json:"rtp_request_id" toml:"rtp_request_id" yaml:"rtp_request_id"`
	Amount               types.Decimal     `boil:"amount" json:"amount" toml:"amount" yaml:"amount"`
	DateCreated          time.Time         `boil:"date_created" json:"date_created" toml:"date_created" yaml:"date_created"`
	RequestStatus        null.String       `boil:"request_status" json:"request_status,omitempty" toml:"request_status" yaml:"request_status,omitempty"`
	ResponderName        null.String       `boil:"responder_name" json:"responder_name,omitempty" toml:"responder_name" yaml:"responder_name,omitempty"`
	FromPartyID          int               `boil:"from_party_id" json:"from_party_id" toml:"from_party_id" yaml:"from_party_id"`
	RequesterTokenID     int               `boil:"requester_token_id" json:"requester_token_id" toml:"requester_token_id" yaml:"requester_token_id"`
	ResponderTokenID     int               `boil:"responder_token_id" json:"responder_token_id" toml:"responder_token_id" yaml:"responder_token_id"`
	RTPChargeAmount      types.NullDecimal `boil:"rtp_charge_amount" json:"rtp_charge_amount,omitempty" toml:"rtp_charge_amount" yaml:"rtp_charge_amount,omitempty"`
	FinalRTPCreditAmount types.NullDecimal `boil:"final_rtp_credit_amount" json:"final_rtp_credit_amount,omitempty" toml:"final_rtp_credit_amount" yaml:"final_rtp_credit_amount,omitempty"`
	MakerDate            time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate          null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID              string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID            null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy           null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate         null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *rtpRequestR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L rtpRequestL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var RtpRequestColumns = struct {
	RTPRequestID         string
	Amount               string
	DateCreated          string
	RequestStatus        string
	ResponderName        string
	FromPartyID          string
	RequesterTokenID     string
	ResponderTokenID     string
	RTPChargeAmount      string
	FinalRTPCreditAmount string
	MakerDate            string
	CheckerDate          string
	MakerID              string
	CheckerID            string
	ModifiedBy           string
	ModifiedDate         string
}{
	RTPRequestID:         "rtp_request_id",
	Amount:               "amount",
	DateCreated:          "date_created",
	RequestStatus:        "request_status",
	ResponderName:        "responder_name",
	FromPartyID:          "from_party_id",
	RequesterTokenID:     "requester_token_id",
	ResponderTokenID:     "responder_token_id",
	RTPChargeAmount:      "rtp_charge_amount",
	FinalRTPCreditAmount: "final_rtp_credit_amount",
	MakerDate:            "maker_date",
	CheckerDate:          "checker_date",
	MakerID:              "maker_id",
	CheckerID:            "checker_id",
	ModifiedBy:           "modified_by",
	ModifiedDate:         "modified_date",
}

// Generated where

var RtpRequestWhere = struct {
	RTPRequestID         whereHelperint
	Amount               whereHelpertypes_Decimal
	DateCreated          whereHelpertime_Time
	RequestStatus        whereHelpernull_String
	ResponderName        whereHelpernull_String
	FromPartyID          whereHelperint
	RequesterTokenID     whereHelperint
	ResponderTokenID     whereHelperint
	RTPChargeAmount      whereHelpertypes_NullDecimal
	FinalRTPCreditAmount whereHelpertypes_NullDecimal
	MakerDate            whereHelpertime_Time
	CheckerDate          whereHelpernull_Time
	MakerID              whereHelperstring
	CheckerID            whereHelpernull_String
	ModifiedBy           whereHelpernull_String
	ModifiedDate         whereHelpernull_Time
}{
	RTPRequestID:         whereHelperint{field: `rtp_request_id`},
	Amount:               whereHelpertypes_Decimal{field: `amount`},
	DateCreated:          whereHelpertime_Time{field: `date_created`},
	RequestStatus:        whereHelpernull_String{field: `request_status`},
	ResponderName:        whereHelpernull_String{field: `responder_name`},
	FromPartyID:          whereHelperint{field: `from_party_id`},
	RequesterTokenID:     whereHelperint{field: `requester_token_id`},
	ResponderTokenID:     whereHelperint{field: `responder_token_id`},
	RTPChargeAmount:      whereHelpertypes_NullDecimal{field: `rtp_charge_amount`},
	FinalRTPCreditAmount: whereHelpertypes_NullDecimal{field: `final_rtp_credit_amount`},
	MakerDate:            whereHelpertime_Time{field: `maker_date`},
	CheckerDate:          whereHelpernull_Time{field: `checker_date`},
	MakerID:              whereHelperstring{field: `maker_id`},
	CheckerID:            whereHelpernull_String{field: `checker_id`},
	ModifiedBy:           whereHelpernull_String{field: `modified_by`},
	ModifiedDate:         whereHelpernull_Time{field: `modified_date`},
}

// RtpRequestRels is where relationship names are stored.
var RtpRequestRels = struct {
	FromParty             string
	RequesterToken        string
	ResponderToken        string
	RTPRequestPaymentRtps string
}{
	FromParty:             "FromParty",
	RequesterToken:        "RequesterToken",
	ResponderToken:        "ResponderToken",
	RTPRequestPaymentRtps: "RTPRequestPaymentRtps",
}

// rtpRequestR is where relationships are stored.
type rtpRequestR struct {
	FromParty             *Party
	RequesterToken        *RtpToken
	ResponderToken        *RtpToken
	RTPRequestPaymentRtps PaymentRtpSlice
}

// NewStruct creates a new relationship struct
func (*rtpRequestR) NewStruct() *rtpRequestR {
	return &rtpRequestR{}
}

// rtpRequestL is where Load methods for each relationship are stored.
type rtpRequestL struct{}

var (
	rtpRequestColumns               = []string{"rtp_request_id", "amount", "date_created", "request_status", "responder_name", "from_party_id", "requester_token_id", "responder_token_id", "rtp_charge_amount", "final_rtp_credit_amount", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	rtpRequestColumnsWithoutDefault = []string{"amount", "date_created", "request_status", "responder_name", "from_party_id", "requester_token_id", "responder_token_id", "rtp_charge_amount", "final_rtp_credit_amount", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	rtpRequestColumnsWithDefault    = []string{"rtp_request_id"}
	rtpRequestPrimaryKeyColumns     = []string{"rtp_request_id"}
)

type (
	// RtpRequestSlice is an alias for a slice of pointers to RtpRequest.
	// This should generally be used opposed to []RtpRequest.
	RtpRequestSlice []*RtpRequest
	// RtpRequestHook is the signature for custom RtpRequest hook methods
	RtpRequestHook func(context.Context, boil.ContextExecutor, *RtpRequest) error

	rtpRequestQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	rtpRequestType                 = reflect.TypeOf(&RtpRequest{})
	rtpRequestMapping              = queries.MakeStructMapping(rtpRequestType)
	rtpRequestPrimaryKeyMapping, _ = queries.BindMapping(rtpRequestType, rtpRequestMapping, rtpRequestPrimaryKeyColumns)
	rtpRequestInsertCacheMut       sync.RWMutex
	rtpRequestInsertCache          = make(map[string]insertCache)
	rtpRequestUpdateCacheMut       sync.RWMutex
	rtpRequestUpdateCache          = make(map[string]updateCache)
	rtpRequestUpsertCacheMut       sync.RWMutex
	rtpRequestUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var rtpRequestBeforeInsertHooks []RtpRequestHook
var rtpRequestBeforeUpdateHooks []RtpRequestHook
var rtpRequestBeforeDeleteHooks []RtpRequestHook
var rtpRequestBeforeUpsertHooks []RtpRequestHook

var rtpRequestAfterInsertHooks []RtpRequestHook
var rtpRequestAfterSelectHooks []RtpRequestHook
var rtpRequestAfterUpdateHooks []RtpRequestHook
var rtpRequestAfterDeleteHooks []RtpRequestHook
var rtpRequestAfterUpsertHooks []RtpRequestHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *RtpRequest) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *RtpRequest) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *RtpRequest) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *RtpRequest) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *RtpRequest) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *RtpRequest) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *RtpRequest) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *RtpRequest) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *RtpRequest) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rtpRequestAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddRtpRequestHook registers your hook function for all future operations.
func AddRtpRequestHook(hookPoint boil.HookPoint, rtpRequestHook RtpRequestHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		rtpRequestBeforeInsertHooks = append(rtpRequestBeforeInsertHooks, rtpRequestHook)
	case boil.BeforeUpdateHook:
		rtpRequestBeforeUpdateHooks = append(rtpRequestBeforeUpdateHooks, rtpRequestHook)
	case boil.BeforeDeleteHook:
		rtpRequestBeforeDeleteHooks = append(rtpRequestBeforeDeleteHooks, rtpRequestHook)
	case boil.BeforeUpsertHook:
		rtpRequestBeforeUpsertHooks = append(rtpRequestBeforeUpsertHooks, rtpRequestHook)
	case boil.AfterInsertHook:
		rtpRequestAfterInsertHooks = append(rtpRequestAfterInsertHooks, rtpRequestHook)
	case boil.AfterSelectHook:
		rtpRequestAfterSelectHooks = append(rtpRequestAfterSelectHooks, rtpRequestHook)
	case boil.AfterUpdateHook:
		rtpRequestAfterUpdateHooks = append(rtpRequestAfterUpdateHooks, rtpRequestHook)
	case boil.AfterDeleteHook:
		rtpRequestAfterDeleteHooks = append(rtpRequestAfterDeleteHooks, rtpRequestHook)
	case boil.AfterUpsertHook:
		rtpRequestAfterUpsertHooks = append(rtpRequestAfterUpsertHooks, rtpRequestHook)
	}
}

// One returns a single rtpRequest record from the query.
func (q rtpRequestQuery) One(ctx context.Context, exec boil.ContextExecutor) (*RtpRequest, error) {
	o := &RtpRequest{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for RtpRequest")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all RtpRequest records from the query.
func (q rtpRequestQuery) All(ctx context.Context, exec boil.ContextExecutor) (RtpRequestSlice, error) {
	var o []*RtpRequest

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to RtpRequest slice")
	}

	if len(rtpRequestAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all RtpRequest records in the query.
func (q rtpRequestQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count RtpRequest rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q rtpRequestQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if RtpRequest exists")
	}

	return count > 0, nil
}

// FromParty pointed to by the foreign key.
func (o *RtpRequest) FromParty(mods ...qm.QueryMod) partyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.FromPartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	return query
}

// RequesterToken pointed to by the foreign key.
func (o *RtpRequest) RequesterToken(mods ...qm.QueryMod) rtpTokenQuery {
	queryMods := []qm.QueryMod{
		qm.Where("token_id=?", o.RequesterTokenID),
	}

	queryMods = append(queryMods, mods...)

	query := RtpTokens(queryMods...)
	queries.SetFrom(query.Query, "`RtpToken`")

	return query
}

// ResponderToken pointed to by the foreign key.
func (o *RtpRequest) ResponderToken(mods ...qm.QueryMod) rtpTokenQuery {
	queryMods := []qm.QueryMod{
		qm.Where("token_id=?", o.ResponderTokenID),
	}

	queryMods = append(queryMods, mods...)

	query := RtpTokens(queryMods...)
	queries.SetFrom(query.Query, "`RtpToken`")

	return query
}

// RTPRequestPaymentRtps retrieves all the PaymentRtp's PaymentRtps with an executor via rtp_request_id column.
func (o *RtpRequest) RTPRequestPaymentRtps(mods ...qm.QueryMod) paymentRtpQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentRtp`.`rtp_request_id`=?", o.RTPRequestID),
	)

	query := PaymentRtps(queryMods...)
	queries.SetFrom(query.Query, "`PaymentRtp`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentRtp`.*"})
	}

	return query
}

// LoadFromParty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rtpRequestL) LoadFromParty(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRtpRequest interface{}, mods queries.Applicator) error {
	var slice []*RtpRequest
	var object *RtpRequest

	if singular {
		object = maybeRtpRequest.(*RtpRequest)
	} else {
		slice = *maybeRtpRequest.(*[]*RtpRequest)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &rtpRequestR{}
		}
		args = append(args, object.FromPartyID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rtpRequestR{}
			}

			for _, a := range args {
				if a == obj.FromPartyID {
					continue Outer
				}
			}

			args = append(args, obj.FromPartyID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Party")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Party")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(rtpRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FromParty = foreign
		if foreign.R == nil {
			foreign.R = &partyR{}
		}
		foreign.R.FromPartyRtpRequests = append(foreign.R.FromPartyRtpRequests, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FromPartyID == foreign.PartyID {
				local.R.FromParty = foreign
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.FromPartyRtpRequests = append(foreign.R.FromPartyRtpRequests, local)
				break
			}
		}
	}

	return nil
}

// LoadRequesterToken allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rtpRequestL) LoadRequesterToken(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRtpRequest interface{}, mods queries.Applicator) error {
	var slice []*RtpRequest
	var object *RtpRequest

	if singular {
		object = maybeRtpRequest.(*RtpRequest)
	} else {
		slice = *maybeRtpRequest.(*[]*RtpRequest)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &rtpRequestR{}
		}
		args = append(args, object.RequesterTokenID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rtpRequestR{}
			}

			for _, a := range args {
				if a == obj.RequesterTokenID {
					continue Outer
				}
			}

			args = append(args, obj.RequesterTokenID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`RtpToken`), qm.WhereIn(`token_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RtpToken")
	}

	var resultSlice []*RtpToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RtpToken")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for RtpToken")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for RtpToken")
	}

	if len(rtpRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.RequesterToken = foreign
		if foreign.R == nil {
			foreign.R = &rtpTokenR{}
		}
		foreign.R.RequesterTokenRtpRequests = append(foreign.R.RequesterTokenRtpRequests, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RequesterTokenID == foreign.TokenID {
				local.R.RequesterToken = foreign
				if foreign.R == nil {
					foreign.R = &rtpTokenR{}
				}
				foreign.R.RequesterTokenRtpRequests = append(foreign.R.RequesterTokenRtpRequests, local)
				break
			}
		}
	}

	return nil
}

// LoadResponderToken allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rtpRequestL) LoadResponderToken(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRtpRequest interface{}, mods queries.Applicator) error {
	var slice []*RtpRequest
	var object *RtpRequest

	if singular {
		object = maybeRtpRequest.(*RtpRequest)
	} else {
		slice = *maybeRtpRequest.(*[]*RtpRequest)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &rtpRequestR{}
		}
		args = append(args, object.ResponderTokenID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rtpRequestR{}
			}

			for _, a := range args {
				if a == obj.ResponderTokenID {
					continue Outer
				}
			}

			args = append(args, obj.ResponderTokenID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`RtpToken`), qm.WhereIn(`token_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RtpToken")
	}

	var resultSlice []*RtpToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RtpToken")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for RtpToken")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for RtpToken")
	}

	if len(rtpRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ResponderToken = foreign
		if foreign.R == nil {
			foreign.R = &rtpTokenR{}
		}
		foreign.R.ResponderTokenRtpRequests = append(foreign.R.ResponderTokenRtpRequests, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ResponderTokenID == foreign.TokenID {
				local.R.ResponderToken = foreign
				if foreign.R == nil {
					foreign.R = &rtpTokenR{}
				}
				foreign.R.ResponderTokenRtpRequests = append(foreign.R.ResponderTokenRtpRequests, local)
				break
			}
		}
	}

	return nil
}

// LoadRTPRequestPaymentRtps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (rtpRequestL) LoadRTPRequestPaymentRtps(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRtpRequest interface{}, mods queries.Applicator) error {
	var slice []*RtpRequest
	var object *RtpRequest

	if singular {
		object = maybeRtpRequest.(*RtpRequest)
	} else {
		slice = *maybeRtpRequest.(*[]*RtpRequest)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &rtpRequestR{}
		}
		args = append(args, object.RTPRequestID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rtpRequestR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.RTPRequestID) {
					continue Outer
				}
			}

			args = append(args, obj.RTPRequestID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentRtp`), qm.WhereIn(`rtp_request_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentRtp")
	}

	var resultSlice []*PaymentRtp
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentRtp")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentRtp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentRtp")
	}

	if len(paymentRtpAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RTPRequestPaymentRtps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentRtpR{}
			}
			foreign.R.RTPRequest = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.RTPRequestID, foreign.RTPRequestID) {
				local.R.RTPRequestPaymentRtps = append(local.R.RTPRequestPaymentRtps, foreign)
				if foreign.R == nil {
					foreign.R = &paymentRtpR{}
				}
				foreign.R.RTPRequest = local
				break
			}
		}
	}

	return nil
}

// SetFromParty of the rtpRequest to the related item.
// Sets o.R.FromParty to related.
// Adds o to related.R.FromPartyRtpRequests.
func (o *RtpRequest) SetFromParty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Party) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `RtpRequest` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"from_party_id"}),
		strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns),
	)
	values := []interface{}{related.PartyID, o.RTPRequestID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FromPartyID = related.PartyID
	if o.R == nil {
		o.R = &rtpRequestR{
			FromParty: related,
		}
	} else {
		o.R.FromParty = related
	}

	if related.R == nil {
		related.R = &partyR{
			FromPartyRtpRequests: RtpRequestSlice{o},
		}
	} else {
		related.R.FromPartyRtpRequests = append(related.R.FromPartyRtpRequests, o)
	}

	return nil
}

// SetRequesterToken of the rtpRequest to the related item.
// Sets o.R.RequesterToken to related.
// Adds o to related.R.RequesterTokenRtpRequests.
func (o *RtpRequest) SetRequesterToken(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RtpToken) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `RtpRequest` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"requester_token_id"}),
		strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns),
	)
	values := []interface{}{related.TokenID, o.RTPRequestID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RequesterTokenID = related.TokenID
	if o.R == nil {
		o.R = &rtpRequestR{
			RequesterToken: related,
		}
	} else {
		o.R.RequesterToken = related
	}

	if related.R == nil {
		related.R = &rtpTokenR{
			RequesterTokenRtpRequests: RtpRequestSlice{o},
		}
	} else {
		related.R.RequesterTokenRtpRequests = append(related.R.RequesterTokenRtpRequests, o)
	}

	return nil
}

// SetResponderToken of the rtpRequest to the related item.
// Sets o.R.ResponderToken to related.
// Adds o to related.R.ResponderTokenRtpRequests.
func (o *RtpRequest) SetResponderToken(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RtpToken) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `RtpRequest` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"responder_token_id"}),
		strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns),
	)
	values := []interface{}{related.TokenID, o.RTPRequestID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ResponderTokenID = related.TokenID
	if o.R == nil {
		o.R = &rtpRequestR{
			ResponderToken: related,
		}
	} else {
		o.R.ResponderToken = related
	}

	if related.R == nil {
		related.R = &rtpTokenR{
			ResponderTokenRtpRequests: RtpRequestSlice{o},
		}
	} else {
		related.R.ResponderTokenRtpRequests = append(related.R.ResponderTokenRtpRequests, o)
	}

	return nil
}

// AddRTPRequestPaymentRtps adds the given related objects to the existing relationships
// of the RtpRequest, optionally inserting them as new records.
// Appends related to o.R.RTPRequestPaymentRtps.
// Sets related.R.RTPRequest appropriately.
func (o *RtpRequest) AddRTPRequestPaymentRtps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentRtp) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.RTPRequestID, o.RTPRequestID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentRtp` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"rtp_request_id"}),
				strmangle.WhereClause("`", "`", 0, paymentRtpPrimaryKeyColumns),
			)
			values := []interface{}{o.RTPRequestID, rel.PaymentRTPID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.RTPRequestID, o.RTPRequestID)
		}
	}

	if o.R == nil {
		o.R = &rtpRequestR{
			RTPRequestPaymentRtps: related,
		}
	} else {
		o.R.RTPRequestPaymentRtps = append(o.R.RTPRequestPaymentRtps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentRtpR{
				RTPRequest: o,
			}
		} else {
			rel.R.RTPRequest = o
		}
	}
	return nil
}

// SetRTPRequestPaymentRtps removes all previously related items of the
// RtpRequest replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.RTPRequest's RTPRequestPaymentRtps accordingly.
// Replaces o.R.RTPRequestPaymentRtps with related.
// Sets related.R.RTPRequest's RTPRequestPaymentRtps accordingly.
func (o *RtpRequest) SetRTPRequestPaymentRtps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentRtp) error {
	query := "update `PaymentRtp` set `rtp_request_id` = null where `rtp_request_id` = ?"
	values := []interface{}{o.RTPRequestID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.RTPRequestPaymentRtps {
			queries.SetScanner(&rel.RTPRequestID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.RTPRequest = nil
		}

		o.R.RTPRequestPaymentRtps = nil
	}
	return o.AddRTPRequestPaymentRtps(ctx, exec, insert, related...)
}

// RemoveRTPRequestPaymentRtps relationships from objects passed in.
// Removes related items from R.RTPRequestPaymentRtps (uses pointer comparison, removal does not keep order)
// Sets related.R.RTPRequest.
func (o *RtpRequest) RemoveRTPRequestPaymentRtps(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentRtp) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.RTPRequestID, nil)
		if rel.R != nil {
			rel.R.RTPRequest = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("rtp_request_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.RTPRequestPaymentRtps {
			if rel != ri {
				continue
			}

			ln := len(o.R.RTPRequestPaymentRtps)
			if ln > 1 && i < ln-1 {
				o.R.RTPRequestPaymentRtps[i] = o.R.RTPRequestPaymentRtps[ln-1]
			}
			o.R.RTPRequestPaymentRtps = o.R.RTPRequestPaymentRtps[:ln-1]
			break
		}
	}

	return nil
}

// RtpRequests retrieves all the records using an executor.
func RtpRequests(mods ...qm.QueryMod) rtpRequestQuery {
	mods = append(mods, qm.From("`RtpRequest`"))
	return rtpRequestQuery{NewQuery(mods...)}
}

// FindRtpRequest retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindRtpRequest(ctx context.Context, exec boil.ContextExecutor, rTPRequestID int, selectCols ...string) (*RtpRequest, error) {
	rtpRequestObj := &RtpRequest{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `RtpRequest` where `rtp_request_id`=?", sel,
	)

	q := queries.Raw(query, rTPRequestID)

	err := q.Bind(ctx, exec, rtpRequestObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from RtpRequest")
	}

	return rtpRequestObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *RtpRequest) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no RtpRequest provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rtpRequestColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	rtpRequestInsertCacheMut.RLock()
	cache, cached := rtpRequestInsertCache[key]
	rtpRequestInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			rtpRequestColumns,
			rtpRequestColumnsWithDefault,
			rtpRequestColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `RtpRequest` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `RtpRequest` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `RtpRequest` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into RtpRequest")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.RTPRequestID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == rtpRequestMapping["RTPRequestID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.RTPRequestID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for RtpRequest")
	}

CacheNoHooks:
	if !cached {
		rtpRequestInsertCacheMut.Lock()
		rtpRequestInsertCache[key] = cache
		rtpRequestInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the RtpRequest.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *RtpRequest) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	rtpRequestUpdateCacheMut.RLock()
	cache, cached := rtpRequestUpdateCache[key]
	rtpRequestUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			rtpRequestColumns,
			rtpRequestPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update RtpRequest, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `RtpRequest` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, rtpRequestPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, append(wl, rtpRequestPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update RtpRequest row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for RtpRequest")
	}

	if !cached {
		rtpRequestUpdateCacheMut.Lock()
		rtpRequestUpdateCache[key] = cache
		rtpRequestUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q rtpRequestQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for RtpRequest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for RtpRequest")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o RtpRequestSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rtpRequestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `RtpRequest` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rtpRequestPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in rtpRequest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all rtpRequest")
	}
	return rowsAff, nil
}

var mySQLRtpRequestUniqueColumns = []string{
	"rtp_request_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *RtpRequest) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no RtpRequest provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rtpRequestColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLRtpRequestUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	rtpRequestUpsertCacheMut.RLock()
	cache, cached := rtpRequestUpsertCache[key]
	rtpRequestUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			rtpRequestColumns,
			rtpRequestColumnsWithDefault,
			rtpRequestColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			rtpRequestColumns,
			rtpRequestPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert RtpRequest, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "RtpRequest", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `RtpRequest` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for RtpRequest")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.RTPRequestID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == rtpRequestMapping["rtp_request_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(rtpRequestType, rtpRequestMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for RtpRequest")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for RtpRequest")
	}

CacheNoHooks:
	if !cached {
		rtpRequestUpsertCacheMut.Lock()
		rtpRequestUpsertCache[key] = cache
		rtpRequestUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single RtpRequest record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *RtpRequest) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no RtpRequest provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), rtpRequestPrimaryKeyMapping)
	sql := "DELETE FROM `RtpRequest` WHERE `rtp_request_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from RtpRequest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for RtpRequest")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q rtpRequestQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no rtpRequestQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from RtpRequest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for RtpRequest")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o RtpRequestSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no RtpRequest slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(rtpRequestBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rtpRequestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `RtpRequest` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rtpRequestPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from rtpRequest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for RtpRequest")
	}

	if len(rtpRequestAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *RtpRequest) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindRtpRequest(ctx, exec, o.RTPRequestID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RtpRequestSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := RtpRequestSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rtpRequestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `RtpRequest`.* FROM `RtpRequest` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rtpRequestPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in RtpRequestSlice")
	}

	*o = slice

	return nil
}

// RtpRequestExists checks if the RtpRequest row exists.
func RtpRequestExists(ctx context.Context, exec boil.ContextExecutor, rTPRequestID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `RtpRequest` where `rtp_request_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, rTPRequestID)
	}

	row := exec.QueryRowContext(ctx, sql, rTPRequestID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if RtpRequest exists")
	}

	return exists, nil
}
