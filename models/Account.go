// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Account is an object representing the database table.
type Account struct {
	AccountID               int               `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	SchemeName              string            `boil:"scheme_name" json:"scheme_name" toml:"scheme_name" yaml:"scheme_name"`
	AccountIdentification   string            `boil:"account_identification" json:"account_identification" toml:"account_identification" yaml:"account_identification"`
	SecondaryIdentification string            `boil:"secondary_identification" json:"secondary_identification" toml:"secondary_identification" yaml:"secondary_identification"`
	BankID                  int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	BranchID                int               `boil:"branch_id" json:"branch_id" toml:"branch_id" yaml:"branch_id"`
	AccountName             string            `boil:"account_name" json:"account_name" toml:"account_name" yaml:"account_name"`
	Nickname                string            `boil:"nickname" json:"nickname" toml:"nickname" yaml:"nickname"`
	ProductID               int               `boil:"product_id" json:"product_id" toml:"product_id" yaml:"product_id"`
	AccountCurrency         string            `boil:"account_currency" json:"account_currency" toml:"account_currency" yaml:"account_currency"`
	Balance                 types.Decimal     `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	Status                  string            `boil:"status" json:"status" toml:"status" yaml:"status"`
	TypeOfBalance           string            `boil:"type_of_balance" json:"type_of_balance" toml:"type_of_balance" yaml:"type_of_balance"`
	AccountOpeningDate      time.Time         `boil:"account_opening_date" json:"account_opening_date" toml:"account_opening_date" yaml:"account_opening_date"`
	AccountClosingDate      time.Time         `boil:"account_closing_date" json:"account_closing_date" toml:"account_closing_date" yaml:"account_closing_date"`
	AccountTypeID           int               `boil:"account_type_id" json:"account_type_id" toml:"account_type_id" yaml:"account_type_id"`
	Accountrefnumber        string            `boil:"accountrefnumber" json:"accountrefnumber" toml:"accountrefnumber" yaml:"accountrefnumber"`
	Isjointaccount          null.String       `boil:"isjointaccount" json:"isjointaccount,omitempty" toml:"isjointaccount" yaml:"isjointaccount,omitempty"`
	Isonlineaccessenabled   null.String       `boil:"isonlineaccessenabled" json:"isonlineaccessenabled,omitempty" toml:"isonlineaccessenabled" yaml:"isonlineaccessenabled,omitempty"`
	Usage                   null.String       `boil:"usage" json:"usage,omitempty" toml:"usage" yaml:"usage,omitempty"`
	NomineeName             null.String       `boil:"nominee_name" json:"nominee_name,omitempty" toml:"nominee_name" yaml:"nominee_name,omitempty"`
	NomineeAddress          null.String       `boil:"nominee_address" json:"nominee_address,omitempty" toml:"nominee_address" yaml:"nominee_address,omitempty"`
	NomineePhoneNo          null.String       `boil:"nominee_phone_no" json:"nominee_phone_no,omitempty" toml:"nominee_phone_no" yaml:"nominee_phone_no,omitempty"`
	NomineeDob              null.Time         `boil:"nominee_dob" json:"nominee_dob,omitempty" toml:"nominee_dob" yaml:"nominee_dob,omitempty"`
	NomineeRelatonship      null.String       `boil:"nominee_relatonship" json:"nominee_relatonship,omitempty" toml:"nominee_relatonship" yaml:"nominee_relatonship,omitempty"`
	CardFacility            null.String       `boil:"card_facility" json:"card_facility,omitempty" toml:"card_facility" yaml:"card_facility,omitempty"`
	PassbookFacility        null.String       `boil:"passbook_facility" json:"passbook_facility,omitempty" toml:"passbook_facility" yaml:"passbook_facility,omitempty"`
	ChequebookFacility      null.String       `boil:"chequebook_facility" json:"chequebook_facility,omitempty" toml:"chequebook_facility" yaml:"chequebook_facility,omitempty"`
	Frozen                  null.String       `boil:"frozen" json:"frozen,omitempty" toml:"frozen" yaml:"frozen,omitempty"`
	NoDebit                 null.String       `boil:"no_debit" json:"no_debit,omitempty" toml:"no_debit" yaml:"no_debit,omitempty"`
	NoCredit                null.String       `boil:"no_credit" json:"no_credit,omitempty" toml:"no_credit" yaml:"no_credit,omitempty"`
	CreditDebitIndicator    null.String       `boil:"credit_debit_indicator" json:"credit_debit_indicator,omitempty" toml:"credit_debit_indicator" yaml:"credit_debit_indicator,omitempty"`
	CreditLineType          null.String       `boil:"credit_line_type" json:"credit_line_type,omitempty" toml:"credit_line_type" yaml:"credit_line_type,omitempty"`
	MakerDate               time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate             null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                 string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID               null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy              null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate            null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`
	AccountRiskScore        types.NullDecimal `boil:"account_risk_score" json:"account_risk_score,omitempty" toml:"account_risk_score" yaml:"account_risk_score,omitempty"`

	R *accountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountColumns = struct {
	AccountID               string
	SchemeName              string
	AccountIdentification   string
	SecondaryIdentification string
	BankID                  string
	BranchID                string
	AccountName             string
	Nickname                string
	ProductID               string
	AccountCurrency         string
	Balance                 string
	Status                  string
	TypeOfBalance           string
	AccountOpeningDate      string
	AccountClosingDate      string
	AccountTypeID           string
	Accountrefnumber        string
	Isjointaccount          string
	Isonlineaccessenabled   string
	Usage                   string
	NomineeName             string
	NomineeAddress          string
	NomineePhoneNo          string
	NomineeDob              string
	NomineeRelatonship      string
	CardFacility            string
	PassbookFacility        string
	ChequebookFacility      string
	Frozen                  string
	NoDebit                 string
	NoCredit                string
	CreditDebitIndicator    string
	CreditLineType          string
	MakerDate               string
	CheckerDate             string
	MakerID                 string
	CheckerID               string
	ModifiedBy              string
	ModifiedDate            string
	AccountRiskScore        string
}{
	AccountID:               "account_id",
	SchemeName:              "scheme_name",
	AccountIdentification:   "account_identification",
	SecondaryIdentification: "secondary_identification",
	BankID:                  "bank_id",
	BranchID:                "branch_id",
	AccountName:             "account_name",
	Nickname:                "nickname",
	ProductID:               "product_id",
	AccountCurrency:         "account_currency",
	Balance:                 "balance",
	Status:                  "status",
	TypeOfBalance:           "type_of_balance",
	AccountOpeningDate:      "account_opening_date",
	AccountClosingDate:      "account_closing_date",
	AccountTypeID:           "account_type_id",
	Accountrefnumber:        "accountrefnumber",
	Isjointaccount:          "isjointaccount",
	Isonlineaccessenabled:   "isonlineaccessenabled",
	Usage:                   "usage",
	NomineeName:             "nominee_name",
	NomineeAddress:          "nominee_address",
	NomineePhoneNo:          "nominee_phone_no",
	NomineeDob:              "nominee_dob",
	NomineeRelatonship:      "nominee_relatonship",
	CardFacility:            "card_facility",
	PassbookFacility:        "passbook_facility",
	ChequebookFacility:      "chequebook_facility",
	Frozen:                  "frozen",
	NoDebit:                 "no_debit",
	NoCredit:                "no_credit",
	CreditDebitIndicator:    "credit_debit_indicator",
	CreditLineType:          "credit_line_type",
	MakerDate:               "maker_date",
	CheckerDate:             "checker_date",
	MakerID:                 "maker_id",
	CheckerID:               "checker_id",
	ModifiedBy:              "modified_by",
	ModifiedDate:            "modified_date",
	AccountRiskScore:        "account_risk_score",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var AccountWhere = struct {
	AccountID               whereHelperint
	SchemeName              whereHelperstring
	AccountIdentification   whereHelperstring
	SecondaryIdentification whereHelperstring
	BankID                  whereHelperint
	BranchID                whereHelperint
	AccountName             whereHelperstring
	Nickname                whereHelperstring
	ProductID               whereHelperint
	AccountCurrency         whereHelperstring
	Balance                 whereHelpertypes_Decimal
	Status                  whereHelperstring
	TypeOfBalance           whereHelperstring
	AccountOpeningDate      whereHelpertime_Time
	AccountClosingDate      whereHelpertime_Time
	AccountTypeID           whereHelperint
	Accountrefnumber        whereHelperstring
	Isjointaccount          whereHelpernull_String
	Isonlineaccessenabled   whereHelpernull_String
	Usage                   whereHelpernull_String
	NomineeName             whereHelpernull_String
	NomineeAddress          whereHelpernull_String
	NomineePhoneNo          whereHelpernull_String
	NomineeDob              whereHelpernull_Time
	NomineeRelatonship      whereHelpernull_String
	CardFacility            whereHelpernull_String
	PassbookFacility        whereHelpernull_String
	ChequebookFacility      whereHelpernull_String
	Frozen                  whereHelpernull_String
	NoDebit                 whereHelpernull_String
	NoCredit                whereHelpernull_String
	CreditDebitIndicator    whereHelpernull_String
	CreditLineType          whereHelpernull_String
	MakerDate               whereHelpertime_Time
	CheckerDate             whereHelpernull_Time
	MakerID                 whereHelperstring
	CheckerID               whereHelpernull_String
	ModifiedBy              whereHelpernull_String
	ModifiedDate            whereHelpernull_Time
	AccountRiskScore        whereHelpertypes_NullDecimal
}{
	AccountID:               whereHelperint{field: `account_id`},
	SchemeName:              whereHelperstring{field: `scheme_name`},
	AccountIdentification:   whereHelperstring{field: `account_identification`},
	SecondaryIdentification: whereHelperstring{field: `secondary_identification`},
	BankID:                  whereHelperint{field: `bank_id`},
	BranchID:                whereHelperint{field: `branch_id`},
	AccountName:             whereHelperstring{field: `account_name`},
	Nickname:                whereHelperstring{field: `nickname`},
	ProductID:               whereHelperint{field: `product_id`},
	AccountCurrency:         whereHelperstring{field: `account_currency`},
	Balance:                 whereHelpertypes_Decimal{field: `balance`},
	Status:                  whereHelperstring{field: `status`},
	TypeOfBalance:           whereHelperstring{field: `type_of_balance`},
	AccountOpeningDate:      whereHelpertime_Time{field: `account_opening_date`},
	AccountClosingDate:      whereHelpertime_Time{field: `account_closing_date`},
	AccountTypeID:           whereHelperint{field: `account_type_id`},
	Accountrefnumber:        whereHelperstring{field: `accountrefnumber`},
	Isjointaccount:          whereHelpernull_String{field: `isjointaccount`},
	Isonlineaccessenabled:   whereHelpernull_String{field: `isonlineaccessenabled`},
	Usage:                   whereHelpernull_String{field: `usage`},
	NomineeName:             whereHelpernull_String{field: `nominee_name`},
	NomineeAddress:          whereHelpernull_String{field: `nominee_address`},
	NomineePhoneNo:          whereHelpernull_String{field: `nominee_phone_no`},
	NomineeDob:              whereHelpernull_Time{field: `nominee_dob`},
	NomineeRelatonship:      whereHelpernull_String{field: `nominee_relatonship`},
	CardFacility:            whereHelpernull_String{field: `card_facility`},
	PassbookFacility:        whereHelpernull_String{field: `passbook_facility`},
	ChequebookFacility:      whereHelpernull_String{field: `chequebook_facility`},
	Frozen:                  whereHelpernull_String{field: `frozen`},
	NoDebit:                 whereHelpernull_String{field: `no_debit`},
	NoCredit:                whereHelpernull_String{field: `no_credit`},
	CreditDebitIndicator:    whereHelpernull_String{field: `credit_debit_indicator`},
	CreditLineType:          whereHelpernull_String{field: `credit_line_type`},
	MakerDate:               whereHelpertime_Time{field: `maker_date`},
	CheckerDate:             whereHelpernull_Time{field: `checker_date`},
	MakerID:                 whereHelperstring{field: `maker_id`},
	CheckerID:               whereHelpernull_String{field: `checker_id`},
	ModifiedBy:              whereHelpernull_String{field: `modified_by`},
	ModifiedDate:            whereHelpernull_Time{field: `modified_date`},
	AccountRiskScore:        whereHelpertypes_NullDecimal{field: `account_risk_score`},
}

// AccountRels is where relationship names are stored.
var AccountRels = struct {
	Bank                               string
	Product                            string
	AccountType                        string
	Branch                             string
	AccountAccountCreditLines          string
	FromAccountAccountLinks            string
	ToAccountAccountLinks              string
	AccountAccountOwners               string
	AccountAccountRequestHistories     string
	DebtorAccountBeneficiaries         string
	PayeeAccountBillers                string
	AccountCustomerOffers              string
	DebtorAccountDirectDebits          string
	AccountFundConfirmations           string
	AccountFxDeals                     string
	AccountJournalEntryLines           string
	AccountLoans                       string
	AccountOBPFundConfirmationConsents string
	FromAccountPaymentAches            string
	ToAccountPaymentAches              string
	FromAccountPaymentBills            string
	AcountPaymentLimits                string
	FromAccountPaymentWires            string
	ToAccountPaymentWires              string
	AccountPortfolios                  string
	PayeeAccountRegisteredBillers      string
	AccountRTPS                        string
	AccountSchedulePayments            string
	DebtorAccountStandingOrders        string
	AccountStatements                  string
	AccountTFParties                   string
	AccountTFPartyTxns                 string
	AccountTransactions                string
	FromAccountTransferAches           string
	ToAccountTransferAches             string
	FromAccountTransferWires           string
	ToAccountTransferWires             string
}{
	Bank:                               "Bank",
	Product:                            "Product",
	AccountType:                        "AccountType",
	Branch:                             "Branch",
	AccountAccountCreditLines:          "AccountAccountCreditLines",
	FromAccountAccountLinks:            "FromAccountAccountLinks",
	ToAccountAccountLinks:              "ToAccountAccountLinks",
	AccountAccountOwners:               "AccountAccountOwners",
	AccountAccountRequestHistories:     "AccountAccountRequestHistories",
	DebtorAccountBeneficiaries:         "DebtorAccountBeneficiaries",
	PayeeAccountBillers:                "PayeeAccountBillers",
	AccountCustomerOffers:              "AccountCustomerOffers",
	DebtorAccountDirectDebits:          "DebtorAccountDirectDebits",
	AccountFundConfirmations:           "AccountFundConfirmations",
	AccountFxDeals:                     "AccountFxDeals",
	AccountJournalEntryLines:           "AccountJournalEntryLines",
	AccountLoans:                       "AccountLoans",
	AccountOBPFundConfirmationConsents: "AccountOBPFundConfirmationConsents",
	FromAccountPaymentAches:            "FromAccountPaymentAches",
	ToAccountPaymentAches:              "ToAccountPaymentAches",
	FromAccountPaymentBills:            "FromAccountPaymentBills",
	AcountPaymentLimits:                "AcountPaymentLimits",
	FromAccountPaymentWires:            "FromAccountPaymentWires",
	ToAccountPaymentWires:              "ToAccountPaymentWires",
	AccountPortfolios:                  "AccountPortfolios",
	PayeeAccountRegisteredBillers:      "PayeeAccountRegisteredBillers",
	AccountRTPS:                        "AccountRTPS",
	AccountSchedulePayments:            "AccountSchedulePayments",
	DebtorAccountStandingOrders:        "DebtorAccountStandingOrders",
	AccountStatements:                  "AccountStatements",
	AccountTFParties:                   "AccountTFParties",
	AccountTFPartyTxns:                 "AccountTFPartyTxns",
	AccountTransactions:                "AccountTransactions",
	FromAccountTransferAches:           "FromAccountTransferAches",
	ToAccountTransferAches:             "ToAccountTransferAches",
	FromAccountTransferWires:           "FromAccountTransferWires",
	ToAccountTransferWires:             "ToAccountTransferWires",
}

// accountR is where relationships are stored.
type accountR struct {
	Bank                               *Bank
	Product                            *Product
	AccountType                        *AccountType
	Branch                             *Branch
	AccountAccountCreditLines          AccountCreditLineSlice
	FromAccountAccountLinks            AccountLinkSlice
	ToAccountAccountLinks              AccountLinkSlice
	AccountAccountOwners               AccountOwnerSlice
	AccountAccountRequestHistories     AccountRequestHistorySlice
	DebtorAccountBeneficiaries         BeneficiarySlice
	PayeeAccountBillers                BillerSlice
	AccountCustomerOffers              CustomerOfferSlice
	DebtorAccountDirectDebits          DirectDebitSlice
	AccountFundConfirmations           FundConfirmationSlice
	AccountFxDeals                     FxDealSlice
	AccountJournalEntryLines           JournalEntryLineSlice
	AccountLoans                       LoanSlice
	AccountOBPFundConfirmationConsents OBPFundConfirmationConsentSlice
	FromAccountPaymentAches            PaymentAchSlice
	ToAccountPaymentAches              PaymentAchSlice
	FromAccountPaymentBills            PaymentBillSlice
	AcountPaymentLimits                PaymentLimitSlice
	FromAccountPaymentWires            PaymentWireSlice
	ToAccountPaymentWires              PaymentWireSlice
	AccountPortfolios                  PortfolioSlice
	PayeeAccountRegisteredBillers      RegisteredBillerSlice
	AccountRTPS                        RTPSlice
	AccountSchedulePayments            SchedulePaymentSlice
	DebtorAccountStandingOrders        StandingOrderSlice
	AccountStatements                  StatementSlice
	AccountTFParties                   TFPartySlice
	AccountTFPartyTxns                 TFPartyTxnSlice
	AccountTransactions                TransactionSlice
	FromAccountTransferAches           TransferAchSlice
	ToAccountTransferAches             TransferAchSlice
	FromAccountTransferWires           TransferWireSlice
	ToAccountTransferWires             TransferWireSlice
}

// NewStruct creates a new relationship struct
func (*accountR) NewStruct() *accountR {
	return &accountR{}
}

// accountL is where Load methods for each relationship are stored.
type accountL struct{}

var (
	accountColumns               = []string{"account_id", "scheme_name", "account_identification", "secondary_identification", "bank_id", "branch_id", "account_name", "nickname", "product_id", "account_currency", "balance", "status", "type_of_balance", "account_opening_date", "account_closing_date", "account_type_id", "accountrefnumber", "isjointaccount", "isonlineaccessenabled", "usage", "nominee_name", "nominee_address", "nominee_phone_no", "nominee_dob", "nominee_relatonship", "card_facility", "passbook_facility", "chequebook_facility", "frozen", "no_debit", "no_credit", "credit_debit_indicator", "credit_line_type", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "account_risk_score"}
	accountColumnsWithoutDefault = []string{"scheme_name", "account_identification", "secondary_identification", "bank_id", "branch_id", "account_name", "nickname", "product_id", "account_currency", "balance", "status", "type_of_balance", "account_opening_date", "account_closing_date", "account_type_id", "accountrefnumber", "isjointaccount", "isonlineaccessenabled", "usage", "nominee_name", "nominee_address", "nominee_phone_no", "nominee_dob", "nominee_relatonship", "card_facility", "passbook_facility", "chequebook_facility", "frozen", "no_debit", "no_credit", "credit_debit_indicator", "credit_line_type", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date", "account_risk_score"}
	accountColumnsWithDefault    = []string{"account_id"}
	accountPrimaryKeyColumns     = []string{"account_id"}
)

type (
	// AccountSlice is an alias for a slice of pointers to Account.
	// This should generally be used opposed to []Account.
	AccountSlice []*Account
	// AccountHook is the signature for custom Account hook methods
	AccountHook func(context.Context, boil.ContextExecutor, *Account) error

	accountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountType                 = reflect.TypeOf(&Account{})
	accountMapping              = queries.MakeStructMapping(accountType)
	accountPrimaryKeyMapping, _ = queries.BindMapping(accountType, accountMapping, accountPrimaryKeyColumns)
	accountInsertCacheMut       sync.RWMutex
	accountInsertCache          = make(map[string]insertCache)
	accountUpdateCacheMut       sync.RWMutex
	accountUpdateCache          = make(map[string]updateCache)
	accountUpsertCacheMut       sync.RWMutex
	accountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var accountBeforeInsertHooks []AccountHook
var accountBeforeUpdateHooks []AccountHook
var accountBeforeDeleteHooks []AccountHook
var accountBeforeUpsertHooks []AccountHook

var accountAfterInsertHooks []AccountHook
var accountAfterSelectHooks []AccountHook
var accountAfterUpdateHooks []AccountHook
var accountAfterDeleteHooks []AccountHook
var accountAfterUpsertHooks []AccountHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Account) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Account) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Account) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Account) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Account) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Account) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Account) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Account) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Account) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAccountHook registers your hook function for all future operations.
func AddAccountHook(hookPoint boil.HookPoint, accountHook AccountHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		accountBeforeInsertHooks = append(accountBeforeInsertHooks, accountHook)
	case boil.BeforeUpdateHook:
		accountBeforeUpdateHooks = append(accountBeforeUpdateHooks, accountHook)
	case boil.BeforeDeleteHook:
		accountBeforeDeleteHooks = append(accountBeforeDeleteHooks, accountHook)
	case boil.BeforeUpsertHook:
		accountBeforeUpsertHooks = append(accountBeforeUpsertHooks, accountHook)
	case boil.AfterInsertHook:
		accountAfterInsertHooks = append(accountAfterInsertHooks, accountHook)
	case boil.AfterSelectHook:
		accountAfterSelectHooks = append(accountAfterSelectHooks, accountHook)
	case boil.AfterUpdateHook:
		accountAfterUpdateHooks = append(accountAfterUpdateHooks, accountHook)
	case boil.AfterDeleteHook:
		accountAfterDeleteHooks = append(accountAfterDeleteHooks, accountHook)
	case boil.AfterUpsertHook:
		accountAfterUpsertHooks = append(accountAfterUpsertHooks, accountHook)
	}
}

// One returns a single account record from the query.
func (q accountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Account, error) {
	o := &Account{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Account")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Account records from the query.
func (q accountQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountSlice, error) {
	var o []*Account

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Account slice")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Account records in the query.
func (q accountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Account rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Account exists")
	}

	return count > 0, nil
}

// Bank pointed to by the foreign key.
func (o *Account) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// Product pointed to by the foreign key.
func (o *Account) Product(mods ...qm.QueryMod) productQuery {
	queryMods := []qm.QueryMod{
		qm.Where("product_id=?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	query := Products(queryMods...)
	queries.SetFrom(query.Query, "`Product`")

	return query
}

// AccountType pointed to by the foreign key.
func (o *Account) AccountType(mods ...qm.QueryMod) accountTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("account_type_id=?", o.AccountTypeID),
	}

	queryMods = append(queryMods, mods...)

	query := AccountTypes(queryMods...)
	queries.SetFrom(query.Query, "`AccountType`")

	return query
}

// Branch pointed to by the foreign key.
func (o *Account) Branch(mods ...qm.QueryMod) branchQuery {
	queryMods := []qm.QueryMod{
		qm.Where("branch_id=?", o.BranchID),
	}

	queryMods = append(queryMods, mods...)

	query := Branches(queryMods...)
	queries.SetFrom(query.Query, "`Branches`")

	return query
}

// AccountAccountCreditLines retrieves all the AccountCreditLine's AccountCreditLines with an executor via account_id column.
func (o *Account) AccountAccountCreditLines(mods ...qm.QueryMod) accountCreditLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountCreditLine`.`account_id`=?", o.AccountID),
	)

	query := AccountCreditLines(queryMods...)
	queries.SetFrom(query.Query, "`AccountCreditLine`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountCreditLine`.*"})
	}

	return query
}

// FromAccountAccountLinks retrieves all the AccountLink's AccountLinks with an executor via from_account_id column.
func (o *Account) FromAccountAccountLinks(mods ...qm.QueryMod) accountLinkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountLink`.`from_account_id`=?", o.AccountID),
	)

	query := AccountLinks(queryMods...)
	queries.SetFrom(query.Query, "`AccountLink`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountLink`.*"})
	}

	return query
}

// ToAccountAccountLinks retrieves all the AccountLink's AccountLinks with an executor via to_account_id column.
func (o *Account) ToAccountAccountLinks(mods ...qm.QueryMod) accountLinkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountLink`.`to_account_id`=?", o.AccountID),
	)

	query := AccountLinks(queryMods...)
	queries.SetFrom(query.Query, "`AccountLink`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountLink`.*"})
	}

	return query
}

// AccountAccountOwners retrieves all the AccountOwner's AccountOwners with an executor via account_id column.
func (o *Account) AccountAccountOwners(mods ...qm.QueryMod) accountOwnerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountOwners`.`account_id`=?", o.AccountID),
	)

	query := AccountOwners(queryMods...)
	queries.SetFrom(query.Query, "`AccountOwners`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountOwners`.*"})
	}

	return query
}

// AccountAccountRequestHistories retrieves all the AccountRequestHistory's AccountRequestHistories with an executor via account_id column.
func (o *Account) AccountAccountRequestHistories(mods ...qm.QueryMod) accountRequestHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountRequestHistory`.`account_id`=?", o.AccountID),
	)

	query := AccountRequestHistories(queryMods...)
	queries.SetFrom(query.Query, "`AccountRequestHistory`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountRequestHistory`.*"})
	}

	return query
}

// DebtorAccountBeneficiaries retrieves all the Beneficiary's Beneficiaries with an executor via debtor_account_id column.
func (o *Account) DebtorAccountBeneficiaries(mods ...qm.QueryMod) beneficiaryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Beneficiary`.`debtor_account_id`=?", o.AccountID),
	)

	query := Beneficiaries(queryMods...)
	queries.SetFrom(query.Query, "`Beneficiary`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Beneficiary`.*"})
	}

	return query
}

// PayeeAccountBillers retrieves all the Biller's Billers with an executor via payee_account_id column.
func (o *Account) PayeeAccountBillers(mods ...qm.QueryMod) billerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Biller`.`payee_account_id`=?", o.AccountID),
	)

	query := Billers(queryMods...)
	queries.SetFrom(query.Query, "`Biller`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Biller`.*"})
	}

	return query
}

// AccountCustomerOffers retrieves all the CustomerOffer's CustomerOffers with an executor via account_id column.
func (o *Account) AccountCustomerOffers(mods ...qm.QueryMod) customerOfferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CustomerOffer`.`account_id`=?", o.AccountID),
	)

	query := CustomerOffers(queryMods...)
	queries.SetFrom(query.Query, "`CustomerOffer`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CustomerOffer`.*"})
	}

	return query
}

// DebtorAccountDirectDebits retrieves all the DirectDebit's DirectDebits with an executor via debtor_account_id column.
func (o *Account) DebtorAccountDirectDebits(mods ...qm.QueryMod) directDebitQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`DirectDebits`.`debtor_account_id`=?", o.AccountID),
	)

	query := DirectDebits(queryMods...)
	queries.SetFrom(query.Query, "`DirectDebits`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`DirectDebits`.*"})
	}

	return query
}

// AccountFundConfirmations retrieves all the FundConfirmation's FundConfirmations with an executor via account_id column.
func (o *Account) AccountFundConfirmations(mods ...qm.QueryMod) fundConfirmationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`FundConfirmation`.`account_id`=?", o.AccountID),
	)

	query := FundConfirmations(queryMods...)
	queries.SetFrom(query.Query, "`FundConfirmation`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`FundConfirmation`.*"})
	}

	return query
}

// AccountFxDeals retrieves all the FxDeal's FxDeals with an executor via account_id column.
func (o *Account) AccountFxDeals(mods ...qm.QueryMod) fxDealQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`FxDeals`.`account_id`=?", o.AccountID),
	)

	query := FxDeals(queryMods...)
	queries.SetFrom(query.Query, "`FxDeals`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`FxDeals`.*"})
	}

	return query
}

// AccountJournalEntryLines retrieves all the JournalEntryLine's JournalEntryLines with an executor via account_id column.
func (o *Account) AccountJournalEntryLines(mods ...qm.QueryMod) journalEntryLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JournalEntryLine`.`account_id`=?", o.AccountID),
	)

	query := JournalEntryLines(queryMods...)
	queries.SetFrom(query.Query, "`JournalEntryLine`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JournalEntryLine`.*"})
	}

	return query
}

// AccountLoans retrieves all the Loan's Loans with an executor via account_id column.
func (o *Account) AccountLoans(mods ...qm.QueryMod) loanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Loan`.`account_id`=?", o.AccountID),
	)

	query := Loans(queryMods...)
	queries.SetFrom(query.Query, "`Loan`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Loan`.*"})
	}

	return query
}

// AccountOBPFundConfirmationConsents retrieves all the OBPFundConfirmationConsent's OBPFundConfirmationConsents with an executor via account_id column.
func (o *Account) AccountOBPFundConfirmationConsents(mods ...qm.QueryMod) oBPFundConfirmationConsentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`OBPFundConfirmationConsent`.`account_id`=?", o.AccountID),
	)

	query := OBPFundConfirmationConsents(queryMods...)
	queries.SetFrom(query.Query, "`OBPFundConfirmationConsent`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`OBPFundConfirmationConsent`.*"})
	}

	return query
}

// FromAccountPaymentAches retrieves all the PaymentAch's PaymentAches with an executor via from_account_id column.
func (o *Account) FromAccountPaymentAches(mods ...qm.QueryMod) paymentAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentAch`.`from_account_id`=?", o.AccountID),
	)

	query := PaymentAches(queryMods...)
	queries.SetFrom(query.Query, "`PaymentAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentAch`.*"})
	}

	return query
}

// ToAccountPaymentAches retrieves all the PaymentAch's PaymentAches with an executor via to_account_id column.
func (o *Account) ToAccountPaymentAches(mods ...qm.QueryMod) paymentAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentAch`.`to_account_id`=?", o.AccountID),
	)

	query := PaymentAches(queryMods...)
	queries.SetFrom(query.Query, "`PaymentAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentAch`.*"})
	}

	return query
}

// FromAccountPaymentBills retrieves all the PaymentBill's PaymentBills with an executor via from_account_id column.
func (o *Account) FromAccountPaymentBills(mods ...qm.QueryMod) paymentBillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentBill`.`from_account_id`=?", o.AccountID),
	)

	query := PaymentBills(queryMods...)
	queries.SetFrom(query.Query, "`PaymentBill`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentBill`.*"})
	}

	return query
}

// AcountPaymentLimits retrieves all the PaymentLimit's PaymentLimits with an executor via acount_id column.
func (o *Account) AcountPaymentLimits(mods ...qm.QueryMod) paymentLimitQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentLimit`.`acount_id`=?", o.AccountID),
	)

	query := PaymentLimits(queryMods...)
	queries.SetFrom(query.Query, "`PaymentLimit`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentLimit`.*"})
	}

	return query
}

// FromAccountPaymentWires retrieves all the PaymentWire's PaymentWires with an executor via from_account_id column.
func (o *Account) FromAccountPaymentWires(mods ...qm.QueryMod) paymentWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentWire`.`from_account_id`=?", o.AccountID),
	)

	query := PaymentWires(queryMods...)
	queries.SetFrom(query.Query, "`PaymentWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentWire`.*"})
	}

	return query
}

// ToAccountPaymentWires retrieves all the PaymentWire's PaymentWires with an executor via to_account_id column.
func (o *Account) ToAccountPaymentWires(mods ...qm.QueryMod) paymentWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentWire`.`to_account_id`=?", o.AccountID),
	)

	query := PaymentWires(queryMods...)
	queries.SetFrom(query.Query, "`PaymentWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentWire`.*"})
	}

	return query
}

// AccountPortfolios retrieves all the Portfolio's Portfolios with an executor via account_id column.
func (o *Account) AccountPortfolios(mods ...qm.QueryMod) portfolioQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Portfolio`.`account_id`=?", o.AccountID),
	)

	query := Portfolios(queryMods...)
	queries.SetFrom(query.Query, "`Portfolio`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Portfolio`.*"})
	}

	return query
}

// PayeeAccountRegisteredBillers retrieves all the RegisteredBiller's RegisteredBillers with an executor via payee_account_id column.
func (o *Account) PayeeAccountRegisteredBillers(mods ...qm.QueryMod) registeredBillerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`RegisteredBiller`.`payee_account_id`=?", o.AccountID),
	)

	query := RegisteredBillers(queryMods...)
	queries.SetFrom(query.Query, "`RegisteredBiller`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`RegisteredBiller`.*"})
	}

	return query
}

// AccountRTPS retrieves all the Rtp's RTPS with an executor via account_id column.
func (o *Account) AccountRTPS(mods ...qm.QueryMod) rtpQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Rtp`.`account_id`=?", o.AccountID),
	)

	query := RTPS(queryMods...)
	queries.SetFrom(query.Query, "`Rtp`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Rtp`.*"})
	}

	return query
}

// AccountSchedulePayments retrieves all the SchedulePayment's SchedulePayments with an executor via account_id column.
func (o *Account) AccountSchedulePayments(mods ...qm.QueryMod) schedulePaymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`SchedulePayment`.`account_id`=?", o.AccountID),
	)

	query := SchedulePayments(queryMods...)
	queries.SetFrom(query.Query, "`SchedulePayment`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`SchedulePayment`.*"})
	}

	return query
}

// DebtorAccountStandingOrders retrieves all the StandingOrder's StandingOrders with an executor via debtor_account_id column.
func (o *Account) DebtorAccountStandingOrders(mods ...qm.QueryMod) standingOrderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StandingOrders`.`debtor_account_id`=?", o.AccountID),
	)

	query := StandingOrders(queryMods...)
	queries.SetFrom(query.Query, "`StandingOrders`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StandingOrders`.*"})
	}

	return query
}

// AccountStatements retrieves all the Statement's Statements with an executor via account_id column.
func (o *Account) AccountStatements(mods ...qm.QueryMod) statementQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Statement`.`account_id`=?", o.AccountID),
	)

	query := Statements(queryMods...)
	queries.SetFrom(query.Query, "`Statement`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Statement`.*"})
	}

	return query
}

// AccountTFParties retrieves all the TFParty's TFParties with an executor via account_id column.
func (o *Account) AccountTFParties(mods ...qm.QueryMod) tFPartyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFParty`.`account_id`=?", o.AccountID),
	)

	query := TFParties(queryMods...)
	queries.SetFrom(query.Query, "`TFParty`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFParty`.*"})
	}

	return query
}

// AccountTFPartyTxns retrieves all the TFPartyTxn's TFPartyTxns with an executor via account_id column.
func (o *Account) AccountTFPartyTxns(mods ...qm.QueryMod) tFPartyTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFPartyTxn`.`account_id`=?", o.AccountID),
	)

	query := TFPartyTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFPartyTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFPartyTxn`.*"})
	}

	return query
}

// AccountTransactions retrieves all the Transaction's Transactions with an executor via account_id column.
func (o *Account) AccountTransactions(mods ...qm.QueryMod) transactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Transaction`.`account_id`=?", o.AccountID),
	)

	query := Transactions(queryMods...)
	queries.SetFrom(query.Query, "`Transaction`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Transaction`.*"})
	}

	return query
}

// FromAccountTransferAches retrieves all the TransferAch's TransferAches with an executor via from_account_id column.
func (o *Account) FromAccountTransferAches(mods ...qm.QueryMod) transferAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TransferAch`.`from_account_id`=?", o.AccountID),
	)

	query := TransferAches(queryMods...)
	queries.SetFrom(query.Query, "`TransferAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TransferAch`.*"})
	}

	return query
}

// ToAccountTransferAches retrieves all the TransferAch's TransferAches with an executor via to_account_id column.
func (o *Account) ToAccountTransferAches(mods ...qm.QueryMod) transferAchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TransferAch`.`to_account_id`=?", o.AccountID),
	)

	query := TransferAches(queryMods...)
	queries.SetFrom(query.Query, "`TransferAch`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TransferAch`.*"})
	}

	return query
}

// FromAccountTransferWires retrieves all the TransferWire's TransferWires with an executor via from_account_id column.
func (o *Account) FromAccountTransferWires(mods ...qm.QueryMod) transferWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TransferWire`.`from_account_id`=?", o.AccountID),
	)

	query := TransferWires(queryMods...)
	queries.SetFrom(query.Query, "`TransferWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TransferWire`.*"})
	}

	return query
}

// ToAccountTransferWires retrieves all the TransferWire's TransferWires with an executor via to_account_id column.
func (o *Account) ToAccountTransferWires(mods ...qm.QueryMod) transferWireQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TransferWire`.`to_account_id`=?", o.AccountID),
	)

	query := TransferWires(queryMods...)
	queries.SetFrom(query.Query, "`TransferWire`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TransferWire`.*"})
	}

	return query
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankAccounts = append(foreign.R.BankAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankAccounts = append(foreign.R.BankAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ProductID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ProductID {
					continue Outer
				}
			}

			args = append(args, obj.ProductID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Product`), qm.WhereIn(`product_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Product")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Product")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &productR{}
		}
		foreign.R.ProductAccounts = append(foreign.R.ProductAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductID == foreign.ProductID {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.ProductAccounts = append(foreign.R.ProductAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadAccountType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadAccountType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountTypeID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountTypeID {
					continue Outer
				}
			}

			args = append(args, obj.AccountTypeID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountType`), qm.WhereIn(`account_type_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountType")
	}

	var resultSlice []*AccountType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for AccountType")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountType")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AccountType = foreign
		if foreign.R == nil {
			foreign.R = &accountTypeR{}
		}
		foreign.R.AccountTypeAccounts = append(foreign.R.AccountTypeAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AccountTypeID == foreign.AccountTypeID {
				local.R.AccountType = foreign
				if foreign.R == nil {
					foreign.R = &accountTypeR{}
				}
				foreign.R.AccountTypeAccounts = append(foreign.R.AccountTypeAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadBranch allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountL) LoadBranch(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.BranchID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.BranchID {
					continue Outer
				}
			}

			args = append(args, obj.BranchID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Branches`), qm.WhereIn(`branch_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Branch")
	}

	var resultSlice []*Branch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Branch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Branches")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Branches")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Branch = foreign
		if foreign.R == nil {
			foreign.R = &branchR{}
		}
		foreign.R.BranchAccounts = append(foreign.R.BranchAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BranchID == foreign.BranchID {
				local.R.Branch = foreign
				if foreign.R == nil {
					foreign.R = &branchR{}
				}
				foreign.R.BranchAccounts = append(foreign.R.BranchAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadAccountAccountCreditLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountAccountCreditLines(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountCreditLine`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountCreditLine")
	}

	var resultSlice []*AccountCreditLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountCreditLine")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountCreditLine")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountCreditLine")
	}

	if len(accountCreditLineAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountAccountCreditLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountCreditLineR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.AccountID, foreign.AccountID) {
				local.R.AccountAccountCreditLines = append(local.R.AccountAccountCreditLines, foreign)
				if foreign.R == nil {
					foreign.R = &accountCreditLineR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountAccountLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountAccountLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountLink`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountLink")
	}

	var resultSlice []*AccountLink
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountLink")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountLink")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountLink")
	}

	if len(accountLinkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountAccountLinks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountLinkR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountAccountLinks = append(local.R.FromAccountAccountLinks, foreign)
				if foreign.R == nil {
					foreign.R = &accountLinkR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadToAccountAccountLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadToAccountAccountLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountLink`), qm.WhereIn(`to_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountLink")
	}

	var resultSlice []*AccountLink
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountLink")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountLink")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountLink")
	}

	if len(accountLinkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAccountAccountLinks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountLinkR{}
			}
			foreign.R.ToAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.ToAccountID {
				local.R.ToAccountAccountLinks = append(local.R.ToAccountAccountLinks, foreign)
				if foreign.R == nil {
					foreign.R = &accountLinkR{}
				}
				foreign.R.ToAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountAccountOwners allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountAccountOwners(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountOwners`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountOwners")
	}

	var resultSlice []*AccountOwner
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountOwners")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountOwners")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountOwners")
	}

	if len(accountOwnerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountAccountOwners = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountOwnerR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountAccountOwners = append(local.R.AccountAccountOwners, foreign)
				if foreign.R == nil {
					foreign.R = &accountOwnerR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountAccountRequestHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountAccountRequestHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountRequestHistory`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountRequestHistory")
	}

	var resultSlice []*AccountRequestHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountRequestHistory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountRequestHistory")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountRequestHistory")
	}

	if len(accountRequestHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountAccountRequestHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountRequestHistoryR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.AccountID, foreign.AccountID) {
				local.R.AccountAccountRequestHistories = append(local.R.AccountAccountRequestHistories, foreign)
				if foreign.R == nil {
					foreign.R = &accountRequestHistoryR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDebtorAccountBeneficiaries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDebtorAccountBeneficiaries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Beneficiary`), qm.WhereIn(`debtor_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Beneficiary")
	}

	var resultSlice []*Beneficiary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Beneficiary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Beneficiary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Beneficiary")
	}

	if len(beneficiaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DebtorAccountBeneficiaries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &beneficiaryR{}
			}
			foreign.R.DebtorAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.DebtorAccountID {
				local.R.DebtorAccountBeneficiaries = append(local.R.DebtorAccountBeneficiaries, foreign)
				if foreign.R == nil {
					foreign.R = &beneficiaryR{}
				}
				foreign.R.DebtorAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPayeeAccountBillers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadPayeeAccountBillers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Biller`), qm.WhereIn(`payee_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Biller")
	}

	var resultSlice []*Biller
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Biller")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Biller")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Biller")
	}

	if len(billerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PayeeAccountBillers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &billerR{}
			}
			foreign.R.PayeeAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.PayeeAccountID {
				local.R.PayeeAccountBillers = append(local.R.PayeeAccountBillers, foreign)
				if foreign.R == nil {
					foreign.R = &billerR{}
				}
				foreign.R.PayeeAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountCustomerOffers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountCustomerOffers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CustomerOffer`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerOffer")
	}

	var resultSlice []*CustomerOffer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerOffer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CustomerOffer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CustomerOffer")
	}

	if len(customerOfferAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountCustomerOffers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerOfferR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.AccountID, foreign.AccountID) {
				local.R.AccountCustomerOffers = append(local.R.AccountCustomerOffers, foreign)
				if foreign.R == nil {
					foreign.R = &customerOfferR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDebtorAccountDirectDebits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDebtorAccountDirectDebits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`DirectDebits`), qm.WhereIn(`debtor_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DirectDebits")
	}

	var resultSlice []*DirectDebit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DirectDebits")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on DirectDebits")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for DirectDebits")
	}

	if len(directDebitAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DebtorAccountDirectDebits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &directDebitR{}
			}
			foreign.R.DebtorAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.DebtorAccountID {
				local.R.DebtorAccountDirectDebits = append(local.R.DebtorAccountDirectDebits, foreign)
				if foreign.R == nil {
					foreign.R = &directDebitR{}
				}
				foreign.R.DebtorAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountFundConfirmations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountFundConfirmations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`FundConfirmation`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FundConfirmation")
	}

	var resultSlice []*FundConfirmation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FundConfirmation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on FundConfirmation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for FundConfirmation")
	}

	if len(fundConfirmationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountFundConfirmations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fundConfirmationR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountFundConfirmations = append(local.R.AccountFundConfirmations, foreign)
				if foreign.R == nil {
					foreign.R = &fundConfirmationR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountFxDeals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountFxDeals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`FxDeals`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FxDeals")
	}

	var resultSlice []*FxDeal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FxDeals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on FxDeals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for FxDeals")
	}

	if len(fxDealAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountFxDeals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fxDealR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountFxDeals = append(local.R.AccountFxDeals, foreign)
				if foreign.R == nil {
					foreign.R = &fxDealR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountJournalEntryLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountJournalEntryLines(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JournalEntryLine`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JournalEntryLine")
	}

	var resultSlice []*JournalEntryLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JournalEntryLine")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JournalEntryLine")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JournalEntryLine")
	}

	if len(journalEntryLineAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountJournalEntryLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &journalEntryLineR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountJournalEntryLines = append(local.R.AccountJournalEntryLines, foreign)
				if foreign.R == nil {
					foreign.R = &journalEntryLineR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountLoans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountLoans(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Loan`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Loan")
	}

	var resultSlice []*Loan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Loan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Loan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Loan")
	}

	if len(loanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountLoans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loanR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountLoans = append(local.R.AccountLoans, foreign)
				if foreign.R == nil {
					foreign.R = &loanR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountOBPFundConfirmationConsents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountOBPFundConfirmationConsents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`OBPFundConfirmationConsent`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OBPFundConfirmationConsent")
	}

	var resultSlice []*OBPFundConfirmationConsent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OBPFundConfirmationConsent")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on OBPFundConfirmationConsent")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for OBPFundConfirmationConsent")
	}

	if len(oBPFundConfirmationConsentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountOBPFundConfirmationConsents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &oBPFundConfirmationConsentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountOBPFundConfirmationConsents = append(local.R.AccountOBPFundConfirmationConsents, foreign)
				if foreign.R == nil {
					foreign.R = &oBPFundConfirmationConsentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountPaymentAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountPaymentAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentAch`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentAch")
	}

	var resultSlice []*PaymentAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentAch")
	}

	if len(paymentAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountPaymentAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAchR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountPaymentAches = append(local.R.FromAccountPaymentAches, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAchR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadToAccountPaymentAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadToAccountPaymentAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentAch`), qm.WhereIn(`to_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentAch")
	}

	var resultSlice []*PaymentAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentAch")
	}

	if len(paymentAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAccountPaymentAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentAchR{}
			}
			foreign.R.ToAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.ToAccountID {
				local.R.ToAccountPaymentAches = append(local.R.ToAccountPaymentAches, foreign)
				if foreign.R == nil {
					foreign.R = &paymentAchR{}
				}
				foreign.R.ToAccount = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountPaymentBills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountPaymentBills(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentBill`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentBill")
	}

	var resultSlice []*PaymentBill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentBill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentBill")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentBill")
	}

	if len(paymentBillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountPaymentBills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentBillR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountPaymentBills = append(local.R.FromAccountPaymentBills, foreign)
				if foreign.R == nil {
					foreign.R = &paymentBillR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAcountPaymentLimits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAcountPaymentLimits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentLimit`), qm.WhereIn(`acount_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentLimit")
	}

	var resultSlice []*PaymentLimit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentLimit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentLimit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentLimit")
	}

	if len(paymentLimitAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AcountPaymentLimits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentLimitR{}
			}
			foreign.R.Acount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AcountID {
				local.R.AcountPaymentLimits = append(local.R.AcountPaymentLimits, foreign)
				if foreign.R == nil {
					foreign.R = &paymentLimitR{}
				}
				foreign.R.Acount = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountPaymentWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountPaymentWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentWire`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentWire")
	}

	var resultSlice []*PaymentWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentWire")
	}

	if len(paymentWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountPaymentWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentWireR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountPaymentWires = append(local.R.FromAccountPaymentWires, foreign)
				if foreign.R == nil {
					foreign.R = &paymentWireR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadToAccountPaymentWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadToAccountPaymentWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentWire`), qm.WhereIn(`to_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentWire")
	}

	var resultSlice []*PaymentWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentWire")
	}

	if len(paymentWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAccountPaymentWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentWireR{}
			}
			foreign.R.ToAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.ToAccountID {
				local.R.ToAccountPaymentWires = append(local.R.ToAccountPaymentWires, foreign)
				if foreign.R == nil {
					foreign.R = &paymentWireR{}
				}
				foreign.R.ToAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountPortfolios allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountPortfolios(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Portfolio`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Portfolio")
	}

	var resultSlice []*Portfolio
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Portfolio")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Portfolio")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Portfolio")
	}

	if len(portfolioAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountPortfolios = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &portfolioR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountPortfolios = append(local.R.AccountPortfolios, foreign)
				if foreign.R == nil {
					foreign.R = &portfolioR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadPayeeAccountRegisteredBillers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadPayeeAccountRegisteredBillers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`RegisteredBiller`), qm.WhereIn(`payee_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RegisteredBiller")
	}

	var resultSlice []*RegisteredBiller
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RegisteredBiller")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on RegisteredBiller")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for RegisteredBiller")
	}

	if len(registeredBillerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PayeeAccountRegisteredBillers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &registeredBillerR{}
			}
			foreign.R.PayeeAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.PayeeAccountID {
				local.R.PayeeAccountRegisteredBillers = append(local.R.PayeeAccountRegisteredBillers, foreign)
				if foreign.R == nil {
					foreign.R = &registeredBillerR{}
				}
				foreign.R.PayeeAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountRTPS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountRTPS(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Rtp`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Rtp")
	}

	var resultSlice []*RTP
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Rtp")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Rtp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Rtp")
	}

	if len(rtpAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountRTPS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &rtpR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountRTPS = append(local.R.AccountRTPS, foreign)
				if foreign.R == nil {
					foreign.R = &rtpR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountSchedulePayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountSchedulePayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`SchedulePayment`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SchedulePayment")
	}

	var resultSlice []*SchedulePayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SchedulePayment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on SchedulePayment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for SchedulePayment")
	}

	if len(schedulePaymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountSchedulePayments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &schedulePaymentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.AccountID, foreign.AccountID) {
				local.R.AccountSchedulePayments = append(local.R.AccountSchedulePayments, foreign)
				if foreign.R == nil {
					foreign.R = &schedulePaymentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDebtorAccountStandingOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDebtorAccountStandingOrders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StandingOrders`), qm.WhereIn(`debtor_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StandingOrders")
	}

	var resultSlice []*StandingOrder
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StandingOrders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StandingOrders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StandingOrders")
	}

	if len(standingOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DebtorAccountStandingOrders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &standingOrderR{}
			}
			foreign.R.DebtorAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.DebtorAccountID {
				local.R.DebtorAccountStandingOrders = append(local.R.DebtorAccountStandingOrders, foreign)
				if foreign.R == nil {
					foreign.R = &standingOrderR{}
				}
				foreign.R.DebtorAccount = local
				break
			}
		}
	}

	return nil
}

// LoadAccountStatements allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountStatements(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Statement`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Statement")
	}

	var resultSlice []*Statement
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Statement")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Statement")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Statement")
	}

	if len(statementAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountStatements = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &statementR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountStatements = append(local.R.AccountStatements, foreign)
				if foreign.R == nil {
					foreign.R = &statementR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountTFParties allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTFParties(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFParty`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFParty")
	}

	var resultSlice []*TFParty
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFParty")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFParty")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFParty")
	}

	if len(tFPartyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountTFParties = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountTFParties = append(local.R.AccountTFParties, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountTFPartyTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTFPartyTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFPartyTxn`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFPartyTxn")
	}

	var resultSlice []*TFPartyTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFPartyTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFPartyTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFPartyTxn")
	}

	if len(tFPartyTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountTFPartyTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFPartyTxnR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountTFPartyTxns = append(local.R.AccountTFPartyTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFPartyTxnR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadAccountTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Transaction`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Transaction")
	}

	var resultSlice []*Transaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Transaction")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AccountTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transactionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.AccountID {
				local.R.AccountTransactions = append(local.R.AccountTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &transactionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountTransferAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountTransferAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TransferAch`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TransferAch")
	}

	var resultSlice []*TransferAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TransferAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TransferAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TransferAch")
	}

	if len(transferAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountTransferAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferAchR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountTransferAches = append(local.R.FromAccountTransferAches, foreign)
				if foreign.R == nil {
					foreign.R = &transferAchR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadToAccountTransferAches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadToAccountTransferAches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TransferAch`), qm.WhereIn(`to_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TransferAch")
	}

	var resultSlice []*TransferAch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TransferAch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TransferAch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TransferAch")
	}

	if len(transferAchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAccountTransferAches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferAchR{}
			}
			foreign.R.ToAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.ToAccountID {
				local.R.ToAccountTransferAches = append(local.R.ToAccountTransferAches, foreign)
				if foreign.R == nil {
					foreign.R = &transferAchR{}
				}
				foreign.R.ToAccount = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountTransferWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountTransferWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TransferWire`), qm.WhereIn(`from_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TransferWire")
	}

	var resultSlice []*TransferWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TransferWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TransferWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TransferWire")
	}

	if len(transferWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FromAccountTransferWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferWireR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.FromAccountID {
				local.R.FromAccountTransferWires = append(local.R.FromAccountTransferWires, foreign)
				if foreign.R == nil {
					foreign.R = &transferWireR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadToAccountTransferWires allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadToAccountTransferWires(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.AccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TransferWire`), qm.WhereIn(`to_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TransferWire")
	}

	var resultSlice []*TransferWire
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TransferWire")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TransferWire")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TransferWire")
	}

	if len(transferWireAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToAccountTransferWires = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferWireR{}
			}
			foreign.R.ToAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AccountID == foreign.ToAccountID {
				local.R.ToAccountTransferWires = append(local.R.ToAccountTransferWires, foreign)
				if foreign.R == nil {
					foreign.R = &transferWireR{}
				}
				foreign.R.ToAccount = local
				break
			}
		}
	}

	return nil
}

// SetBank of the account to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankAccounts.
func (o *Account) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Account` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.AccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &accountR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankAccounts: AccountSlice{o},
		}
	} else {
		related.R.BankAccounts = append(related.R.BankAccounts, o)
	}

	return nil
}

// SetProduct of the account to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.ProductAccounts.
func (o *Account) SetProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Product) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Account` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"product_id"}),
		strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductID, o.AccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductID = related.ProductID
	if o.R == nil {
		o.R = &accountR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &productR{
			ProductAccounts: AccountSlice{o},
		}
	} else {
		related.R.ProductAccounts = append(related.R.ProductAccounts, o)
	}

	return nil
}

// SetAccountType of the account to the related item.
// Sets o.R.AccountType to related.
// Adds o to related.R.AccountTypeAccounts.
func (o *Account) SetAccountType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *AccountType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Account` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"account_type_id"}),
		strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.AccountTypeID, o.AccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AccountTypeID = related.AccountTypeID
	if o.R == nil {
		o.R = &accountR{
			AccountType: related,
		}
	} else {
		o.R.AccountType = related
	}

	if related.R == nil {
		related.R = &accountTypeR{
			AccountTypeAccounts: AccountSlice{o},
		}
	} else {
		related.R.AccountTypeAccounts = append(related.R.AccountTypeAccounts, o)
	}

	return nil
}

// SetBranch of the account to the related item.
// Sets o.R.Branch to related.
// Adds o to related.R.BranchAccounts.
func (o *Account) SetBranch(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Branch) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Account` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"branch_id"}),
		strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
	)
	values := []interface{}{related.BranchID, o.AccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BranchID = related.BranchID
	if o.R == nil {
		o.R = &accountR{
			Branch: related,
		}
	} else {
		o.R.Branch = related
	}

	if related.R == nil {
		related.R = &branchR{
			BranchAccounts: AccountSlice{o},
		}
	} else {
		related.R.BranchAccounts = append(related.R.BranchAccounts, o)
	}

	return nil
}

// AddAccountAccountCreditLines adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountAccountCreditLines.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountAccountCreditLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountCreditLine) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.AccountID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountCreditLine` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, accountCreditLinePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.AccountCreditLineID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.AccountID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountAccountCreditLines: related,
		}
	} else {
		o.R.AccountAccountCreditLines = append(o.R.AccountAccountCreditLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountCreditLineR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetAccountAccountCreditLines removes all previously related items of the
// Account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's AccountAccountCreditLines accordingly.
// Replaces o.R.AccountAccountCreditLines with related.
// Sets related.R.Account's AccountAccountCreditLines accordingly.
func (o *Account) SetAccountAccountCreditLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountCreditLine) error {
	query := "update `AccountCreditLine` set `account_id` = null where `account_id` = ?"
	values := []interface{}{o.AccountID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AccountAccountCreditLines {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.AccountAccountCreditLines = nil
	}
	return o.AddAccountAccountCreditLines(ctx, exec, insert, related...)
}

// RemoveAccountAccountCreditLines relationships from objects passed in.
// Removes related items from R.AccountAccountCreditLines (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveAccountAccountCreditLines(ctx context.Context, exec boil.ContextExecutor, related ...*AccountCreditLine) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AccountAccountCreditLines {
			if rel != ri {
				continue
			}

			ln := len(o.R.AccountAccountCreditLines)
			if ln > 1 && i < ln-1 {
				o.R.AccountAccountCreditLines[i] = o.R.AccountAccountCreditLines[ln-1]
			}
			o.R.AccountAccountCreditLines = o.R.AccountAccountCreditLines[:ln-1]
			break
		}
	}

	return nil
}

// AddFromAccountAccountLinks adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountAccountLinks.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountAccountLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountLink) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountLink` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, accountLinkPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.AccountLinkID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountAccountLinks: related,
		}
	} else {
		o.R.FromAccountAccountLinks = append(o.R.FromAccountAccountLinks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountLinkR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddToAccountAccountLinks adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.ToAccountAccountLinks.
// Sets related.R.ToAccount appropriately.
func (o *Account) AddToAccountAccountLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountLink) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountLink` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_account_id"}),
				strmangle.WhereClause("`", "`", 0, accountLinkPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.AccountLinkID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ToAccountAccountLinks: related,
		}
	} else {
		o.R.ToAccountAccountLinks = append(o.R.ToAccountAccountLinks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountLinkR{
				ToAccount: o,
			}
		} else {
			rel.R.ToAccount = o
		}
	}
	return nil
}

// AddAccountAccountOwners adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountAccountOwners.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountAccountOwners(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountOwner) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountOwners` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, accountOwnerPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.AccountOwnerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountAccountOwners: related,
		}
	} else {
		o.R.AccountAccountOwners = append(o.R.AccountAccountOwners, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountOwnerR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountAccountRequestHistories adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountAccountRequestHistories.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequestHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.AccountID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountRequestHistory` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.AccountRequestHistoryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.AccountID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountAccountRequestHistories: related,
		}
	} else {
		o.R.AccountAccountRequestHistories = append(o.R.AccountAccountRequestHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountRequestHistoryR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetAccountAccountRequestHistories removes all previously related items of the
// Account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's AccountAccountRequestHistories accordingly.
// Replaces o.R.AccountAccountRequestHistories with related.
// Sets related.R.Account's AccountAccountRequestHistories accordingly.
func (o *Account) SetAccountAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequestHistory) error {
	query := "update `AccountRequestHistory` set `account_id` = null where `account_id` = ?"
	values := []interface{}{o.AccountID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AccountAccountRequestHistories {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.AccountAccountRequestHistories = nil
	}
	return o.AddAccountAccountRequestHistories(ctx, exec, insert, related...)
}

// RemoveAccountAccountRequestHistories relationships from objects passed in.
// Removes related items from R.AccountAccountRequestHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveAccountAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, related ...*AccountRequestHistory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AccountAccountRequestHistories {
			if rel != ri {
				continue
			}

			ln := len(o.R.AccountAccountRequestHistories)
			if ln > 1 && i < ln-1 {
				o.R.AccountAccountRequestHistories[i] = o.R.AccountAccountRequestHistories[ln-1]
			}
			o.R.AccountAccountRequestHistories = o.R.AccountAccountRequestHistories[:ln-1]
			break
		}
	}

	return nil
}

// AddDebtorAccountBeneficiaries adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.DebtorAccountBeneficiaries.
// Sets related.R.DebtorAccount appropriately.
func (o *Account) AddDebtorAccountBeneficiaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Beneficiary) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DebtorAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Beneficiary` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"debtor_account_id"}),
				strmangle.WhereClause("`", "`", 0, beneficiaryPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.BeneficiaryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DebtorAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DebtorAccountBeneficiaries: related,
		}
	} else {
		o.R.DebtorAccountBeneficiaries = append(o.R.DebtorAccountBeneficiaries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &beneficiaryR{
				DebtorAccount: o,
			}
		} else {
			rel.R.DebtorAccount = o
		}
	}
	return nil
}

// AddPayeeAccountBillers adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.PayeeAccountBillers.
// Sets related.R.PayeeAccount appropriately.
func (o *Account) AddPayeeAccountBillers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Biller) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PayeeAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Biller` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payee_account_id"}),
				strmangle.WhereClause("`", "`", 0, billerPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.BillerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PayeeAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			PayeeAccountBillers: related,
		}
	} else {
		o.R.PayeeAccountBillers = append(o.R.PayeeAccountBillers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &billerR{
				PayeeAccount: o,
			}
		} else {
			rel.R.PayeeAccount = o
		}
	}
	return nil
}

// AddAccountCustomerOffers adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountCustomerOffers.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountCustomerOffers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerOffer) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.AccountID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CustomerOffer` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, customerOfferPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.CustomerOfferID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.AccountID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountCustomerOffers: related,
		}
	} else {
		o.R.AccountCustomerOffers = append(o.R.AccountCustomerOffers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerOfferR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetAccountCustomerOffers removes all previously related items of the
// Account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's AccountCustomerOffers accordingly.
// Replaces o.R.AccountCustomerOffers with related.
// Sets related.R.Account's AccountCustomerOffers accordingly.
func (o *Account) SetAccountCustomerOffers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerOffer) error {
	query := "update `CustomerOffer` set `account_id` = null where `account_id` = ?"
	values := []interface{}{o.AccountID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AccountCustomerOffers {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.AccountCustomerOffers = nil
	}
	return o.AddAccountCustomerOffers(ctx, exec, insert, related...)
}

// RemoveAccountCustomerOffers relationships from objects passed in.
// Removes related items from R.AccountCustomerOffers (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveAccountCustomerOffers(ctx context.Context, exec boil.ContextExecutor, related ...*CustomerOffer) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AccountCustomerOffers {
			if rel != ri {
				continue
			}

			ln := len(o.R.AccountCustomerOffers)
			if ln > 1 && i < ln-1 {
				o.R.AccountCustomerOffers[i] = o.R.AccountCustomerOffers[ln-1]
			}
			o.R.AccountCustomerOffers = o.R.AccountCustomerOffers[:ln-1]
			break
		}
	}

	return nil
}

// AddDebtorAccountDirectDebits adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.DebtorAccountDirectDebits.
// Sets related.R.DebtorAccount appropriately.
func (o *Account) AddDebtorAccountDirectDebits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DirectDebit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DebtorAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `DirectDebits` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"debtor_account_id"}),
				strmangle.WhereClause("`", "`", 0, directDebitPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.DirectDebitID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DebtorAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DebtorAccountDirectDebits: related,
		}
	} else {
		o.R.DebtorAccountDirectDebits = append(o.R.DebtorAccountDirectDebits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &directDebitR{
				DebtorAccount: o,
			}
		} else {
			rel.R.DebtorAccount = o
		}
	}
	return nil
}

// AddAccountFundConfirmations adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountFundConfirmations.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountFundConfirmations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FundConfirmation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `FundConfirmation` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, fundConfirmationPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.FundConfirmationID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountFundConfirmations: related,
		}
	} else {
		o.R.AccountFundConfirmations = append(o.R.AccountFundConfirmations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fundConfirmationR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountFxDeals adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountFxDeals.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountFxDeals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FxDeal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `FxDeals` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, fxDealPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.FXDealID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountFxDeals: related,
		}
	} else {
		o.R.AccountFxDeals = append(o.R.AccountFxDeals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fxDealR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountJournalEntryLines adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountJournalEntryLines.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountJournalEntryLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JournalEntryLine) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JournalEntryLine` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, journalEntryLinePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.JournalEntryLineID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountJournalEntryLines: related,
		}
	} else {
		o.R.AccountJournalEntryLines = append(o.R.AccountJournalEntryLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &journalEntryLineR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountLoans adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountLoans.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountLoans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Loan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Loan` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.LoanID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountLoans: related,
		}
	} else {
		o.R.AccountLoans = append(o.R.AccountLoans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loanR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountOBPFundConfirmationConsents adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountOBPFundConfirmationConsents.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountOBPFundConfirmationConsents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OBPFundConfirmationConsent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `OBPFundConfirmationConsent` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, oBPFundConfirmationConsentPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.ObfundconfirmationconsentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountOBPFundConfirmationConsents: related,
		}
	} else {
		o.R.AccountOBPFundConfirmationConsents = append(o.R.AccountOBPFundConfirmationConsents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &oBPFundConfirmationConsentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddFromAccountPaymentAches adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountPaymentAches.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, paymentAchPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountPaymentAches: related,
		}
	} else {
		o.R.FromAccountPaymentAches = append(o.R.FromAccountPaymentAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAchR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddToAccountPaymentAches adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.ToAccountPaymentAches.
// Sets related.R.ToAccount appropriately.
func (o *Account) AddToAccountPaymentAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentAch) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_account_id"}),
				strmangle.WhereClause("`", "`", 0, paymentAchPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ToAccountPaymentAches: related,
		}
	} else {
		o.R.ToAccountPaymentAches = append(o.R.ToAccountPaymentAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentAchR{
				ToAccount: o,
			}
		} else {
			rel.R.ToAccount = o
		}
	}
	return nil
}

// AddFromAccountPaymentBills adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountPaymentBills.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountPaymentBills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentBill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentBill` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, paymentBillPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentBillID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountPaymentBills: related,
		}
	} else {
		o.R.FromAccountPaymentBills = append(o.R.FromAccountPaymentBills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentBillR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddAcountPaymentLimits adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AcountPaymentLimits.
// Sets related.R.Acount appropriately.
func (o *Account) AddAcountPaymentLimits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLimit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AcountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentLimit` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"acount_id"}),
				strmangle.WhereClause("`", "`", 0, paymentLimitPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentLimitID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AcountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AcountPaymentLimits: related,
		}
	} else {
		o.R.AcountPaymentLimits = append(o.R.AcountPaymentLimits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentLimitR{
				Acount: o,
			}
		} else {
			rel.R.Acount = o
		}
	}
	return nil
}

// AddFromAccountPaymentWires adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountPaymentWires.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, paymentWirePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountPaymentWires: related,
		}
	} else {
		o.R.FromAccountPaymentWires = append(o.R.FromAccountPaymentWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentWireR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddToAccountPaymentWires adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.ToAccountPaymentWires.
// Sets related.R.ToAccount appropriately.
func (o *Account) AddToAccountPaymentWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentWire) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_account_id"}),
				strmangle.WhereClause("`", "`", 0, paymentWirePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PaymentWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ToAccountPaymentWires: related,
		}
	} else {
		o.R.ToAccountPaymentWires = append(o.R.ToAccountPaymentWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentWireR{
				ToAccount: o,
			}
		} else {
			rel.R.ToAccount = o
		}
	}
	return nil
}

// AddAccountPortfolios adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountPortfolios.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountPortfolios(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Portfolio) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Portfolio` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, portfolioPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.PortfolioID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountPortfolios: related,
		}
	} else {
		o.R.AccountPortfolios = append(o.R.AccountPortfolios, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &portfolioR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddPayeeAccountRegisteredBillers adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.PayeeAccountRegisteredBillers.
// Sets related.R.PayeeAccount appropriately.
func (o *Account) AddPayeeAccountRegisteredBillers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RegisteredBiller) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PayeeAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `RegisteredBiller` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"payee_account_id"}),
				strmangle.WhereClause("`", "`", 0, registeredBillerPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.BillerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PayeeAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			PayeeAccountRegisteredBillers: related,
		}
	} else {
		o.R.PayeeAccountRegisteredBillers = append(o.R.PayeeAccountRegisteredBillers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &registeredBillerR{
				PayeeAccount: o,
			}
		} else {
			rel.R.PayeeAccount = o
		}
	}
	return nil
}

// AddAccountRTPS adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountRTPS.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountRTPS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RTP) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Rtp` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, rtpPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.RTPID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountRTPS: related,
		}
	} else {
		o.R.AccountRTPS = append(o.R.AccountRTPS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &rtpR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountSchedulePayments adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountSchedulePayments.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountSchedulePayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SchedulePayment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.AccountID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `SchedulePayment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, schedulePaymentPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.SchedulePaymentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.AccountID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountSchedulePayments: related,
		}
	} else {
		o.R.AccountSchedulePayments = append(o.R.AccountSchedulePayments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &schedulePaymentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetAccountSchedulePayments removes all previously related items of the
// Account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's AccountSchedulePayments accordingly.
// Replaces o.R.AccountSchedulePayments with related.
// Sets related.R.Account's AccountSchedulePayments accordingly.
func (o *Account) SetAccountSchedulePayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SchedulePayment) error {
	query := "update `SchedulePayment` set `account_id` = null where `account_id` = ?"
	values := []interface{}{o.AccountID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AccountSchedulePayments {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.AccountSchedulePayments = nil
	}
	return o.AddAccountSchedulePayments(ctx, exec, insert, related...)
}

// RemoveAccountSchedulePayments relationships from objects passed in.
// Removes related items from R.AccountSchedulePayments (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveAccountSchedulePayments(ctx context.Context, exec boil.ContextExecutor, related ...*SchedulePayment) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AccountSchedulePayments {
			if rel != ri {
				continue
			}

			ln := len(o.R.AccountSchedulePayments)
			if ln > 1 && i < ln-1 {
				o.R.AccountSchedulePayments[i] = o.R.AccountSchedulePayments[ln-1]
			}
			o.R.AccountSchedulePayments = o.R.AccountSchedulePayments[:ln-1]
			break
		}
	}

	return nil
}

// AddDebtorAccountStandingOrders adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.DebtorAccountStandingOrders.
// Sets related.R.DebtorAccount appropriately.
func (o *Account) AddDebtorAccountStandingOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StandingOrder) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DebtorAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StandingOrders` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"debtor_account_id"}),
				strmangle.WhereClause("`", "`", 0, standingOrderPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.StandingOrderID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DebtorAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DebtorAccountStandingOrders: related,
		}
	} else {
		o.R.DebtorAccountStandingOrders = append(o.R.DebtorAccountStandingOrders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &standingOrderR{
				DebtorAccount: o,
			}
		} else {
			rel.R.DebtorAccount = o
		}
	}
	return nil
}

// AddAccountStatements adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountStatements.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountStatements(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Statement) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Statement` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, statementPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.StatementID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountStatements: related,
		}
	} else {
		o.R.AccountStatements = append(o.R.AccountStatements, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &statementR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountTFParties adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountTFParties.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTFParties(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFParty) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFParty` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TFPartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTFParties: related,
		}
	} else {
		o.R.AccountTFParties = append(o.R.AccountTFParties, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountTFPartyTxns adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountTFPartyTxns.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTFPartyTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFPartyTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFPartyTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, tFPartyTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TFPartyID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTFPartyTxns: related,
		}
	} else {
		o.R.AccountTFPartyTxns = append(o.R.AccountTFPartyTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFPartyTxnR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddAccountTransactions adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.AccountTransactions.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Transaction` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
				strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTransactions: related,
		}
	} else {
		o.R.AccountTransactions = append(o.R.AccountTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transactionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddFromAccountTransferAches adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountTransferAches.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountTransferAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TransferAch) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TransferAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, transferAchPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TransferAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountTransferAches: related,
		}
	} else {
		o.R.FromAccountTransferAches = append(o.R.FromAccountTransferAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferAchR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddToAccountTransferAches adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.ToAccountTransferAches.
// Sets related.R.ToAccount appropriately.
func (o *Account) AddToAccountTransferAches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TransferAch) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TransferAch` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_account_id"}),
				strmangle.WhereClause("`", "`", 0, transferAchPrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TransferAchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ToAccountTransferAches: related,
		}
	} else {
		o.R.ToAccountTransferAches = append(o.R.ToAccountTransferAches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferAchR{
				ToAccount: o,
			}
		} else {
			rel.R.ToAccount = o
		}
	}
	return nil
}

// AddFromAccountTransferWires adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.FromAccountTransferWires.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountTransferWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TransferWire) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TransferWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"from_account_id"}),
				strmangle.WhereClause("`", "`", 0, transferWirePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TransferWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountTransferWires: related,
		}
	} else {
		o.R.FromAccountTransferWires = append(o.R.FromAccountTransferWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferWireR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddToAccountTransferWires adds the given related objects to the existing relationships
// of the Account, optionally inserting them as new records.
// Appends related to o.R.ToAccountTransferWires.
// Sets related.R.ToAccount appropriately.
func (o *Account) AddToAccountTransferWires(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TransferWire) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToAccountID = o.AccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TransferWire` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"to_account_id"}),
				strmangle.WhereClause("`", "`", 0, transferWirePrimaryKeyColumns),
			)
			values := []interface{}{o.AccountID, rel.TransferWireID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToAccountID = o.AccountID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ToAccountTransferWires: related,
		}
	} else {
		o.R.ToAccountTransferWires = append(o.R.ToAccountTransferWires, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferWireR{
				ToAccount: o,
			}
		} else {
			rel.R.ToAccount = o
		}
	}
	return nil
}

// Accounts retrieves all the records using an executor.
func Accounts(mods ...qm.QueryMod) accountQuery {
	mods = append(mods, qm.From("`Account`"))
	return accountQuery{NewQuery(mods...)}
}

// FindAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccount(ctx context.Context, exec boil.ContextExecutor, accountID int, selectCols ...string) (*Account, error) {
	accountObj := &Account{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Account` where `account_id`=?", sel,
	)

	q := queries.Raw(query, accountID)

	err := q.Bind(ctx, exec, accountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Account")
	}

	return accountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Account) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Account provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountInsertCacheMut.RLock()
	cache, cached := accountInsertCache[key]
	accountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountType, accountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Account` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Account` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Account` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Account")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.AccountID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == accountMapping["AccountID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.AccountID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Account")
	}

CacheNoHooks:
	if !cached {
		accountInsertCacheMut.Lock()
		accountInsertCache[key] = cache
		accountInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Account.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Account) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	accountUpdateCacheMut.RLock()
	cache, cached := accountUpdateCache[key]
	accountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountColumns,
			accountPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Account, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Account` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, append(wl, accountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Account row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Account")
	}

	if !cached {
		accountUpdateCacheMut.Lock()
		accountUpdateCache[key] = cache
		accountUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q accountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Account")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Account` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all account")
	}
	return rowsAff, nil
}

var mySQLAccountUniqueColumns = []string{
	"account_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Account) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Account provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLAccountUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountUpsertCacheMut.RLock()
	cache, cached := accountUpsertCache[key]
	accountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			accountColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			accountColumns,
			accountPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Account, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Account", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Account` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountType, accountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Account")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.AccountID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == accountMapping["account_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(accountType, accountMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Account")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Account")
	}

CacheNoHooks:
	if !cached {
		accountUpsertCacheMut.Lock()
		accountUpsertCache[key] = cache
		accountUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Account record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Account) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Account provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountPrimaryKeyMapping)
	sql := "DELETE FROM `Account` WHERE `account_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Account")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no accountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Account slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(accountBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Account` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Account")
	}

	if len(accountAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Account) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccount(ctx, exec, o.AccountID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Account`.* FROM `Account` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AccountSlice")
	}

	*o = slice

	return nil
}

// AccountExists checks if the Account row exists.
func AccountExists(ctx context.Context, exec boil.ContextExecutor, accountID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Account` where `account_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, accountID)
	}

	row := exec.QueryRowContext(ctx, sql, accountID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Account exists")
	}

	return exists, nil
}
