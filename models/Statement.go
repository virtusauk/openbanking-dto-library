// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Statement is an object representing the database table.
type Statement struct {
	StatementID               int         `boil:"statement_id" json:"statement_id" toml:"statement_id" yaml:"statement_id"`
	StatementRefID            null.String `boil:"statement_ref_id" json:"statement_ref_id,omitempty" toml:"statement_ref_id" yaml:"statement_ref_id,omitempty"`
	AccountID                 int         `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	StatementReference        null.String `boil:"statement_reference" json:"statement_reference,omitempty" toml:"statement_reference" yaml:"statement_reference,omitempty"`
	StatementdatetimeDatetime null.Time   `boil:"statementdatetime_datetime" json:"statementdatetime_datetime,omitempty" toml:"statementdatetime_datetime" yaml:"statementdatetime_datetime,omitempty"`
	StatementdatetimeType     null.String `boil:"statementdatetime_type" json:"statementdatetime_type,omitempty" toml:"statementdatetime_type" yaml:"statementdatetime_type,omitempty"`
	StatementrateRate         null.String `boil:"statementrate_rate" json:"statementrate_rate,omitempty" toml:"statementrate_rate" yaml:"statementrate_rate,omitempty"`
	StatementrateType         null.String `boil:"statementrate_type" json:"statementrate_type,omitempty" toml:"statementrate_type" yaml:"statementrate_type,omitempty"`
	StatementvalueValue       null.String `boil:"statementvalue_value" json:"statementvalue_value,omitempty" toml:"statementvalue_value" yaml:"statementvalue_value,omitempty"`
	StatementvalueType        null.String `boil:"statementvalue_type" json:"statementvalue_type,omitempty" toml:"statementvalue_type" yaml:"statementvalue_type,omitempty"`
	StatementType             string      `boil:"statement_type" json:"statement_type" toml:"statement_type" yaml:"statement_type"`
	StartDateTime             null.Time   `boil:"start_date_time" json:"start_date_time,omitempty" toml:"start_date_time" yaml:"start_date_time,omitempty"`
	EndDateTime               null.Time   `boil:"end_date_time" json:"end_date_time,omitempty" toml:"end_date_time" yaml:"end_date_time,omitempty"`
	CreationDateTime          null.Time   `boil:"creation_date_time" json:"creation_date_time,omitempty" toml:"creation_date_time" yaml:"creation_date_time,omitempty"`
	StatementDescription      null.String `boil:"statement_description" json:"statement_description,omitempty" toml:"statement_description" yaml:"statement_description,omitempty"`
	MakerDate                 time.Time   `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate               null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                   string      `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                 null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate              null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *statementR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L statementL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var StatementColumns = struct {
	StatementID               string
	StatementRefID            string
	AccountID                 string
	StatementReference        string
	StatementdatetimeDatetime string
	StatementdatetimeType     string
	StatementrateRate         string
	StatementrateType         string
	StatementvalueValue       string
	StatementvalueType        string
	StatementType             string
	StartDateTime             string
	EndDateTime               string
	CreationDateTime          string
	StatementDescription      string
	MakerDate                 string
	CheckerDate               string
	MakerID                   string
	CheckerID                 string
	ModifiedBy                string
	ModifiedDate              string
}{
	StatementID:               "statement_id",
	StatementRefID:            "statement_ref_id",
	AccountID:                 "account_id",
	StatementReference:        "statement_reference",
	StatementdatetimeDatetime: "statementdatetime_datetime",
	StatementdatetimeType:     "statementdatetime_type",
	StatementrateRate:         "statementrate_rate",
	StatementrateType:         "statementrate_type",
	StatementvalueValue:       "statementvalue_value",
	StatementvalueType:        "statementvalue_type",
	StatementType:             "statement_type",
	StartDateTime:             "start_date_time",
	EndDateTime:               "end_date_time",
	CreationDateTime:          "creation_date_time",
	StatementDescription:      "statement_description",
	MakerDate:                 "maker_date",
	CheckerDate:               "checker_date",
	MakerID:                   "maker_id",
	CheckerID:                 "checker_id",
	ModifiedBy:                "modified_by",
	ModifiedDate:              "modified_date",
}

// Generated where

var StatementWhere = struct {
	StatementID               whereHelperint
	StatementRefID            whereHelpernull_String
	AccountID                 whereHelperint
	StatementReference        whereHelpernull_String
	StatementdatetimeDatetime whereHelpernull_Time
	StatementdatetimeType     whereHelpernull_String
	StatementrateRate         whereHelpernull_String
	StatementrateType         whereHelpernull_String
	StatementvalueValue       whereHelpernull_String
	StatementvalueType        whereHelpernull_String
	StatementType             whereHelperstring
	StartDateTime             whereHelpernull_Time
	EndDateTime               whereHelpernull_Time
	CreationDateTime          whereHelpernull_Time
	StatementDescription      whereHelpernull_String
	MakerDate                 whereHelpertime_Time
	CheckerDate               whereHelpernull_Time
	MakerID                   whereHelperstring
	CheckerID                 whereHelpernull_String
	ModifiedBy                whereHelpernull_String
	ModifiedDate              whereHelpernull_Time
}{
	StatementID:               whereHelperint{field: `statement_id`},
	StatementRefID:            whereHelpernull_String{field: `statement_ref_id`},
	AccountID:                 whereHelperint{field: `account_id`},
	StatementReference:        whereHelpernull_String{field: `statement_reference`},
	StatementdatetimeDatetime: whereHelpernull_Time{field: `statementdatetime_datetime`},
	StatementdatetimeType:     whereHelpernull_String{field: `statementdatetime_type`},
	StatementrateRate:         whereHelpernull_String{field: `statementrate_rate`},
	StatementrateType:         whereHelpernull_String{field: `statementrate_type`},
	StatementvalueValue:       whereHelpernull_String{field: `statementvalue_value`},
	StatementvalueType:        whereHelpernull_String{field: `statementvalue_type`},
	StatementType:             whereHelperstring{field: `statement_type`},
	StartDateTime:             whereHelpernull_Time{field: `start_date_time`},
	EndDateTime:               whereHelpernull_Time{field: `end_date_time`},
	CreationDateTime:          whereHelpernull_Time{field: `creation_date_time`},
	StatementDescription:      whereHelpernull_String{field: `statement_description`},
	MakerDate:                 whereHelpertime_Time{field: `maker_date`},
	CheckerDate:               whereHelpernull_Time{field: `checker_date`},
	MakerID:                   whereHelperstring{field: `maker_id`},
	CheckerID:                 whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                whereHelpernull_String{field: `modified_by`},
	ModifiedDate:              whereHelpernull_Time{field: `modified_date`},
}

// StatementRels is where relationship names are stored.
var StatementRels = struct {
	Account                     string
	StatementStatementAmounts   string
	StatementStatementBenefits  string
	StatementStatementFees      string
	StatementStatementInterests string
}{
	Account:                     "Account",
	StatementStatementAmounts:   "StatementStatementAmounts",
	StatementStatementBenefits:  "StatementStatementBenefits",
	StatementStatementFees:      "StatementStatementFees",
	StatementStatementInterests: "StatementStatementInterests",
}

// statementR is where relationships are stored.
type statementR struct {
	Account                     *Account
	StatementStatementAmounts   StatementAmountSlice
	StatementStatementBenefits  StatementBenefitSlice
	StatementStatementFees      StatementFeeSlice
	StatementStatementInterests StatementInterestSlice
}

// NewStruct creates a new relationship struct
func (*statementR) NewStruct() *statementR {
	return &statementR{}
}

// statementL is where Load methods for each relationship are stored.
type statementL struct{}

var (
	statementColumns               = []string{"statement_id", "statement_ref_id", "account_id", "statement_reference", "statementdatetime_datetime", "statementdatetime_type", "statementrate_rate", "statementrate_type", "statementvalue_value", "statementvalue_type", "statement_type", "start_date_time", "end_date_time", "creation_date_time", "statement_description", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	statementColumnsWithoutDefault = []string{"statement_id", "statement_ref_id", "account_id", "statement_reference", "statementdatetime_datetime", "statementdatetime_type", "statementrate_rate", "statementrate_type", "statementvalue_value", "statementvalue_type", "statement_type", "start_date_time", "end_date_time", "creation_date_time", "statement_description", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	statementColumnsWithDefault    = []string{}
	statementPrimaryKeyColumns     = []string{"statement_id"}
)

type (
	// StatementSlice is an alias for a slice of pointers to Statement.
	// This should generally be used opposed to []Statement.
	StatementSlice []*Statement
	// StatementHook is the signature for custom Statement hook methods
	StatementHook func(context.Context, boil.ContextExecutor, *Statement) error

	statementQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	statementType                 = reflect.TypeOf(&Statement{})
	statementMapping              = queries.MakeStructMapping(statementType)
	statementPrimaryKeyMapping, _ = queries.BindMapping(statementType, statementMapping, statementPrimaryKeyColumns)
	statementInsertCacheMut       sync.RWMutex
	statementInsertCache          = make(map[string]insertCache)
	statementUpdateCacheMut       sync.RWMutex
	statementUpdateCache          = make(map[string]updateCache)
	statementUpsertCacheMut       sync.RWMutex
	statementUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var statementBeforeInsertHooks []StatementHook
var statementBeforeUpdateHooks []StatementHook
var statementBeforeDeleteHooks []StatementHook
var statementBeforeUpsertHooks []StatementHook

var statementAfterInsertHooks []StatementHook
var statementAfterSelectHooks []StatementHook
var statementAfterUpdateHooks []StatementHook
var statementAfterDeleteHooks []StatementHook
var statementAfterUpsertHooks []StatementHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Statement) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Statement) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Statement) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Statement) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Statement) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Statement) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Statement) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Statement) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Statement) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range statementAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddStatementHook registers your hook function for all future operations.
func AddStatementHook(hookPoint boil.HookPoint, statementHook StatementHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		statementBeforeInsertHooks = append(statementBeforeInsertHooks, statementHook)
	case boil.BeforeUpdateHook:
		statementBeforeUpdateHooks = append(statementBeforeUpdateHooks, statementHook)
	case boil.BeforeDeleteHook:
		statementBeforeDeleteHooks = append(statementBeforeDeleteHooks, statementHook)
	case boil.BeforeUpsertHook:
		statementBeforeUpsertHooks = append(statementBeforeUpsertHooks, statementHook)
	case boil.AfterInsertHook:
		statementAfterInsertHooks = append(statementAfterInsertHooks, statementHook)
	case boil.AfterSelectHook:
		statementAfterSelectHooks = append(statementAfterSelectHooks, statementHook)
	case boil.AfterUpdateHook:
		statementAfterUpdateHooks = append(statementAfterUpdateHooks, statementHook)
	case boil.AfterDeleteHook:
		statementAfterDeleteHooks = append(statementAfterDeleteHooks, statementHook)
	case boil.AfterUpsertHook:
		statementAfterUpsertHooks = append(statementAfterUpsertHooks, statementHook)
	}
}

// One returns a single statement record from the query.
func (q statementQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Statement, error) {
	o := &Statement{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Statement")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Statement records from the query.
func (q statementQuery) All(ctx context.Context, exec boil.ContextExecutor) (StatementSlice, error) {
	var o []*Statement

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Statement slice")
	}

	if len(statementAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Statement records in the query.
func (q statementQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Statement rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q statementQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Statement exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *Statement) Account(mods ...qm.QueryMod) accountQuery {
	queryMods := []qm.QueryMod{
		qm.Where("account_id=?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	query := Accounts(queryMods...)
	queries.SetFrom(query.Query, "`Account`")

	return query
}

// StatementStatementAmounts retrieves all the StatementAmount's StatementAmounts with an executor via statement_id column.
func (o *Statement) StatementStatementAmounts(mods ...qm.QueryMod) statementAmountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StatementAmount`.`statement_id`=?", o.StatementID),
	)

	query := StatementAmounts(queryMods...)
	queries.SetFrom(query.Query, "`StatementAmount`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StatementAmount`.*"})
	}

	return query
}

// StatementStatementBenefits retrieves all the StatementBenefit's StatementBenefits with an executor via statement_id column.
func (o *Statement) StatementStatementBenefits(mods ...qm.QueryMod) statementBenefitQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StatementBenefit`.`statement_id`=?", o.StatementID),
	)

	query := StatementBenefits(queryMods...)
	queries.SetFrom(query.Query, "`StatementBenefit`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StatementBenefit`.*"})
	}

	return query
}

// StatementStatementFees retrieves all the StatementFee's StatementFees with an executor via statement_id column.
func (o *Statement) StatementStatementFees(mods ...qm.QueryMod) statementFeeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StatementFee`.`statement_id`=?", o.StatementID),
	)

	query := StatementFees(queryMods...)
	queries.SetFrom(query.Query, "`StatementFee`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StatementFee`.*"})
	}

	return query
}

// StatementStatementInterests retrieves all the StatementInterest's StatementInterests with an executor via statement_id column.
func (o *Statement) StatementStatementInterests(mods ...qm.QueryMod) statementInterestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StatementInterest`.`statement_id`=?", o.StatementID),
	)

	query := StatementInterests(queryMods...)
	queries.SetFrom(query.Query, "`StatementInterest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StatementInterest`.*"})
	}

	return query
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (statementL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStatement interface{}, mods queries.Applicator) error {
	var slice []*Statement
	var object *Statement

	if singular {
		object = maybeStatement.(*Statement)
	} else {
		slice = *maybeStatement.(*[]*Statement)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &statementR{}
		}
		args = append(args, object.AccountID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &statementR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Account`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Account")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Account")
	}

	if len(statementAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &accountR{}
		}
		foreign.R.AccountStatements = append(foreign.R.AccountStatements, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AccountID == foreign.AccountID {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.AccountStatements = append(foreign.R.AccountStatements, local)
				break
			}
		}
	}

	return nil
}

// LoadStatementStatementAmounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (statementL) LoadStatementStatementAmounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStatement interface{}, mods queries.Applicator) error {
	var slice []*Statement
	var object *Statement

	if singular {
		object = maybeStatement.(*Statement)
	} else {
		slice = *maybeStatement.(*[]*Statement)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &statementR{}
		}
		args = append(args, object.StatementID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &statementR{}
			}

			for _, a := range args {
				if a == obj.StatementID {
					continue Outer
				}
			}

			args = append(args, obj.StatementID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StatementAmount`), qm.WhereIn(`statement_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StatementAmount")
	}

	var resultSlice []*StatementAmount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StatementAmount")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StatementAmount")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StatementAmount")
	}

	if len(statementAmountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StatementStatementAmounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &statementAmountR{}
			}
			foreign.R.Statement = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.StatementID == foreign.StatementID {
				local.R.StatementStatementAmounts = append(local.R.StatementStatementAmounts, foreign)
				if foreign.R == nil {
					foreign.R = &statementAmountR{}
				}
				foreign.R.Statement = local
				break
			}
		}
	}

	return nil
}

// LoadStatementStatementBenefits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (statementL) LoadStatementStatementBenefits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStatement interface{}, mods queries.Applicator) error {
	var slice []*Statement
	var object *Statement

	if singular {
		object = maybeStatement.(*Statement)
	} else {
		slice = *maybeStatement.(*[]*Statement)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &statementR{}
		}
		args = append(args, object.StatementID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &statementR{}
			}

			for _, a := range args {
				if a == obj.StatementID {
					continue Outer
				}
			}

			args = append(args, obj.StatementID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StatementBenefit`), qm.WhereIn(`statement_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StatementBenefit")
	}

	var resultSlice []*StatementBenefit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StatementBenefit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StatementBenefit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StatementBenefit")
	}

	if len(statementBenefitAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StatementStatementBenefits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &statementBenefitR{}
			}
			foreign.R.Statement = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.StatementID == foreign.StatementID {
				local.R.StatementStatementBenefits = append(local.R.StatementStatementBenefits, foreign)
				if foreign.R == nil {
					foreign.R = &statementBenefitR{}
				}
				foreign.R.Statement = local
				break
			}
		}
	}

	return nil
}

// LoadStatementStatementFees allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (statementL) LoadStatementStatementFees(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStatement interface{}, mods queries.Applicator) error {
	var slice []*Statement
	var object *Statement

	if singular {
		object = maybeStatement.(*Statement)
	} else {
		slice = *maybeStatement.(*[]*Statement)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &statementR{}
		}
		args = append(args, object.StatementID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &statementR{}
			}

			for _, a := range args {
				if a == obj.StatementID {
					continue Outer
				}
			}

			args = append(args, obj.StatementID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StatementFee`), qm.WhereIn(`statement_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StatementFee")
	}

	var resultSlice []*StatementFee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StatementFee")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StatementFee")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StatementFee")
	}

	if len(statementFeeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StatementStatementFees = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &statementFeeR{}
			}
			foreign.R.Statement = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.StatementID == foreign.StatementID {
				local.R.StatementStatementFees = append(local.R.StatementStatementFees, foreign)
				if foreign.R == nil {
					foreign.R = &statementFeeR{}
				}
				foreign.R.Statement = local
				break
			}
		}
	}

	return nil
}

// LoadStatementStatementInterests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (statementL) LoadStatementStatementInterests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeStatement interface{}, mods queries.Applicator) error {
	var slice []*Statement
	var object *Statement

	if singular {
		object = maybeStatement.(*Statement)
	} else {
		slice = *maybeStatement.(*[]*Statement)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &statementR{}
		}
		args = append(args, object.StatementID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &statementR{}
			}

			for _, a := range args {
				if a == obj.StatementID {
					continue Outer
				}
			}

			args = append(args, obj.StatementID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StatementInterest`), qm.WhereIn(`statement_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StatementInterest")
	}

	var resultSlice []*StatementInterest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StatementInterest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StatementInterest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StatementInterest")
	}

	if len(statementInterestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StatementStatementInterests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &statementInterestR{}
			}
			foreign.R.Statement = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.StatementID == foreign.StatementID {
				local.R.StatementStatementInterests = append(local.R.StatementStatementInterests, foreign)
				if foreign.R == nil {
					foreign.R = &statementInterestR{}
				}
				foreign.R.Statement = local
				break
			}
		}
	}

	return nil
}

// SetAccount of the statement to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountStatements.
func (o *Statement) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Account) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Statement` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
		strmangle.WhereClause("`", "`", 0, statementPrimaryKeyColumns),
	)
	values := []interface{}{related.AccountID, o.StatementID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AccountID = related.AccountID
	if o.R == nil {
		o.R = &statementR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &accountR{
			AccountStatements: StatementSlice{o},
		}
	} else {
		related.R.AccountStatements = append(related.R.AccountStatements, o)
	}

	return nil
}

// AddStatementStatementAmounts adds the given related objects to the existing relationships
// of the Statement, optionally inserting them as new records.
// Appends related to o.R.StatementStatementAmounts.
// Sets related.R.Statement appropriately.
func (o *Statement) AddStatementStatementAmounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StatementAmount) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.StatementID = o.StatementID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StatementAmount` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"statement_id"}),
				strmangle.WhereClause("`", "`", 0, statementAmountPrimaryKeyColumns),
			)
			values := []interface{}{o.StatementID, rel.StatementAmountID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.StatementID = o.StatementID
		}
	}

	if o.R == nil {
		o.R = &statementR{
			StatementStatementAmounts: related,
		}
	} else {
		o.R.StatementStatementAmounts = append(o.R.StatementStatementAmounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &statementAmountR{
				Statement: o,
			}
		} else {
			rel.R.Statement = o
		}
	}
	return nil
}

// AddStatementStatementBenefits adds the given related objects to the existing relationships
// of the Statement, optionally inserting them as new records.
// Appends related to o.R.StatementStatementBenefits.
// Sets related.R.Statement appropriately.
func (o *Statement) AddStatementStatementBenefits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StatementBenefit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.StatementID = o.StatementID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StatementBenefit` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"statement_id"}),
				strmangle.WhereClause("`", "`", 0, statementBenefitPrimaryKeyColumns),
			)
			values := []interface{}{o.StatementID, rel.StatementBenefitID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.StatementID = o.StatementID
		}
	}

	if o.R == nil {
		o.R = &statementR{
			StatementStatementBenefits: related,
		}
	} else {
		o.R.StatementStatementBenefits = append(o.R.StatementStatementBenefits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &statementBenefitR{
				Statement: o,
			}
		} else {
			rel.R.Statement = o
		}
	}
	return nil
}

// AddStatementStatementFees adds the given related objects to the existing relationships
// of the Statement, optionally inserting them as new records.
// Appends related to o.R.StatementStatementFees.
// Sets related.R.Statement appropriately.
func (o *Statement) AddStatementStatementFees(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StatementFee) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.StatementID = o.StatementID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StatementFee` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"statement_id"}),
				strmangle.WhereClause("`", "`", 0, statementFeePrimaryKeyColumns),
			)
			values := []interface{}{o.StatementID, rel.StatementFeeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.StatementID = o.StatementID
		}
	}

	if o.R == nil {
		o.R = &statementR{
			StatementStatementFees: related,
		}
	} else {
		o.R.StatementStatementFees = append(o.R.StatementStatementFees, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &statementFeeR{
				Statement: o,
			}
		} else {
			rel.R.Statement = o
		}
	}
	return nil
}

// AddStatementStatementInterests adds the given related objects to the existing relationships
// of the Statement, optionally inserting them as new records.
// Appends related to o.R.StatementStatementInterests.
// Sets related.R.Statement appropriately.
func (o *Statement) AddStatementStatementInterests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StatementInterest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.StatementID = o.StatementID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StatementInterest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"statement_id"}),
				strmangle.WhereClause("`", "`", 0, statementInterestPrimaryKeyColumns),
			)
			values := []interface{}{o.StatementID, rel.StatementInterestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.StatementID = o.StatementID
		}
	}

	if o.R == nil {
		o.R = &statementR{
			StatementStatementInterests: related,
		}
	} else {
		o.R.StatementStatementInterests = append(o.R.StatementStatementInterests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &statementInterestR{
				Statement: o,
			}
		} else {
			rel.R.Statement = o
		}
	}
	return nil
}

// Statements retrieves all the records using an executor.
func Statements(mods ...qm.QueryMod) statementQuery {
	mods = append(mods, qm.From("`Statement`"))
	return statementQuery{NewQuery(mods...)}
}

// FindStatement retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindStatement(ctx context.Context, exec boil.ContextExecutor, statementID int, selectCols ...string) (*Statement, error) {
	statementObj := &Statement{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Statement` where `statement_id`=?", sel,
	)

	q := queries.Raw(query, statementID)

	err := q.Bind(ctx, exec, statementObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Statement")
	}

	return statementObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Statement) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Statement provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(statementColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	statementInsertCacheMut.RLock()
	cache, cached := statementInsertCache[key]
	statementInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			statementColumns,
			statementColumnsWithDefault,
			statementColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(statementType, statementMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(statementType, statementMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Statement` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Statement` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Statement` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, statementPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Statement")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.StatementID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Statement")
	}

CacheNoHooks:
	if !cached {
		statementInsertCacheMut.Lock()
		statementInsertCache[key] = cache
		statementInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Statement.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Statement) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	statementUpdateCacheMut.RLock()
	cache, cached := statementUpdateCache[key]
	statementUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			statementColumns,
			statementPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Statement, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Statement` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, statementPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(statementType, statementMapping, append(wl, statementPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Statement row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Statement")
	}

	if !cached {
		statementUpdateCacheMut.Lock()
		statementUpdateCache[key] = cache
		statementUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q statementQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Statement")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Statement")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o StatementSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), statementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Statement` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, statementPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in statement slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all statement")
	}
	return rowsAff, nil
}

var mySQLStatementUniqueColumns = []string{
	"statement_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Statement) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Statement provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(statementColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLStatementUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	statementUpsertCacheMut.RLock()
	cache, cached := statementUpsertCache[key]
	statementUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			statementColumns,
			statementColumnsWithDefault,
			statementColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			statementColumns,
			statementPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Statement, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Statement", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Statement` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(statementType, statementMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(statementType, statementMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Statement")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(statementType, statementMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Statement")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Statement")
	}

CacheNoHooks:
	if !cached {
		statementUpsertCacheMut.Lock()
		statementUpsertCache[key] = cache
		statementUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Statement record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Statement) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Statement provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), statementPrimaryKeyMapping)
	sql := "DELETE FROM `Statement` WHERE `statement_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Statement")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Statement")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q statementQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no statementQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Statement")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Statement")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o StatementSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Statement slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(statementBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), statementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Statement` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, statementPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from statement slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Statement")
	}

	if len(statementAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Statement) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindStatement(ctx, exec, o.StatementID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *StatementSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := StatementSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), statementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Statement`.* FROM `Statement` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, statementPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in StatementSlice")
	}

	*o = slice

	return nil
}

// StatementExists checks if the Statement row exists.
func StatementExists(ctx context.Context, exec boil.ContextExecutor, statementID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Statement` where `statement_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, statementID)
	}

	row := exec.QueryRowContext(ctx, sql, statementID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Statement exists")
	}

	return exists, nil
}
