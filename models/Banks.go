// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Bank is an object representing the database table.
type Bank struct {
	BankID                 int         `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	BankRegNumber          string      `boil:"bank_reg_number" json:"bank_reg_number" toml:"bank_reg_number" yaml:"bank_reg_number"`
	BankIdentificationCode string      `boil:"bank_identification_code" json:"bank_identification_code" toml:"bank_identification_code" yaml:"bank_identification_code"`
	BankName               string      `boil:"bank_name" json:"bank_name" toml:"bank_name" yaml:"bank_name"`
	Country                string      `boil:"country" json:"country" toml:"country" yaml:"country"`
	RegisteredAddress      string      `boil:"registered_address" json:"registered_address" toml:"registered_address" yaml:"registered_address"`
	MakerDate              time.Time   `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate            null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                string      `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID              null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy             null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate           null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *bankR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L bankL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var BankColumns = struct {
	BankID                 string
	BankRegNumber          string
	BankIdentificationCode string
	BankName               string
	Country                string
	RegisteredAddress      string
	MakerDate              string
	CheckerDate            string
	MakerID                string
	CheckerID              string
	ModifiedBy             string
	ModifiedDate           string
}{
	BankID:                 "bank_id",
	BankRegNumber:          "bank_reg_number",
	BankIdentificationCode: "bank_identification_code",
	BankName:               "bank_name",
	Country:                "country",
	RegisteredAddress:      "registered_address",
	MakerDate:              "maker_date",
	CheckerDate:            "checker_date",
	MakerID:                "maker_id",
	CheckerID:              "checker_id",
	ModifiedBy:             "modified_by",
	ModifiedDate:           "modified_date",
}

// Generated where

var BankWhere = struct {
	BankID                 whereHelperint
	BankRegNumber          whereHelperstring
	BankIdentificationCode whereHelperstring
	BankName               whereHelperstring
	Country                whereHelperstring
	RegisteredAddress      whereHelperstring
	MakerDate              whereHelpertime_Time
	CheckerDate            whereHelpernull_Time
	MakerID                whereHelperstring
	CheckerID              whereHelpernull_String
	ModifiedBy             whereHelpernull_String
	ModifiedDate           whereHelpernull_Time
}{
	BankID:                 whereHelperint{field: `bank_id`},
	BankRegNumber:          whereHelperstring{field: `bank_reg_number`},
	BankIdentificationCode: whereHelperstring{field: `bank_identification_code`},
	BankName:               whereHelperstring{field: `bank_name`},
	Country:                whereHelperstring{field: `country`},
	RegisteredAddress:      whereHelperstring{field: `registered_address`},
	MakerDate:              whereHelpertime_Time{field: `maker_date`},
	CheckerDate:            whereHelpernull_Time{field: `checker_date`},
	MakerID:                whereHelperstring{field: `maker_id`},
	CheckerID:              whereHelpernull_String{field: `checker_id`},
	ModifiedBy:             whereHelpernull_String{field: `modified_by`},
	ModifiedDate:           whereHelpernull_Time{field: `modified_date`},
}

// BankRels is where relationship names are stored.
var BankRels = struct {
	BankAccounts                   string
	BankAccountOwners              string
	BankAccountRequests            string
	BankAccountRequestHistories    string
	BankAccountTypes               string
	BankAddresses                  string
	BankBeneficiaries              string
	BankBorrowers                  string
	BankBranches                   string
	BankCryptographies             string
	BankCustomerOffers             string
	BankDevices                    string
	BankDirectDebits               string
	BankEmails                     string
	BankGLAccounts                 string
	BankJointAccounts              string
	PostedBankKeyJournalEntries    string
	BankKYCS                       string
	BankOrganizations              string
	BankOrganizationContacts       string
	BankOrganizationFinancialInfos string
	BankParties                    string
	BankPaymentCheques             string
	BankPaymentFxTrades            string
	BankPersons                    string
	BankPersonFinancialInfos       string
	BankPhoneNumbers               string
	BankProducts                   string
	BankSocialInfos                string
	BankStandingOrders             string
	BankTFBankGuarantees           string
	BankTFLetterOfCredits          string
	BankTFLetterOfCreditTxns       string
	ConfirmingBankTrades           string
	IssueingBankTrades             string
	BankTransactions               string
}{
	BankAccounts:                   "BankAccounts",
	BankAccountOwners:              "BankAccountOwners",
	BankAccountRequests:            "BankAccountRequests",
	BankAccountRequestHistories:    "BankAccountRequestHistories",
	BankAccountTypes:               "BankAccountTypes",
	BankAddresses:                  "BankAddresses",
	BankBeneficiaries:              "BankBeneficiaries",
	BankBorrowers:                  "BankBorrowers",
	BankBranches:                   "BankBranches",
	BankCryptographies:             "BankCryptographies",
	BankCustomerOffers:             "BankCustomerOffers",
	BankDevices:                    "BankDevices",
	BankDirectDebits:               "BankDirectDebits",
	BankEmails:                     "BankEmails",
	BankGLAccounts:                 "BankGLAccounts",
	BankJointAccounts:              "BankJointAccounts",
	PostedBankKeyJournalEntries:    "PostedBankKeyJournalEntries",
	BankKYCS:                       "BankKYCS",
	BankOrganizations:              "BankOrganizations",
	BankOrganizationContacts:       "BankOrganizationContacts",
	BankOrganizationFinancialInfos: "BankOrganizationFinancialInfos",
	BankParties:                    "BankParties",
	BankPaymentCheques:             "BankPaymentCheques",
	BankPaymentFxTrades:            "BankPaymentFxTrades",
	BankPersons:                    "BankPersons",
	BankPersonFinancialInfos:       "BankPersonFinancialInfos",
	BankPhoneNumbers:               "BankPhoneNumbers",
	BankProducts:                   "BankProducts",
	BankSocialInfos:                "BankSocialInfos",
	BankStandingOrders:             "BankStandingOrders",
	BankTFBankGuarantees:           "BankTFBankGuarantees",
	BankTFLetterOfCredits:          "BankTFLetterOfCredits",
	BankTFLetterOfCreditTxns:       "BankTFLetterOfCreditTxns",
	ConfirmingBankTrades:           "ConfirmingBankTrades",
	IssueingBankTrades:             "IssueingBankTrades",
	BankTransactions:               "BankTransactions",
}

// bankR is where relationships are stored.
type bankR struct {
	BankAccounts                   AccountSlice
	BankAccountOwners              AccountOwnerSlice
	BankAccountRequests            AccountRequestSlice
	BankAccountRequestHistories    AccountRequestHistorySlice
	BankAccountTypes               AccountTypeSlice
	BankAddresses                  AddressSlice
	BankBeneficiaries              BeneficiarySlice
	BankBorrowers                  BorrowerSlice
	BankBranches                   BranchSlice
	BankCryptographies             CryptographySlice
	BankCustomerOffers             CustomerOfferSlice
	BankDevices                    DeviceSlice
	BankDirectDebits               DirectDebitSlice
	BankEmails                     EmailSlice
	BankGLAccounts                 GLAccountSlice
	BankJointAccounts              JointAccountSlice
	PostedBankKeyJournalEntries    JournalEntrySlice
	BankKYCS                       KYCSlice
	BankOrganizations              OrganizationSlice
	BankOrganizationContacts       OrganizationContactSlice
	BankOrganizationFinancialInfos OrganizationFinancialInfoSlice
	BankParties                    PartySlice
	BankPaymentCheques             PaymentChequeSlice
	BankPaymentFxTrades            PaymentFxTradeSlice
	BankPersons                    PersonSlice
	BankPersonFinancialInfos       PersonFinancialInfoSlice
	BankPhoneNumbers               PhoneNumberSlice
	BankProducts                   ProductSlice
	BankSocialInfos                SocialInfoSlice
	BankStandingOrders             StandingOrderSlice
	BankTFBankGuarantees           TFBankGuaranteeSlice
	BankTFLetterOfCredits          TFLetterOfCreditSlice
	BankTFLetterOfCreditTxns       TFLetterOfCreditTxnSlice
	ConfirmingBankTrades           TradeSlice
	IssueingBankTrades             TradeSlice
	BankTransactions               TransactionSlice
}

// NewStruct creates a new relationship struct
func (*bankR) NewStruct() *bankR {
	return &bankR{}
}

// bankL is where Load methods for each relationship are stored.
type bankL struct{}

var (
	bankColumns               = []string{"bank_id", "bank_reg_number", "bank_identification_code", "bank_name", "country", "registered_address", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	bankColumnsWithoutDefault = []string{"bank_reg_number", "bank_identification_code", "bank_name", "country", "registered_address", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	bankColumnsWithDefault    = []string{"bank_id"}
	bankPrimaryKeyColumns     = []string{"bank_id"}
)

type (
	// BankSlice is an alias for a slice of pointers to Bank.
	// This should generally be used opposed to []Bank.
	BankSlice []*Bank
	// BankHook is the signature for custom Bank hook methods
	BankHook func(context.Context, boil.ContextExecutor, *Bank) error

	bankQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	bankType                 = reflect.TypeOf(&Bank{})
	bankMapping              = queries.MakeStructMapping(bankType)
	bankPrimaryKeyMapping, _ = queries.BindMapping(bankType, bankMapping, bankPrimaryKeyColumns)
	bankInsertCacheMut       sync.RWMutex
	bankInsertCache          = make(map[string]insertCache)
	bankUpdateCacheMut       sync.RWMutex
	bankUpdateCache          = make(map[string]updateCache)
	bankUpsertCacheMut       sync.RWMutex
	bankUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var bankBeforeInsertHooks []BankHook
var bankBeforeUpdateHooks []BankHook
var bankBeforeDeleteHooks []BankHook
var bankBeforeUpsertHooks []BankHook

var bankAfterInsertHooks []BankHook
var bankAfterSelectHooks []BankHook
var bankAfterUpdateHooks []BankHook
var bankAfterDeleteHooks []BankHook
var bankAfterUpsertHooks []BankHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Bank) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Bank) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Bank) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Bank) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Bank) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Bank) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Bank) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Bank) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Bank) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bankAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBankHook registers your hook function for all future operations.
func AddBankHook(hookPoint boil.HookPoint, bankHook BankHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		bankBeforeInsertHooks = append(bankBeforeInsertHooks, bankHook)
	case boil.BeforeUpdateHook:
		bankBeforeUpdateHooks = append(bankBeforeUpdateHooks, bankHook)
	case boil.BeforeDeleteHook:
		bankBeforeDeleteHooks = append(bankBeforeDeleteHooks, bankHook)
	case boil.BeforeUpsertHook:
		bankBeforeUpsertHooks = append(bankBeforeUpsertHooks, bankHook)
	case boil.AfterInsertHook:
		bankAfterInsertHooks = append(bankAfterInsertHooks, bankHook)
	case boil.AfterSelectHook:
		bankAfterSelectHooks = append(bankAfterSelectHooks, bankHook)
	case boil.AfterUpdateHook:
		bankAfterUpdateHooks = append(bankAfterUpdateHooks, bankHook)
	case boil.AfterDeleteHook:
		bankAfterDeleteHooks = append(bankAfterDeleteHooks, bankHook)
	case boil.AfterUpsertHook:
		bankAfterUpsertHooks = append(bankAfterUpsertHooks, bankHook)
	}
}

// One returns a single bank record from the query.
func (q bankQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Bank, error) {
	o := &Bank{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Banks")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Bank records from the query.
func (q bankQuery) All(ctx context.Context, exec boil.ContextExecutor) (BankSlice, error) {
	var o []*Bank

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Bank slice")
	}

	if len(bankAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Bank records in the query.
func (q bankQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Banks rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q bankQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Banks exists")
	}

	return count > 0, nil
}

// BankAccounts retrieves all the Account's Accounts with an executor via bank_id column.
func (o *Bank) BankAccounts(mods ...qm.QueryMod) accountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Account`.`bank_id`=?", o.BankID),
	)

	query := Accounts(queryMods...)
	queries.SetFrom(query.Query, "`Account`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Account`.*"})
	}

	return query
}

// BankAccountOwners retrieves all the AccountOwner's AccountOwners with an executor via bank_id column.
func (o *Bank) BankAccountOwners(mods ...qm.QueryMod) accountOwnerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountOwners`.`bank_id`=?", o.BankID),
	)

	query := AccountOwners(queryMods...)
	queries.SetFrom(query.Query, "`AccountOwners`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountOwners`.*"})
	}

	return query
}

// BankAccountRequests retrieves all the AccountRequest's AccountRequests with an executor via bank_id column.
func (o *Bank) BankAccountRequests(mods ...qm.QueryMod) accountRequestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountRequest`.`bank_id`=?", o.BankID),
	)

	query := AccountRequests(queryMods...)
	queries.SetFrom(query.Query, "`AccountRequest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountRequest`.*"})
	}

	return query
}

// BankAccountRequestHistories retrieves all the AccountRequestHistory's AccountRequestHistories with an executor via bank_id column.
func (o *Bank) BankAccountRequestHistories(mods ...qm.QueryMod) accountRequestHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountRequestHistory`.`bank_id`=?", o.BankID),
	)

	query := AccountRequestHistories(queryMods...)
	queries.SetFrom(query.Query, "`AccountRequestHistory`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountRequestHistory`.*"})
	}

	return query
}

// BankAccountTypes retrieves all the AccountType's AccountTypes with an executor via bank_id column.
func (o *Bank) BankAccountTypes(mods ...qm.QueryMod) accountTypeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`AccountType`.`bank_id`=?", o.BankID),
	)

	query := AccountTypes(queryMods...)
	queries.SetFrom(query.Query, "`AccountType`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`AccountType`.*"})
	}

	return query
}

// BankAddresses retrieves all the Address's Addresses with an executor via bank_id column.
func (o *Bank) BankAddresses(mods ...qm.QueryMod) addressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Address`.`bank_id`=?", o.BankID),
	)

	query := Addresses(queryMods...)
	queries.SetFrom(query.Query, "`Address`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Address`.*"})
	}

	return query
}

// BankBeneficiaries retrieves all the Beneficiary's Beneficiaries with an executor via bank_id column.
func (o *Bank) BankBeneficiaries(mods ...qm.QueryMod) beneficiaryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Beneficiary`.`bank_id`=?", o.BankID),
	)

	query := Beneficiaries(queryMods...)
	queries.SetFrom(query.Query, "`Beneficiary`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Beneficiary`.*"})
	}

	return query
}

// BankBorrowers retrieves all the Borrower's Borrowers with an executor via bank_id column.
func (o *Bank) BankBorrowers(mods ...qm.QueryMod) borrowerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Borrower`.`bank_id`=?", o.BankID),
	)

	query := Borrowers(queryMods...)
	queries.SetFrom(query.Query, "`Borrower`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Borrower`.*"})
	}

	return query
}

// BankBranches retrieves all the Branch's Branches with an executor via bank_id column.
func (o *Bank) BankBranches(mods ...qm.QueryMod) branchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Branches`.`bank_id`=?", o.BankID),
	)

	query := Branches(queryMods...)
	queries.SetFrom(query.Query, "`Branches`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Branches`.*"})
	}

	return query
}

// BankCryptographies retrieves all the Cryptography's Cryptographies with an executor via bank_id column.
func (o *Bank) BankCryptographies(mods ...qm.QueryMod) cryptographyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Cryptography`.`bank_id`=?", o.BankID),
	)

	query := Cryptographies(queryMods...)
	queries.SetFrom(query.Query, "`Cryptography`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Cryptography`.*"})
	}

	return query
}

// BankCustomerOffers retrieves all the CustomerOffer's CustomerOffers with an executor via bank_id column.
func (o *Bank) BankCustomerOffers(mods ...qm.QueryMod) customerOfferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`CustomerOffer`.`bank_id`=?", o.BankID),
	)

	query := CustomerOffers(queryMods...)
	queries.SetFrom(query.Query, "`CustomerOffer`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`CustomerOffer`.*"})
	}

	return query
}

// BankDevices retrieves all the Device's Devices with an executor via bank_id column.
func (o *Bank) BankDevices(mods ...qm.QueryMod) deviceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Devices`.`bank_id`=?", o.BankID),
	)

	query := Devices(queryMods...)
	queries.SetFrom(query.Query, "`Devices`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Devices`.*"})
	}

	return query
}

// BankDirectDebits retrieves all the DirectDebit's DirectDebits with an executor via bank_id column.
func (o *Bank) BankDirectDebits(mods ...qm.QueryMod) directDebitQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`DirectDebits`.`bank_id`=?", o.BankID),
	)

	query := DirectDebits(queryMods...)
	queries.SetFrom(query.Query, "`DirectDebits`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`DirectDebits`.*"})
	}

	return query
}

// BankEmails retrieves all the Email's Emails with an executor via bank_id column.
func (o *Bank) BankEmails(mods ...qm.QueryMod) emailQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Emails`.`bank_id`=?", o.BankID),
	)

	query := Emails(queryMods...)
	queries.SetFrom(query.Query, "`Emails`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Emails`.*"})
	}

	return query
}

// BankGLAccounts retrieves all the GLAccount's GLAccounts with an executor via bank_id column.
func (o *Bank) BankGLAccounts(mods ...qm.QueryMod) gLAccountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`GLAccount`.`bank_id`=?", o.BankID),
	)

	query := GLAccounts(queryMods...)
	queries.SetFrom(query.Query, "`GLAccount`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`GLAccount`.*"})
	}

	return query
}

// BankJointAccounts retrieves all the JointAccount's JointAccounts with an executor via bank_id column.
func (o *Bank) BankJointAccounts(mods ...qm.QueryMod) jointAccountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JointAccount`.`bank_id`=?", o.BankID),
	)

	query := JointAccounts(queryMods...)
	queries.SetFrom(query.Query, "`JointAccount`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JointAccount`.*"})
	}

	return query
}

// PostedBankKeyJournalEntries retrieves all the JournalEntry's JournalEntries with an executor via posted_bank_key column.
func (o *Bank) PostedBankKeyJournalEntries(mods ...qm.QueryMod) journalEntryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`JournalEntry`.`posted_bank_key`=?", o.BankID),
	)

	query := JournalEntries(queryMods...)
	queries.SetFrom(query.Query, "`JournalEntry`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`JournalEntry`.*"})
	}

	return query
}

// BankKYCS retrieves all the KYC's KYCS with an executor via bank_id column.
func (o *Bank) BankKYCS(mods ...qm.QueryMod) kYCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`KYC`.`bank_id`=?", o.BankID),
	)

	query := KYCS(queryMods...)
	queries.SetFrom(query.Query, "`KYC`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`KYC`.*"})
	}

	return query
}

// BankOrganizations retrieves all the Organization's Organizations with an executor via bank_id column.
func (o *Bank) BankOrganizations(mods ...qm.QueryMod) organizationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Organization`.`bank_id`=?", o.BankID),
	)

	query := Organizations(queryMods...)
	queries.SetFrom(query.Query, "`Organization`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Organization`.*"})
	}

	return query
}

// BankOrganizationContacts retrieves all the OrganizationContact's OrganizationContacts with an executor via bank_id column.
func (o *Bank) BankOrganizationContacts(mods ...qm.QueryMod) organizationContactQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`OrganizationContacts`.`bank_id`=?", o.BankID),
	)

	query := OrganizationContacts(queryMods...)
	queries.SetFrom(query.Query, "`OrganizationContacts`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`OrganizationContacts`.*"})
	}

	return query
}

// BankOrganizationFinancialInfos retrieves all the OrganizationFinancialInfo's OrganizationFinancialInfos with an executor via bank_id column.
func (o *Bank) BankOrganizationFinancialInfos(mods ...qm.QueryMod) organizationFinancialInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`OrganizationFinancialInfo`.`bank_id`=?", o.BankID),
	)

	query := OrganizationFinancialInfos(queryMods...)
	queries.SetFrom(query.Query, "`OrganizationFinancialInfo`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`OrganizationFinancialInfo`.*"})
	}

	return query
}

// BankParties retrieves all the Party's Parties with an executor via bank_id column.
func (o *Bank) BankParties(mods ...qm.QueryMod) partyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Parties`.`bank_id`=?", o.BankID),
	)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Parties`.*"})
	}

	return query
}

// BankPaymentCheques retrieves all the PaymentCheque's PaymentCheques with an executor via bank_id column.
func (o *Bank) BankPaymentCheques(mods ...qm.QueryMod) paymentChequeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentCheque`.`bank_id`=?", o.BankID),
	)

	query := PaymentCheques(queryMods...)
	queries.SetFrom(query.Query, "`PaymentCheque`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentCheque`.*"})
	}

	return query
}

// BankPaymentFxTrades retrieves all the PaymentFxTrade's PaymentFxTrades with an executor via bank_id column.
func (o *Bank) BankPaymentFxTrades(mods ...qm.QueryMod) paymentFxTradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentFxTrade`.`bank_id`=?", o.BankID),
	)

	query := PaymentFxTrades(queryMods...)
	queries.SetFrom(query.Query, "`PaymentFxTrade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentFxTrade`.*"})
	}

	return query
}

// BankPersons retrieves all the Person's Persons with an executor via bank_id column.
func (o *Bank) BankPersons(mods ...qm.QueryMod) personQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Person`.`bank_id`=?", o.BankID),
	)

	query := Persons(queryMods...)
	queries.SetFrom(query.Query, "`Person`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Person`.*"})
	}

	return query
}

// BankPersonFinancialInfos retrieves all the PersonFinancialInfo's PersonFinancialInfos with an executor via bank_id column.
func (o *Bank) BankPersonFinancialInfos(mods ...qm.QueryMod) personFinancialInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PersonFinancialInfo`.`bank_id`=?", o.BankID),
	)

	query := PersonFinancialInfos(queryMods...)
	queries.SetFrom(query.Query, "`PersonFinancialInfo`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PersonFinancialInfo`.*"})
	}

	return query
}

// BankPhoneNumbers retrieves all the PhoneNumber's PhoneNumbers with an executor via bank_id column.
func (o *Bank) BankPhoneNumbers(mods ...qm.QueryMod) phoneNumberQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PhoneNumbers`.`bank_id`=?", o.BankID),
	)

	query := PhoneNumbers(queryMods...)
	queries.SetFrom(query.Query, "`PhoneNumbers`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PhoneNumbers`.*"})
	}

	return query
}

// BankProducts retrieves all the Product's Products with an executor via bank_id column.
func (o *Bank) BankProducts(mods ...qm.QueryMod) productQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Product`.`bank_id`=?", o.BankID),
	)

	query := Products(queryMods...)
	queries.SetFrom(query.Query, "`Product`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Product`.*"})
	}

	return query
}

// BankSocialInfos retrieves all the SocialInfo's SocialInfos with an executor via bank_id column.
func (o *Bank) BankSocialInfos(mods ...qm.QueryMod) socialInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`SocialInfo`.`bank_id`=?", o.BankID),
	)

	query := SocialInfos(queryMods...)
	queries.SetFrom(query.Query, "`SocialInfo`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`SocialInfo`.*"})
	}

	return query
}

// BankStandingOrders retrieves all the StandingOrder's StandingOrders with an executor via bank_id column.
func (o *Bank) BankStandingOrders(mods ...qm.QueryMod) standingOrderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`StandingOrders`.`bank_id`=?", o.BankID),
	)

	query := StandingOrders(queryMods...)
	queries.SetFrom(query.Query, "`StandingOrders`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`StandingOrders`.*"})
	}

	return query
}

// BankTFBankGuarantees retrieves all the TFBankGuarantee's TFBankGuarantees with an executor via bank_id column.
func (o *Bank) BankTFBankGuarantees(mods ...qm.QueryMod) tFBankGuaranteeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFBankGuarantee`.`bank_id`=?", o.BankID),
	)

	query := TFBankGuarantees(queryMods...)
	queries.SetFrom(query.Query, "`TFBankGuarantee`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFBankGuarantee`.*"})
	}

	return query
}

// BankTFLetterOfCredits retrieves all the TFLetterOfCredit's TFLetterOfCredits with an executor via bank_id column.
func (o *Bank) BankTFLetterOfCredits(mods ...qm.QueryMod) tFLetterOfCreditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLetterOfCredit`.`bank_id`=?", o.BankID),
	)

	query := TFLetterOfCredits(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCredit`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLetterOfCredit`.*"})
	}

	return query
}

// BankTFLetterOfCreditTxns retrieves all the TFLetterOfCreditTxn's TFLetterOfCreditTxns with an executor via bank_id column.
func (o *Bank) BankTFLetterOfCreditTxns(mods ...qm.QueryMod) tFLetterOfCreditTxnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`TFLetterOfCreditTxn`.`bank_id`=?", o.BankID),
	)

	query := TFLetterOfCreditTxns(queryMods...)
	queries.SetFrom(query.Query, "`TFLetterOfCreditTxn`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`TFLetterOfCreditTxn`.*"})
	}

	return query
}

// ConfirmingBankTrades retrieves all the Trade's Trades with an executor via confirming_bank_id column.
func (o *Bank) ConfirmingBankTrades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Trade`.`confirming_bank_id`=?", o.BankID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "`Trade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Trade`.*"})
	}

	return query
}

// IssueingBankTrades retrieves all the Trade's Trades with an executor via issueing_bank_id column.
func (o *Bank) IssueingBankTrades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Trade`.`issueing_bank_id`=?", o.BankID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "`Trade`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Trade`.*"})
	}

	return query
}

// BankTransactions retrieves all the Transaction's Transactions with an executor via bank_id column.
func (o *Bank) BankTransactions(mods ...qm.QueryMod) transactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Transaction`.`bank_id`=?", o.BankID),
	)

	query := Transactions(queryMods...)
	queries.SetFrom(query.Query, "`Transaction`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Transaction`.*"})
	}

	return query
}

// LoadBankAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Account`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Account")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Account")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAccounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankAccounts = append(local.R.BankAccounts, foreign)
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankAccountOwners allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAccountOwners(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountOwners`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountOwners")
	}

	var resultSlice []*AccountOwner
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountOwners")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountOwners")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountOwners")
	}

	if len(accountOwnerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAccountOwners = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountOwnerR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankAccountOwners = append(local.R.BankAccountOwners, foreign)
				if foreign.R == nil {
					foreign.R = &accountOwnerR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankAccountRequests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAccountRequests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountRequest`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountRequest")
	}

	var resultSlice []*AccountRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountRequest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountRequest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountRequest")
	}

	if len(accountRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAccountRequests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountRequestR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.BankAccountRequests = append(local.R.BankAccountRequests, foreign)
				if foreign.R == nil {
					foreign.R = &accountRequestR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankAccountRequestHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAccountRequestHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountRequestHistory`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountRequestHistory")
	}

	var resultSlice []*AccountRequestHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountRequestHistory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountRequestHistory")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountRequestHistory")
	}

	if len(accountRequestHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAccountRequestHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountRequestHistoryR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.BankAccountRequestHistories = append(local.R.BankAccountRequestHistories, foreign)
				if foreign.R == nil {
					foreign.R = &accountRequestHistoryR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankAccountTypes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAccountTypes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`AccountType`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AccountType")
	}

	var resultSlice []*AccountType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AccountType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on AccountType")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for AccountType")
	}

	if len(accountTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAccountTypes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountTypeR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankAccountTypes = append(local.R.BankAccountTypes, foreign)
				if foreign.R == nil {
					foreign.R = &accountTypeR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Address`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Address")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Address")
	}

	if len(addressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &addressR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankAddresses = append(local.R.BankAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankBeneficiaries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankBeneficiaries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Beneficiary`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Beneficiary")
	}

	var resultSlice []*Beneficiary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Beneficiary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Beneficiary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Beneficiary")
	}

	if len(beneficiaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankBeneficiaries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &beneficiaryR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankBeneficiaries = append(local.R.BankBeneficiaries, foreign)
				if foreign.R == nil {
					foreign.R = &beneficiaryR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankBorrowers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankBorrowers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Borrower`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Borrower")
	}

	var resultSlice []*Borrower
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Borrower")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Borrower")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Borrower")
	}

	if len(borrowerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankBorrowers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &borrowerR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankBorrowers = append(local.R.BankBorrowers, foreign)
				if foreign.R == nil {
					foreign.R = &borrowerR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankBranches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankBranches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Branches`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Branches")
	}

	var resultSlice []*Branch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Branches")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Branches")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Branches")
	}

	if len(branchAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankBranches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &branchR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankBranches = append(local.R.BankBranches, foreign)
				if foreign.R == nil {
					foreign.R = &branchR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankCryptographies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankCryptographies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Cryptography`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Cryptography")
	}

	var resultSlice []*Cryptography
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Cryptography")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Cryptography")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Cryptography")
	}

	if len(cryptographyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankCryptographies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cryptographyR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankCryptographies = append(local.R.BankCryptographies, foreign)
				if foreign.R == nil {
					foreign.R = &cryptographyR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankCustomerOffers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankCustomerOffers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CustomerOffer`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerOffer")
	}

	var resultSlice []*CustomerOffer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerOffer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on CustomerOffer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CustomerOffer")
	}

	if len(customerOfferAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankCustomerOffers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerOfferR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.BankCustomerOffers = append(local.R.BankCustomerOffers, foreign)
				if foreign.R == nil {
					foreign.R = &customerOfferR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankDevices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankDevices(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Devices`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Devices")
	}

	var resultSlice []*Device
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Devices")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Devices")
	}

	if len(deviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankDevices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankDevices = append(local.R.BankDevices, foreign)
				if foreign.R == nil {
					foreign.R = &deviceR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankDirectDebits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankDirectDebits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`DirectDebits`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DirectDebits")
	}

	var resultSlice []*DirectDebit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DirectDebits")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on DirectDebits")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for DirectDebits")
	}

	if len(directDebitAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankDirectDebits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &directDebitR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankDirectDebits = append(local.R.BankDirectDebits, foreign)
				if foreign.R == nil {
					foreign.R = &directDebitR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankEmails allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankEmails(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Emails`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Emails")
	}

	var resultSlice []*Email
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Emails")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Emails")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Emails")
	}

	if len(emailAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankEmails = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emailR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankEmails = append(local.R.BankEmails, foreign)
				if foreign.R == nil {
					foreign.R = &emailR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankGLAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankGLAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`GLAccount`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GLAccount")
	}

	var resultSlice []*GLAccount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GLAccount")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on GLAccount")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for GLAccount")
	}

	if len(gLAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankGLAccounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &gLAccountR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankGLAccounts = append(local.R.BankGLAccounts, foreign)
				if foreign.R == nil {
					foreign.R = &gLAccountR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankJointAccounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankJointAccounts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JointAccount`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JointAccount")
	}

	var resultSlice []*JointAccount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JointAccount")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JointAccount")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JointAccount")
	}

	if len(jointAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankJointAccounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &jointAccountR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankJointAccounts = append(local.R.BankJointAccounts, foreign)
				if foreign.R == nil {
					foreign.R = &jointAccountR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadPostedBankKeyJournalEntries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadPostedBankKeyJournalEntries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`JournalEntry`), qm.WhereIn(`posted_bank_key in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load JournalEntry")
	}

	var resultSlice []*JournalEntry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice JournalEntry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on JournalEntry")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for JournalEntry")
	}

	if len(journalEntryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PostedBankKeyJournalEntries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &journalEntryR{}
			}
			foreign.R.PostedBankKey = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.PostedBankKey) {
				local.R.PostedBankKeyJournalEntries = append(local.R.PostedBankKeyJournalEntries, foreign)
				if foreign.R == nil {
					foreign.R = &journalEntryR{}
				}
				foreign.R.PostedBankKey = local
				break
			}
		}
	}

	return nil
}

// LoadBankKYCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankKYCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`KYC`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load KYC")
	}

	var resultSlice []*KYC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice KYC")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on KYC")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for KYC")
	}

	if len(kYCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankKYCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &kYCR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankKYCS = append(local.R.BankKYCS, foreign)
				if foreign.R == nil {
					foreign.R = &kYCR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankOrganizations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankOrganizations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Organization`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Organization")
	}

	var resultSlice []*Organization
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Organization")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Organization")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Organization")
	}

	if len(organizationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankOrganizations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &organizationR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.BankOrganizations = append(local.R.BankOrganizations, foreign)
				if foreign.R == nil {
					foreign.R = &organizationR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankOrganizationContacts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankOrganizationContacts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`OrganizationContacts`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrganizationContacts")
	}

	var resultSlice []*OrganizationContact
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrganizationContacts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on OrganizationContacts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for OrganizationContacts")
	}

	if len(organizationContactAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankOrganizationContacts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &organizationContactR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankOrganizationContacts = append(local.R.BankOrganizationContacts, foreign)
				if foreign.R == nil {
					foreign.R = &organizationContactR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankOrganizationFinancialInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankOrganizationFinancialInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`OrganizationFinancialInfo`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrganizationFinancialInfo")
	}

	var resultSlice []*OrganizationFinancialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrganizationFinancialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on OrganizationFinancialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for OrganizationFinancialInfo")
	}

	if len(organizationFinancialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankOrganizationFinancialInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &organizationFinancialInfoR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankOrganizationFinancialInfos = append(local.R.BankOrganizationFinancialInfos, foreign)
				if foreign.R == nil {
					foreign.R = &organizationFinancialInfoR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankParties allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankParties(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Parties")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Parties")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(partyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankParties = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &partyR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankParties = append(local.R.BankParties, foreign)
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankPaymentCheques allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankPaymentCheques(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentCheque`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentCheque")
	}

	var resultSlice []*PaymentCheque
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentCheque")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentCheque")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentCheque")
	}

	if len(paymentChequeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankPaymentCheques = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentChequeR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankPaymentCheques = append(local.R.BankPaymentCheques, foreign)
				if foreign.R == nil {
					foreign.R = &paymentChequeR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankPaymentFxTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankPaymentFxTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentFxTrade`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentFxTrade")
	}

	var resultSlice []*PaymentFxTrade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentFxTrade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentFxTrade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentFxTrade")
	}

	if len(paymentFxTradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankPaymentFxTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentFxTradeR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankPaymentFxTrades = append(local.R.BankPaymentFxTrades, foreign)
				if foreign.R == nil {
					foreign.R = &paymentFxTradeR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankPersons allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankPersons(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Person`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Person")
	}

	var resultSlice []*Person
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Person")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Person")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Person")
	}

	if len(personAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankPersons = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &personR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.BankPersons = append(local.R.BankPersons, foreign)
				if foreign.R == nil {
					foreign.R = &personR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankPersonFinancialInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankPersonFinancialInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PersonFinancialInfo`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PersonFinancialInfo")
	}

	var resultSlice []*PersonFinancialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PersonFinancialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PersonFinancialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PersonFinancialInfo")
	}

	if len(personFinancialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankPersonFinancialInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &personFinancialInfoR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankPersonFinancialInfos = append(local.R.BankPersonFinancialInfos, foreign)
				if foreign.R == nil {
					foreign.R = &personFinancialInfoR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankPhoneNumbers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankPhoneNumbers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PhoneNumbers`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PhoneNumbers")
	}

	var resultSlice []*PhoneNumber
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PhoneNumbers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PhoneNumbers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PhoneNumbers")
	}

	if len(phoneNumberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankPhoneNumbers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &phoneNumberR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankPhoneNumbers = append(local.R.BankPhoneNumbers, foreign)
				if foreign.R == nil {
					foreign.R = &phoneNumberR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankProducts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankProducts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Product`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Product")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Product")
	}

	if len(productAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankProducts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankProducts = append(local.R.BankProducts, foreign)
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankSocialInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankSocialInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`SocialInfo`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SocialInfo")
	}

	var resultSlice []*SocialInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SocialInfo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on SocialInfo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for SocialInfo")
	}

	if len(socialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankSocialInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &socialInfoR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankSocialInfos = append(local.R.BankSocialInfos, foreign)
				if foreign.R == nil {
					foreign.R = &socialInfoR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankStandingOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankStandingOrders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`StandingOrders`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load StandingOrders")
	}

	var resultSlice []*StandingOrder
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice StandingOrders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on StandingOrders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for StandingOrders")
	}

	if len(standingOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankStandingOrders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &standingOrderR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankStandingOrders = append(local.R.BankStandingOrders, foreign)
				if foreign.R == nil {
					foreign.R = &standingOrderR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankTFBankGuarantees allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankTFBankGuarantees(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFBankGuarantee`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFBankGuarantee")
	}

	var resultSlice []*TFBankGuarantee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFBankGuarantee")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFBankGuarantee")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFBankGuarantee")
	}

	if len(tFBankGuaranteeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankTFBankGuarantees = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFBankGuaranteeR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankTFBankGuarantees = append(local.R.BankTFBankGuarantees, foreign)
				if foreign.R == nil {
					foreign.R = &tFBankGuaranteeR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankTFLetterOfCredits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankTFLetterOfCredits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCredit`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCredit")
	}

	var resultSlice []*TFLetterOfCredit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCredit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLetterOfCredit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCredit")
	}

	if len(tFLetterOfCreditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankTFLetterOfCredits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLetterOfCreditR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankTFLetterOfCredits = append(local.R.BankTFLetterOfCredits, foreign)
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadBankTFLetterOfCreditTxns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankTFLetterOfCreditTxns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`TFLetterOfCreditTxn`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TFLetterOfCreditTxn")
	}

	var resultSlice []*TFLetterOfCreditTxn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TFLetterOfCreditTxn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on TFLetterOfCreditTxn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for TFLetterOfCreditTxn")
	}

	if len(tFLetterOfCreditTxnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankTFLetterOfCreditTxns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tFLetterOfCreditTxnR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankTFLetterOfCreditTxns = append(local.R.BankTFLetterOfCreditTxns, foreign)
				if foreign.R == nil {
					foreign.R = &tFLetterOfCreditTxnR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// LoadConfirmingBankTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadConfirmingBankTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Trade`), qm.WhereIn(`confirming_bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Trade")
	}

	if len(tradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ConfirmingBankTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.ConfirmingBank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.ConfirmingBankID {
				local.R.ConfirmingBankTrades = append(local.R.ConfirmingBankTrades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.ConfirmingBank = local
				break
			}
		}
	}

	return nil
}

// LoadIssueingBankTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadIssueingBankTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Trade`), qm.WhereIn(`issueing_bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Trade")
	}

	if len(tradeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssueingBankTrades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.IssueingBank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.IssueingBankID {
				local.R.IssueingBankTrades = append(local.R.IssueingBankTrades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.IssueingBank = local
				break
			}
		}
	}

	return nil
}

// LoadBankTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (bankL) LoadBankTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBank interface{}, mods queries.Applicator) error {
	var slice []*Bank
	var object *Bank

	if singular {
		object = maybeBank.(*Bank)
	} else {
		slice = *maybeBank.(*[]*Bank)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bankR{}
		}
		args = append(args, object.BankID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bankR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Transaction`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Transaction")
	}

	var resultSlice []*Transaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Transaction")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BankTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transactionR{}
			}
			foreign.R.Bank = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BankID == foreign.BankID {
				local.R.BankTransactions = append(local.R.BankTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &transactionR{}
				}
				foreign.R.Bank = local
				break
			}
		}
	}

	return nil
}

// AddBankAccounts adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAccounts.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Account) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Account` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, accountPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAccounts: related,
		}
	} else {
		o.R.BankAccounts = append(o.R.BankAccounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankAccountOwners adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAccountOwners.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAccountOwners(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountOwner) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountOwners` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, accountOwnerPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountOwnerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAccountOwners: related,
		}
	} else {
		o.R.BankAccountOwners = append(o.R.BankAccountOwners, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountOwnerR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankAccountRequests adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAccountRequests.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAccountRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequest) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.BankID, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountRequest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, accountRequestPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountRequestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.BankID, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAccountRequests: related,
		}
	} else {
		o.R.BankAccountRequests = append(o.R.BankAccountRequests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountRequestR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// SetBankAccountRequests removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Bank's BankAccountRequests accordingly.
// Replaces o.R.BankAccountRequests with related.
// Sets related.R.Bank's BankAccountRequests accordingly.
func (o *Bank) SetBankAccountRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequest) error {
	query := "update `AccountRequest` set `bank_id` = null where `bank_id` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BankAccountRequests {
			queries.SetScanner(&rel.BankID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Bank = nil
		}

		o.R.BankAccountRequests = nil
	}
	return o.AddBankAccountRequests(ctx, exec, insert, related...)
}

// RemoveBankAccountRequests relationships from objects passed in.
// Removes related items from R.BankAccountRequests (uses pointer comparison, removal does not keep order)
// Sets related.R.Bank.
func (o *Bank) RemoveBankAccountRequests(ctx context.Context, exec boil.ContextExecutor, related ...*AccountRequest) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.BankID, nil)
		if rel.R != nil {
			rel.R.Bank = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BankAccountRequests {
			if rel != ri {
				continue
			}

			ln := len(o.R.BankAccountRequests)
			if ln > 1 && i < ln-1 {
				o.R.BankAccountRequests[i] = o.R.BankAccountRequests[ln-1]
			}
			o.R.BankAccountRequests = o.R.BankAccountRequests[:ln-1]
			break
		}
	}

	return nil
}

// AddBankAccountRequestHistories adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAccountRequestHistories.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequestHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.BankID, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountRequestHistory` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountRequestHistoryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.BankID, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAccountRequestHistories: related,
		}
	} else {
		o.R.BankAccountRequestHistories = append(o.R.BankAccountRequestHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountRequestHistoryR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// SetBankAccountRequestHistories removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Bank's BankAccountRequestHistories accordingly.
// Replaces o.R.BankAccountRequestHistories with related.
// Sets related.R.Bank's BankAccountRequestHistories accordingly.
func (o *Bank) SetBankAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountRequestHistory) error {
	query := "update `AccountRequestHistory` set `bank_id` = null where `bank_id` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BankAccountRequestHistories {
			queries.SetScanner(&rel.BankID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Bank = nil
		}

		o.R.BankAccountRequestHistories = nil
	}
	return o.AddBankAccountRequestHistories(ctx, exec, insert, related...)
}

// RemoveBankAccountRequestHistories relationships from objects passed in.
// Removes related items from R.BankAccountRequestHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Bank.
func (o *Bank) RemoveBankAccountRequestHistories(ctx context.Context, exec boil.ContextExecutor, related ...*AccountRequestHistory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.BankID, nil)
		if rel.R != nil {
			rel.R.Bank = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BankAccountRequestHistories {
			if rel != ri {
				continue
			}

			ln := len(o.R.BankAccountRequestHistories)
			if ln > 1 && i < ln-1 {
				o.R.BankAccountRequestHistories[i] = o.R.BankAccountRequestHistories[ln-1]
			}
			o.R.BankAccountRequestHistories = o.R.BankAccountRequestHistories[:ln-1]
			break
		}
	}

	return nil
}

// AddBankAccountTypes adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAccountTypes.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAccountTypes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountType) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `AccountType` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, accountTypePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountTypeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAccountTypes: related,
		}
	} else {
		o.R.BankAccountTypes = append(o.R.BankAccountTypes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountTypeR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankAddresses adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankAddresses.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Address) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Address` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, addressPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AddressID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankAddresses: related,
		}
	} else {
		o.R.BankAddresses = append(o.R.BankAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &addressR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankBeneficiaries adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankBeneficiaries.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankBeneficiaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Beneficiary) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Beneficiary` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, beneficiaryPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.BeneficiaryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankBeneficiaries: related,
		}
	} else {
		o.R.BankBeneficiaries = append(o.R.BankBeneficiaries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &beneficiaryR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankBorrowers adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankBorrowers.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankBorrowers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Borrower) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Borrower` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, borrowerPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.BorrowerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankBorrowers: related,
		}
	} else {
		o.R.BankBorrowers = append(o.R.BankBorrowers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &borrowerR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankBranches adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankBranches.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankBranches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Branch) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Branches` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, branchPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.BranchID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankBranches: related,
		}
	} else {
		o.R.BankBranches = append(o.R.BankBranches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &branchR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankCryptographies adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankCryptographies.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankCryptographies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Cryptography) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Cryptography` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, cryptographyPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.CryptographyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankCryptographies: related,
		}
	} else {
		o.R.BankCryptographies = append(o.R.BankCryptographies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cryptographyR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankCustomerOffers adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankCustomerOffers.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankCustomerOffers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerOffer) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.BankID, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `CustomerOffer` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, customerOfferPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.CustomerOfferID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.BankID, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankCustomerOffers: related,
		}
	} else {
		o.R.BankCustomerOffers = append(o.R.BankCustomerOffers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerOfferR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// SetBankCustomerOffers removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Bank's BankCustomerOffers accordingly.
// Replaces o.R.BankCustomerOffers with related.
// Sets related.R.Bank's BankCustomerOffers accordingly.
func (o *Bank) SetBankCustomerOffers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerOffer) error {
	query := "update `CustomerOffer` set `bank_id` = null where `bank_id` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BankCustomerOffers {
			queries.SetScanner(&rel.BankID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Bank = nil
		}

		o.R.BankCustomerOffers = nil
	}
	return o.AddBankCustomerOffers(ctx, exec, insert, related...)
}

// RemoveBankCustomerOffers relationships from objects passed in.
// Removes related items from R.BankCustomerOffers (uses pointer comparison, removal does not keep order)
// Sets related.R.Bank.
func (o *Bank) RemoveBankCustomerOffers(ctx context.Context, exec boil.ContextExecutor, related ...*CustomerOffer) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.BankID, nil)
		if rel.R != nil {
			rel.R.Bank = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BankCustomerOffers {
			if rel != ri {
				continue
			}

			ln := len(o.R.BankCustomerOffers)
			if ln > 1 && i < ln-1 {
				o.R.BankCustomerOffers[i] = o.R.BankCustomerOffers[ln-1]
			}
			o.R.BankCustomerOffers = o.R.BankCustomerOffers[:ln-1]
			break
		}
	}

	return nil
}

// AddBankDevices adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankDevices.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankDevices(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Device) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Devices` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, devicePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.DevicesID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankDevices: related,
		}
	} else {
		o.R.BankDevices = append(o.R.BankDevices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankDirectDebits adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankDirectDebits.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankDirectDebits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DirectDebit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `DirectDebits` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, directDebitPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.DirectDebitID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankDirectDebits: related,
		}
	} else {
		o.R.BankDirectDebits = append(o.R.BankDirectDebits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &directDebitR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankEmails adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankEmails.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankEmails(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Email) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Emails` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, emailPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PartyID, rel.EmailType}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankEmails: related,
		}
	} else {
		o.R.BankEmails = append(o.R.BankEmails, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emailR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankGLAccounts adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankGLAccounts.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankGLAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*GLAccount) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `GLAccount` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, gLAccountPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.GLCode}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankGLAccounts: related,
		}
	} else {
		o.R.BankGLAccounts = append(o.R.BankGLAccounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &gLAccountR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankJointAccounts adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankJointAccounts.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankJointAccounts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JointAccount) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JointAccount` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, jointAccountPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.AccountID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankJointAccounts: related,
		}
	} else {
		o.R.BankJointAccounts = append(o.R.BankJointAccounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &jointAccountR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddPostedBankKeyJournalEntries adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.PostedBankKeyJournalEntries.
// Sets related.R.PostedBankKey appropriately.
func (o *Bank) AddPostedBankKeyJournalEntries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JournalEntry) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PostedBankKey, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `JournalEntry` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"posted_bank_key"}),
				strmangle.WhereClause("`", "`", 0, journalEntryPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.JournalEntryID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PostedBankKey, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			PostedBankKeyJournalEntries: related,
		}
	} else {
		o.R.PostedBankKeyJournalEntries = append(o.R.PostedBankKeyJournalEntries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &journalEntryR{
				PostedBankKey: o,
			}
		} else {
			rel.R.PostedBankKey = o
		}
	}
	return nil
}

// SetPostedBankKeyJournalEntries removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.PostedBankKey's PostedBankKeyJournalEntries accordingly.
// Replaces o.R.PostedBankKeyJournalEntries with related.
// Sets related.R.PostedBankKey's PostedBankKeyJournalEntries accordingly.
func (o *Bank) SetPostedBankKeyJournalEntries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*JournalEntry) error {
	query := "update `JournalEntry` set `posted_bank_key` = null where `posted_bank_key` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PostedBankKeyJournalEntries {
			queries.SetScanner(&rel.PostedBankKey, nil)
			if rel.R == nil {
				continue
			}

			rel.R.PostedBankKey = nil
		}

		o.R.PostedBankKeyJournalEntries = nil
	}
	return o.AddPostedBankKeyJournalEntries(ctx, exec, insert, related...)
}

// RemovePostedBankKeyJournalEntries relationships from objects passed in.
// Removes related items from R.PostedBankKeyJournalEntries (uses pointer comparison, removal does not keep order)
// Sets related.R.PostedBankKey.
func (o *Bank) RemovePostedBankKeyJournalEntries(ctx context.Context, exec boil.ContextExecutor, related ...*JournalEntry) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PostedBankKey, nil)
		if rel.R != nil {
			rel.R.PostedBankKey = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("posted_bank_key")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PostedBankKeyJournalEntries {
			if rel != ri {
				continue
			}

			ln := len(o.R.PostedBankKeyJournalEntries)
			if ln > 1 && i < ln-1 {
				o.R.PostedBankKeyJournalEntries[i] = o.R.PostedBankKeyJournalEntries[ln-1]
			}
			o.R.PostedBankKeyJournalEntries = o.R.PostedBankKeyJournalEntries[:ln-1]
			break
		}
	}

	return nil
}

// AddBankKYCS adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankKYCS.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankKYCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*KYC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `KYC` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, kYCPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.KycNumber}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankKYCS: related,
		}
	} else {
		o.R.BankKYCS = append(o.R.BankKYCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &kYCR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankOrganizations adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankOrganizations.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankOrganizations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Organization) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.BankID, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Organization` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, organizationPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.BankID, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankOrganizations: related,
		}
	} else {
		o.R.BankOrganizations = append(o.R.BankOrganizations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &organizationR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// SetBankOrganizations removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Bank's BankOrganizations accordingly.
// Replaces o.R.BankOrganizations with related.
// Sets related.R.Bank's BankOrganizations accordingly.
func (o *Bank) SetBankOrganizations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Organization) error {
	query := "update `Organization` set `bank_id` = null where `bank_id` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BankOrganizations {
			queries.SetScanner(&rel.BankID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Bank = nil
		}

		o.R.BankOrganizations = nil
	}
	return o.AddBankOrganizations(ctx, exec, insert, related...)
}

// RemoveBankOrganizations relationships from objects passed in.
// Removes related items from R.BankOrganizations (uses pointer comparison, removal does not keep order)
// Sets related.R.Bank.
func (o *Bank) RemoveBankOrganizations(ctx context.Context, exec boil.ContextExecutor, related ...*Organization) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.BankID, nil)
		if rel.R != nil {
			rel.R.Bank = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BankOrganizations {
			if rel != ri {
				continue
			}

			ln := len(o.R.BankOrganizations)
			if ln > 1 && i < ln-1 {
				o.R.BankOrganizations[i] = o.R.BankOrganizations[ln-1]
			}
			o.R.BankOrganizations = o.R.BankOrganizations[:ln-1]
			break
		}
	}

	return nil
}

// AddBankOrganizationContacts adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankOrganizationContacts.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankOrganizationContacts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrganizationContact) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `OrganizationContacts` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, organizationContactPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.OrganizationContactID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankOrganizationContacts: related,
		}
	} else {
		o.R.BankOrganizationContacts = append(o.R.BankOrganizationContacts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &organizationContactR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankOrganizationFinancialInfos adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankOrganizationFinancialInfos.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankOrganizationFinancialInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrganizationFinancialInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `OrganizationFinancialInfo` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, organizationFinancialInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.OrganizationFinancialInfoID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankOrganizationFinancialInfos: related,
		}
	} else {
		o.R.BankOrganizationFinancialInfos = append(o.R.BankOrganizationFinancialInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &organizationFinancialInfoR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankParties adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankParties.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankParties(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Party) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Parties` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, partyPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankParties: related,
		}
	} else {
		o.R.BankParties = append(o.R.BankParties, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &partyR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankPaymentCheques adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankPaymentCheques.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankPaymentCheques(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentCheque) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentCheque` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, paymentChequePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PaymentChequeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankPaymentCheques: related,
		}
	} else {
		o.R.BankPaymentCheques = append(o.R.BankPaymentCheques, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentChequeR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankPaymentFxTrades adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankPaymentFxTrades.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankPaymentFxTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentFxTrade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentFxTrade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, paymentFxTradePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PaymentFXTradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankPaymentFxTrades: related,
		}
	} else {
		o.R.BankPaymentFxTrades = append(o.R.BankPaymentFxTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentFxTradeR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankPersons adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankPersons.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankPersons(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Person) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.BankID, o.BankID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Person` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, personPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PartyID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.BankID, o.BankID)
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankPersons: related,
		}
	} else {
		o.R.BankPersons = append(o.R.BankPersons, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &personR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// SetBankPersons removes all previously related items of the
// Bank replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Bank's BankPersons accordingly.
// Replaces o.R.BankPersons with related.
// Sets related.R.Bank's BankPersons accordingly.
func (o *Bank) SetBankPersons(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Person) error {
	query := "update `Person` set `bank_id` = null where `bank_id` = ?"
	values := []interface{}{o.BankID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BankPersons {
			queries.SetScanner(&rel.BankID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Bank = nil
		}

		o.R.BankPersons = nil
	}
	return o.AddBankPersons(ctx, exec, insert, related...)
}

// RemoveBankPersons relationships from objects passed in.
// Removes related items from R.BankPersons (uses pointer comparison, removal does not keep order)
// Sets related.R.Bank.
func (o *Bank) RemoveBankPersons(ctx context.Context, exec boil.ContextExecutor, related ...*Person) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.BankID, nil)
		if rel.R != nil {
			rel.R.Bank = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BankPersons {
			if rel != ri {
				continue
			}

			ln := len(o.R.BankPersons)
			if ln > 1 && i < ln-1 {
				o.R.BankPersons[i] = o.R.BankPersons[ln-1]
			}
			o.R.BankPersons = o.R.BankPersons[:ln-1]
			break
		}
	}

	return nil
}

// AddBankPersonFinancialInfos adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankPersonFinancialInfos.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankPersonFinancialInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PersonFinancialInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PersonFinancialInfo` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PersonFinancialInfoID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankPersonFinancialInfos: related,
		}
	} else {
		o.R.BankPersonFinancialInfos = append(o.R.BankPersonFinancialInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &personFinancialInfoR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankPhoneNumbers adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankPhoneNumbers.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankPhoneNumbers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PhoneNumber) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PhoneNumbers` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, phoneNumberPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.PhoneNumberID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankPhoneNumbers: related,
		}
	} else {
		o.R.BankPhoneNumbers = append(o.R.BankPhoneNumbers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &phoneNumberR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankProducts adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankProducts.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankProducts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Product) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Product` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, productPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.ProductID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankProducts: related,
		}
	} else {
		o.R.BankProducts = append(o.R.BankProducts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankSocialInfos adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankSocialInfos.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankSocialInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SocialInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `SocialInfo` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, socialInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.SocialInfoID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankSocialInfos: related,
		}
	} else {
		o.R.BankSocialInfos = append(o.R.BankSocialInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &socialInfoR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankStandingOrders adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankStandingOrders.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankStandingOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StandingOrder) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `StandingOrders` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, standingOrderPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.StandingOrderID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankStandingOrders: related,
		}
	} else {
		o.R.BankStandingOrders = append(o.R.BankStandingOrders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &standingOrderR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankTFBankGuarantees adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankTFBankGuarantees.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankTFBankGuarantees(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFBankGuarantee) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFBankGuarantee` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, tFBankGuaranteePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TFBankGuaranteeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankTFBankGuarantees: related,
		}
	} else {
		o.R.BankTFBankGuarantees = append(o.R.BankTFBankGuarantees, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFBankGuaranteeR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankTFLetterOfCredits adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankTFLetterOfCredits.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankTFLetterOfCredits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLetterOfCredit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLetterOfCredit` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, tFLetterOfCreditPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TFLCID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankTFLetterOfCredits: related,
		}
	} else {
		o.R.BankTFLetterOfCredits = append(o.R.BankTFLetterOfCredits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLetterOfCreditR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddBankTFLetterOfCreditTxns adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankTFLetterOfCreditTxns.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankTFLetterOfCreditTxns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TFLetterOfCreditTxn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `TFLetterOfCreditTxn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, tFLetterOfCreditTxnPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TFLCTXNID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankTFLetterOfCreditTxns: related,
		}
	} else {
		o.R.BankTFLetterOfCreditTxns = append(o.R.BankTFLetterOfCreditTxns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tFLetterOfCreditTxnR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// AddConfirmingBankTrades adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.ConfirmingBankTrades.
// Sets related.R.ConfirmingBank appropriately.
func (o *Bank) AddConfirmingBankTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ConfirmingBankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Trade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"confirming_bank_id"}),
				strmangle.WhereClause("`", "`", 0, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ConfirmingBankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			ConfirmingBankTrades: related,
		}
	} else {
		o.R.ConfirmingBankTrades = append(o.R.ConfirmingBankTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				ConfirmingBank: o,
			}
		} else {
			rel.R.ConfirmingBank = o
		}
	}
	return nil
}

// AddIssueingBankTrades adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.IssueingBankTrades.
// Sets related.R.IssueingBank appropriately.
func (o *Bank) AddIssueingBankTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IssueingBankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Trade` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"issueing_bank_id"}),
				strmangle.WhereClause("`", "`", 0, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TradeID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IssueingBankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			IssueingBankTrades: related,
		}
	} else {
		o.R.IssueingBankTrades = append(o.R.IssueingBankTrades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				IssueingBank: o,
			}
		} else {
			rel.R.IssueingBank = o
		}
	}
	return nil
}

// AddBankTransactions adds the given related objects to the existing relationships
// of the Bank, optionally inserting them as new records.
// Appends related to o.R.BankTransactions.
// Sets related.R.Bank appropriately.
func (o *Bank) AddBankTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BankID = o.BankID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Transaction` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
				strmangle.WhereClause("`", "`", 0, transactionPrimaryKeyColumns),
			)
			values := []interface{}{o.BankID, rel.TransactionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BankID = o.BankID
		}
	}

	if o.R == nil {
		o.R = &bankR{
			BankTransactions: related,
		}
	} else {
		o.R.BankTransactions = append(o.R.BankTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transactionR{
				Bank: o,
			}
		} else {
			rel.R.Bank = o
		}
	}
	return nil
}

// Banks retrieves all the records using an executor.
func Banks(mods ...qm.QueryMod) bankQuery {
	mods = append(mods, qm.From("`Banks`"))
	return bankQuery{NewQuery(mods...)}
}

// FindBank retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindBank(ctx context.Context, exec boil.ContextExecutor, bankID int, selectCols ...string) (*Bank, error) {
	bankObj := &Bank{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Banks` where `bank_id`=?", sel,
	)

	q := queries.Raw(query, bankID)

	err := q.Bind(ctx, exec, bankObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Banks")
	}

	return bankObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Bank) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Banks provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(bankColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	bankInsertCacheMut.RLock()
	cache, cached := bankInsertCache[key]
	bankInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			bankColumns,
			bankColumnsWithDefault,
			bankColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(bankType, bankMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(bankType, bankMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Banks` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Banks` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Banks` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, bankPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Banks")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.BankID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == bankMapping["BankID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.BankID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Banks")
	}

CacheNoHooks:
	if !cached {
		bankInsertCacheMut.Lock()
		bankInsertCache[key] = cache
		bankInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Bank.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Bank) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	bankUpdateCacheMut.RLock()
	cache, cached := bankUpdateCache[key]
	bankUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			bankColumns,
			bankPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Banks, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Banks` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, bankPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(bankType, bankMapping, append(wl, bankPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Banks row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Banks")
	}

	if !cached {
		bankUpdateCacheMut.Lock()
		bankUpdateCache[key] = cache
		bankUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q bankQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Banks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Banks")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o BankSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bankPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Banks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bankPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in bank slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all bank")
	}
	return rowsAff, nil
}

var mySQLBankUniqueColumns = []string{
	"bank_id",
	"bank_reg_number",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Bank) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Banks provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(bankColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLBankUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	bankUpsertCacheMut.RLock()
	cache, cached := bankUpsertCache[key]
	bankUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			bankColumns,
			bankColumnsWithDefault,
			bankColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			bankColumns,
			bankPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Banks, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Banks", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Banks` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(bankType, bankMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(bankType, bankMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Banks")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.BankID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == bankMapping["bank_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(bankType, bankMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Banks")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Banks")
	}

CacheNoHooks:
	if !cached {
		bankUpsertCacheMut.Lock()
		bankUpsertCache[key] = cache
		bankUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Bank record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Bank) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Bank provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), bankPrimaryKeyMapping)
	sql := "DELETE FROM `Banks` WHERE `bank_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Banks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Banks")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q bankQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no bankQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Banks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Banks")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o BankSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Bank slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(bankBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bankPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Banks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bankPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from bank slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Banks")
	}

	if len(bankAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Bank) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindBank(ctx, exec, o.BankID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BankSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := BankSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bankPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Banks`.* FROM `Banks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bankPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in BankSlice")
	}

	*o = slice

	return nil
}

// BankExists checks if the Bank row exists.
func BankExists(ctx context.Context, exec boil.ContextExecutor, bankID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Banks` where `bank_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, bankID)
	}

	row := exec.QueryRowContext(ctx, sql, bankID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Banks exists")
	}

	return exists, nil
}
