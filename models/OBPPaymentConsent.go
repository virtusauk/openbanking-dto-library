// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// OBPPaymentConsent is an object representing the database table.
type OBPPaymentConsent struct {
	ObppaymentconsentID             int         `boil:"obppaymentconsent_id" json:"obppaymentconsent_id" toml:"obppaymentconsent_id" yaml:"obppaymentconsent_id"`
	ConsentID                       string      `boil:"consent_id" json:"consent_id" toml:"consent_id" yaml:"consent_id"`
	PaymentID                       int         `boil:"payment_id" json:"payment_id" toml:"payment_id" yaml:"payment_id"`
	CreationDateTime                time.Time   `boil:"creation_date_time" json:"creation_date_time" toml:"creation_date_time" yaml:"creation_date_time"`
	Status                          string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	StatusUpdateDatetime            time.Time   `boil:"status_update_datetime" json:"status_update_datetime" toml:"status_update_datetime" yaml:"status_update_datetime"`
	Permission                      string      `boil:"permission" json:"permission" toml:"permission" yaml:"permission"`
	CutOffDateTime                  time.Time   `boil:"cut_off_date_time" json:"cut_off_date_time" toml:"cut_off_date_time" yaml:"cut_off_date_time"`
	ExpectedExecutionDateTime       time.Time   `boil:"expected_execution_date_time" json:"expected_execution_date_time" toml:"expected_execution_date_time" yaml:"expected_execution_date_time"`
	ExpectedSettlementDateTime      time.Time   `boil:"expected_settlement_date_time" json:"expected_settlement_date_time" toml:"expected_settlement_date_time" yaml:"expected_settlement_date_time"`
	AuthorizationStatus             null.String `boil:"authorization_status" json:"authorization_status,omitempty" toml:"authorization_status" yaml:"authorization_status,omitempty"`
	AuthorizationDecision           null.String `boil:"authorization_decision" json:"authorization_decision,omitempty" toml:"authorization_decision" yaml:"authorization_decision,omitempty"`
	AuthorizationNumberRequired     null.String `boil:"authorization_number_required" json:"authorization_number_required,omitempty" toml:"authorization_number_required" yaml:"authorization_number_required,omitempty"`
	AuthorizationNumberReceived     null.String `boil:"authorization_number_received" json:"authorization_number_received,omitempty" toml:"authorization_number_received" yaml:"authorization_number_received,omitempty"`
	AuthorizationResponse           null.String `boil:"authorization_response" json:"authorization_response,omitempty" toml:"authorization_response" yaml:"authorization_response,omitempty"`
	AuthorisationType               null.String `boil:"authorisation_type" json:"authorisation_type,omitempty" toml:"authorisation_type" yaml:"authorisation_type,omitempty"`
	AuthorisationCompletionDatetime null.Time   `boil:"authorisation_completion_datetime" json:"authorisation_completion_datetime,omitempty" toml:"authorisation_completion_datetime" yaml:"authorisation_completion_datetime,omitempty"`
	AuthorisationLastUpdateDateTime null.Time   `boil:"authorisation_last_update_date_time" json:"authorisation_last_update_date_time,omitempty" toml:"authorisation_last_update_date_time" yaml:"authorisation_last_update_date_time,omitempty"`
	AuthorisationExpirationDateTime null.Time   `boil:"authorisation_expiration_date_time" json:"authorisation_expiration_date_time,omitempty" toml:"authorisation_expiration_date_time" yaml:"authorisation_expiration_date_time,omitempty"`
	MakerDate                       time.Time   `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                     null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                         string      `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                       null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                      null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate                    null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *oBPPaymentConsentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L oBPPaymentConsentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OBPPaymentConsentColumns = struct {
	ObppaymentconsentID             string
	ConsentID                       string
	PaymentID                       string
	CreationDateTime                string
	Status                          string
	StatusUpdateDatetime            string
	Permission                      string
	CutOffDateTime                  string
	ExpectedExecutionDateTime       string
	ExpectedSettlementDateTime      string
	AuthorizationStatus             string
	AuthorizationDecision           string
	AuthorizationNumberRequired     string
	AuthorizationNumberReceived     string
	AuthorizationResponse           string
	AuthorisationType               string
	AuthorisationCompletionDatetime string
	AuthorisationLastUpdateDateTime string
	AuthorisationExpirationDateTime string
	MakerDate                       string
	CheckerDate                     string
	MakerID                         string
	CheckerID                       string
	ModifiedBy                      string
	ModifiedDate                    string
}{
	ObppaymentconsentID:             "obppaymentconsent_id",
	ConsentID:                       "consent_id",
	PaymentID:                       "payment_id",
	CreationDateTime:                "creation_date_time",
	Status:                          "status",
	StatusUpdateDatetime:            "status_update_datetime",
	Permission:                      "permission",
	CutOffDateTime:                  "cut_off_date_time",
	ExpectedExecutionDateTime:       "expected_execution_date_time",
	ExpectedSettlementDateTime:      "expected_settlement_date_time",
	AuthorizationStatus:             "authorization_status",
	AuthorizationDecision:           "authorization_decision",
	AuthorizationNumberRequired:     "authorization_number_required",
	AuthorizationNumberReceived:     "authorization_number_received",
	AuthorizationResponse:           "authorization_response",
	AuthorisationType:               "authorisation_type",
	AuthorisationCompletionDatetime: "authorisation_completion_datetime",
	AuthorisationLastUpdateDateTime: "authorisation_last_update_date_time",
	AuthorisationExpirationDateTime: "authorisation_expiration_date_time",
	MakerDate:                       "maker_date",
	CheckerDate:                     "checker_date",
	MakerID:                         "maker_id",
	CheckerID:                       "checker_id",
	ModifiedBy:                      "modified_by",
	ModifiedDate:                    "modified_date",
}

// Generated where

var OBPPaymentConsentWhere = struct {
	ObppaymentconsentID             whereHelperint
	ConsentID                       whereHelperstring
	PaymentID                       whereHelperint
	CreationDateTime                whereHelpertime_Time
	Status                          whereHelperstring
	StatusUpdateDatetime            whereHelpertime_Time
	Permission                      whereHelperstring
	CutOffDateTime                  whereHelpertime_Time
	ExpectedExecutionDateTime       whereHelpertime_Time
	ExpectedSettlementDateTime      whereHelpertime_Time
	AuthorizationStatus             whereHelpernull_String
	AuthorizationDecision           whereHelpernull_String
	AuthorizationNumberRequired     whereHelpernull_String
	AuthorizationNumberReceived     whereHelpernull_String
	AuthorizationResponse           whereHelpernull_String
	AuthorisationType               whereHelpernull_String
	AuthorisationCompletionDatetime whereHelpernull_Time
	AuthorisationLastUpdateDateTime whereHelpernull_Time
	AuthorisationExpirationDateTime whereHelpernull_Time
	MakerDate                       whereHelpertime_Time
	CheckerDate                     whereHelpernull_Time
	MakerID                         whereHelperstring
	CheckerID                       whereHelpernull_String
	ModifiedBy                      whereHelpernull_String
	ModifiedDate                    whereHelpernull_Time
}{
	ObppaymentconsentID:             whereHelperint{field: `obppaymentconsent_id`},
	ConsentID:                       whereHelperstring{field: `consent_id`},
	PaymentID:                       whereHelperint{field: `payment_id`},
	CreationDateTime:                whereHelpertime_Time{field: `creation_date_time`},
	Status:                          whereHelperstring{field: `status`},
	StatusUpdateDatetime:            whereHelpertime_Time{field: `status_update_datetime`},
	Permission:                      whereHelperstring{field: `permission`},
	CutOffDateTime:                  whereHelpertime_Time{field: `cut_off_date_time`},
	ExpectedExecutionDateTime:       whereHelpertime_Time{field: `expected_execution_date_time`},
	ExpectedSettlementDateTime:      whereHelpertime_Time{field: `expected_settlement_date_time`},
	AuthorizationStatus:             whereHelpernull_String{field: `authorization_status`},
	AuthorizationDecision:           whereHelpernull_String{field: `authorization_decision`},
	AuthorizationNumberRequired:     whereHelpernull_String{field: `authorization_number_required`},
	AuthorizationNumberReceived:     whereHelpernull_String{field: `authorization_number_received`},
	AuthorizationResponse:           whereHelpernull_String{field: `authorization_response`},
	AuthorisationType:               whereHelpernull_String{field: `authorisation_type`},
	AuthorisationCompletionDatetime: whereHelpernull_Time{field: `authorisation_completion_datetime`},
	AuthorisationLastUpdateDateTime: whereHelpernull_Time{field: `authorisation_last_update_date_time`},
	AuthorisationExpirationDateTime: whereHelpernull_Time{field: `authorisation_expiration_date_time`},
	MakerDate:                       whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                     whereHelpernull_Time{field: `checker_date`},
	MakerID:                         whereHelperstring{field: `maker_id`},
	CheckerID:                       whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                      whereHelpernull_String{field: `modified_by`},
	ModifiedDate:                    whereHelpernull_Time{field: `modified_date`},
}

// OBPPaymentConsentRels is where relationship names are stored.
var OBPPaymentConsentRels = struct {
	Payment string
}{
	Payment: "Payment",
}

// oBPPaymentConsentR is where relationships are stored.
type oBPPaymentConsentR struct {
	Payment *PaymentInitiation
}

// NewStruct creates a new relationship struct
func (*oBPPaymentConsentR) NewStruct() *oBPPaymentConsentR {
	return &oBPPaymentConsentR{}
}

// oBPPaymentConsentL is where Load methods for each relationship are stored.
type oBPPaymentConsentL struct{}

var (
	oBPPaymentConsentColumns               = []string{"obppaymentconsent_id", "consent_id", "payment_id", "creation_date_time", "status", "status_update_datetime", "permission", "cut_off_date_time", "expected_execution_date_time", "expected_settlement_date_time", "authorization_status", "authorization_decision", "authorization_number_required", "authorization_number_received", "authorization_response", "authorisation_type", "authorisation_completion_datetime", "authorisation_last_update_date_time", "authorisation_expiration_date_time", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	oBPPaymentConsentColumnsWithoutDefault = []string{"consent_id", "payment_id", "creation_date_time", "status", "status_update_datetime", "permission", "cut_off_date_time", "expected_execution_date_time", "expected_settlement_date_time", "authorization_status", "authorization_decision", "authorization_number_required", "authorization_number_received", "authorization_response", "authorisation_type", "authorisation_completion_datetime", "authorisation_last_update_date_time", "authorisation_expiration_date_time", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	oBPPaymentConsentColumnsWithDefault    = []string{"obppaymentconsent_id"}
	oBPPaymentConsentPrimaryKeyColumns     = []string{"obppaymentconsent_id"}
)

type (
	// OBPPaymentConsentSlice is an alias for a slice of pointers to OBPPaymentConsent.
	// This should generally be used opposed to []OBPPaymentConsent.
	OBPPaymentConsentSlice []*OBPPaymentConsent
	// OBPPaymentConsentHook is the signature for custom OBPPaymentConsent hook methods
	OBPPaymentConsentHook func(context.Context, boil.ContextExecutor, *OBPPaymentConsent) error

	oBPPaymentConsentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	oBPPaymentConsentType                 = reflect.TypeOf(&OBPPaymentConsent{})
	oBPPaymentConsentMapping              = queries.MakeStructMapping(oBPPaymentConsentType)
	oBPPaymentConsentPrimaryKeyMapping, _ = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, oBPPaymentConsentPrimaryKeyColumns)
	oBPPaymentConsentInsertCacheMut       sync.RWMutex
	oBPPaymentConsentInsertCache          = make(map[string]insertCache)
	oBPPaymentConsentUpdateCacheMut       sync.RWMutex
	oBPPaymentConsentUpdateCache          = make(map[string]updateCache)
	oBPPaymentConsentUpsertCacheMut       sync.RWMutex
	oBPPaymentConsentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var oBPPaymentConsentBeforeInsertHooks []OBPPaymentConsentHook
var oBPPaymentConsentBeforeUpdateHooks []OBPPaymentConsentHook
var oBPPaymentConsentBeforeDeleteHooks []OBPPaymentConsentHook
var oBPPaymentConsentBeforeUpsertHooks []OBPPaymentConsentHook

var oBPPaymentConsentAfterInsertHooks []OBPPaymentConsentHook
var oBPPaymentConsentAfterSelectHooks []OBPPaymentConsentHook
var oBPPaymentConsentAfterUpdateHooks []OBPPaymentConsentHook
var oBPPaymentConsentAfterDeleteHooks []OBPPaymentConsentHook
var oBPPaymentConsentAfterUpsertHooks []OBPPaymentConsentHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *OBPPaymentConsent) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *OBPPaymentConsent) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *OBPPaymentConsent) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *OBPPaymentConsent) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *OBPPaymentConsent) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *OBPPaymentConsent) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *OBPPaymentConsent) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *OBPPaymentConsent) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *OBPPaymentConsent) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range oBPPaymentConsentAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOBPPaymentConsentHook registers your hook function for all future operations.
func AddOBPPaymentConsentHook(hookPoint boil.HookPoint, oBPPaymentConsentHook OBPPaymentConsentHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		oBPPaymentConsentBeforeInsertHooks = append(oBPPaymentConsentBeforeInsertHooks, oBPPaymentConsentHook)
	case boil.BeforeUpdateHook:
		oBPPaymentConsentBeforeUpdateHooks = append(oBPPaymentConsentBeforeUpdateHooks, oBPPaymentConsentHook)
	case boil.BeforeDeleteHook:
		oBPPaymentConsentBeforeDeleteHooks = append(oBPPaymentConsentBeforeDeleteHooks, oBPPaymentConsentHook)
	case boil.BeforeUpsertHook:
		oBPPaymentConsentBeforeUpsertHooks = append(oBPPaymentConsentBeforeUpsertHooks, oBPPaymentConsentHook)
	case boil.AfterInsertHook:
		oBPPaymentConsentAfterInsertHooks = append(oBPPaymentConsentAfterInsertHooks, oBPPaymentConsentHook)
	case boil.AfterSelectHook:
		oBPPaymentConsentAfterSelectHooks = append(oBPPaymentConsentAfterSelectHooks, oBPPaymentConsentHook)
	case boil.AfterUpdateHook:
		oBPPaymentConsentAfterUpdateHooks = append(oBPPaymentConsentAfterUpdateHooks, oBPPaymentConsentHook)
	case boil.AfterDeleteHook:
		oBPPaymentConsentAfterDeleteHooks = append(oBPPaymentConsentAfterDeleteHooks, oBPPaymentConsentHook)
	case boil.AfterUpsertHook:
		oBPPaymentConsentAfterUpsertHooks = append(oBPPaymentConsentAfterUpsertHooks, oBPPaymentConsentHook)
	}
}

// One returns a single oBPPaymentConsent record from the query.
func (q oBPPaymentConsentQuery) One(ctx context.Context, exec boil.ContextExecutor) (*OBPPaymentConsent, error) {
	o := &OBPPaymentConsent{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for OBPPaymentConsent")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all OBPPaymentConsent records from the query.
func (q oBPPaymentConsentQuery) All(ctx context.Context, exec boil.ContextExecutor) (OBPPaymentConsentSlice, error) {
	var o []*OBPPaymentConsent

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to OBPPaymentConsent slice")
	}

	if len(oBPPaymentConsentAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all OBPPaymentConsent records in the query.
func (q oBPPaymentConsentQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count OBPPaymentConsent rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q oBPPaymentConsentQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if OBPPaymentConsent exists")
	}

	return count > 0, nil
}

// Payment pointed to by the foreign key.
func (o *OBPPaymentConsent) Payment(mods ...qm.QueryMod) paymentInitiationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("payment_id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentInitiations(queryMods...)
	queries.SetFrom(query.Query, "`PaymentInitiation`")

	return query
}

// LoadPayment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (oBPPaymentConsentL) LoadPayment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOBPPaymentConsent interface{}, mods queries.Applicator) error {
	var slice []*OBPPaymentConsent
	var object *OBPPaymentConsent

	if singular {
		object = maybeOBPPaymentConsent.(*OBPPaymentConsent)
	} else {
		slice = *maybeOBPPaymentConsent.(*[]*OBPPaymentConsent)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &oBPPaymentConsentR{}
		}
		args = append(args, object.PaymentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &oBPPaymentConsentR{}
			}

			for _, a := range args {
				if a == obj.PaymentID {
					continue Outer
				}
			}

			args = append(args, obj.PaymentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentInitiation`), qm.WhereIn(`payment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentInitiation")
	}

	var resultSlice []*PaymentInitiation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentInitiation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for PaymentInitiation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentInitiation")
	}

	if len(oBPPaymentConsentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Payment = foreign
		if foreign.R == nil {
			foreign.R = &paymentInitiationR{}
		}
		foreign.R.PaymentOBPPaymentConsents = append(foreign.R.PaymentOBPPaymentConsents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentID == foreign.PaymentID {
				local.R.Payment = foreign
				if foreign.R == nil {
					foreign.R = &paymentInitiationR{}
				}
				foreign.R.PaymentOBPPaymentConsents = append(foreign.R.PaymentOBPPaymentConsents, local)
				break
			}
		}
	}

	return nil
}

// SetPayment of the oBPPaymentConsent to the related item.
// Sets o.R.Payment to related.
// Adds o to related.R.PaymentOBPPaymentConsents.
func (o *OBPPaymentConsent) SetPayment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentInitiation) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `OBPPaymentConsent` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
		strmangle.WhereClause("`", "`", 0, oBPPaymentConsentPrimaryKeyColumns),
	)
	values := []interface{}{related.PaymentID, o.ObppaymentconsentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PaymentID = related.PaymentID
	if o.R == nil {
		o.R = &oBPPaymentConsentR{
			Payment: related,
		}
	} else {
		o.R.Payment = related
	}

	if related.R == nil {
		related.R = &paymentInitiationR{
			PaymentOBPPaymentConsents: OBPPaymentConsentSlice{o},
		}
	} else {
		related.R.PaymentOBPPaymentConsents = append(related.R.PaymentOBPPaymentConsents, o)
	}

	return nil
}

// OBPPaymentConsents retrieves all the records using an executor.
func OBPPaymentConsents(mods ...qm.QueryMod) oBPPaymentConsentQuery {
	mods = append(mods, qm.From("`OBPPaymentConsent`"))
	return oBPPaymentConsentQuery{NewQuery(mods...)}
}

// FindOBPPaymentConsent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOBPPaymentConsent(ctx context.Context, exec boil.ContextExecutor, obppaymentconsentID int, selectCols ...string) (*OBPPaymentConsent, error) {
	oBPPaymentConsentObj := &OBPPaymentConsent{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `OBPPaymentConsent` where `obppaymentconsent_id`=?", sel,
	)

	q := queries.Raw(query, obppaymentconsentID)

	err := q.Bind(ctx, exec, oBPPaymentConsentObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from OBPPaymentConsent")
	}

	return oBPPaymentConsentObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OBPPaymentConsent) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no OBPPaymentConsent provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(oBPPaymentConsentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	oBPPaymentConsentInsertCacheMut.RLock()
	cache, cached := oBPPaymentConsentInsertCache[key]
	oBPPaymentConsentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			oBPPaymentConsentColumns,
			oBPPaymentConsentColumnsWithDefault,
			oBPPaymentConsentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `OBPPaymentConsent` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `OBPPaymentConsent` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `OBPPaymentConsent` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, oBPPaymentConsentPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into OBPPaymentConsent")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ObppaymentconsentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == oBPPaymentConsentMapping["ObppaymentconsentID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ObppaymentconsentID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for OBPPaymentConsent")
	}

CacheNoHooks:
	if !cached {
		oBPPaymentConsentInsertCacheMut.Lock()
		oBPPaymentConsentInsertCache[key] = cache
		oBPPaymentConsentInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the OBPPaymentConsent.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OBPPaymentConsent) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	oBPPaymentConsentUpdateCacheMut.RLock()
	cache, cached := oBPPaymentConsentUpdateCache[key]
	oBPPaymentConsentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			oBPPaymentConsentColumns,
			oBPPaymentConsentPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update OBPPaymentConsent, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `OBPPaymentConsent` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, oBPPaymentConsentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, append(wl, oBPPaymentConsentPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update OBPPaymentConsent row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for OBPPaymentConsent")
	}

	if !cached {
		oBPPaymentConsentUpdateCacheMut.Lock()
		oBPPaymentConsentUpdateCache[key] = cache
		oBPPaymentConsentUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q oBPPaymentConsentQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for OBPPaymentConsent")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for OBPPaymentConsent")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OBPPaymentConsentSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), oBPPaymentConsentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `OBPPaymentConsent` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, oBPPaymentConsentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in oBPPaymentConsent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all oBPPaymentConsent")
	}
	return rowsAff, nil
}

var mySQLOBPPaymentConsentUniqueColumns = []string{
	"obppaymentconsent_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OBPPaymentConsent) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no OBPPaymentConsent provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(oBPPaymentConsentColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLOBPPaymentConsentUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	oBPPaymentConsentUpsertCacheMut.RLock()
	cache, cached := oBPPaymentConsentUpsertCache[key]
	oBPPaymentConsentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			oBPPaymentConsentColumns,
			oBPPaymentConsentColumnsWithDefault,
			oBPPaymentConsentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			oBPPaymentConsentColumns,
			oBPPaymentConsentPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert OBPPaymentConsent, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "OBPPaymentConsent", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `OBPPaymentConsent` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for OBPPaymentConsent")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ObppaymentconsentID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == oBPPaymentConsentMapping["obppaymentconsent_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(oBPPaymentConsentType, oBPPaymentConsentMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for OBPPaymentConsent")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for OBPPaymentConsent")
	}

CacheNoHooks:
	if !cached {
		oBPPaymentConsentUpsertCacheMut.Lock()
		oBPPaymentConsentUpsertCache[key] = cache
		oBPPaymentConsentUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single OBPPaymentConsent record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OBPPaymentConsent) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OBPPaymentConsent provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), oBPPaymentConsentPrimaryKeyMapping)
	sql := "DELETE FROM `OBPPaymentConsent` WHERE `obppaymentconsent_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from OBPPaymentConsent")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for OBPPaymentConsent")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q oBPPaymentConsentQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no oBPPaymentConsentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from OBPPaymentConsent")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for OBPPaymentConsent")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OBPPaymentConsentSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OBPPaymentConsent slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(oBPPaymentConsentBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), oBPPaymentConsentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `OBPPaymentConsent` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, oBPPaymentConsentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from oBPPaymentConsent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for OBPPaymentConsent")
	}

	if len(oBPPaymentConsentAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OBPPaymentConsent) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOBPPaymentConsent(ctx, exec, o.ObppaymentconsentID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OBPPaymentConsentSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OBPPaymentConsentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), oBPPaymentConsentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `OBPPaymentConsent`.* FROM `OBPPaymentConsent` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, oBPPaymentConsentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OBPPaymentConsentSlice")
	}

	*o = slice

	return nil
}

// OBPPaymentConsentExists checks if the OBPPaymentConsent row exists.
func OBPPaymentConsentExists(ctx context.Context, exec boil.ContextExecutor, obppaymentconsentID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `OBPPaymentConsent` where `obppaymentconsent_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, obppaymentconsentID)
	}

	row := exec.QueryRowContext(ctx, sql, obppaymentconsentID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if OBPPaymentConsent exists")
	}

	return exists, nil
}
