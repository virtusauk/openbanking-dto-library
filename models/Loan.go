// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Loan is an object representing the database table.
type Loan struct {
	LoanID                       int               `boil:"loan_id" json:"loan_id" toml:"loan_id" yaml:"loan_id"`
	LoanRefNumber                string            `boil:"loan_ref_number" json:"loan_ref_number" toml:"loan_ref_number" yaml:"loan_ref_number"`
	Type                         string            `boil:"type" json:"type" toml:"type" yaml:"type"`
	AccountID                    int               `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	TotalPrincipleAmnt           types.Decimal     `boil:"total_principle_amnt" json:"total_principle_amnt" toml:"total_principle_amnt" yaml:"total_principle_amnt"`
	Paymentfrequency             string            `boil:"paymentfrequency" json:"paymentfrequency" toml:"paymentfrequency" yaml:"paymentfrequency"`
	InstallmentAmount            types.Decimal     `boil:"installment_amount" json:"installment_amount" toml:"installment_amount" yaml:"installment_amount"`
	VerificationStatus           string            `boil:"verification_status" json:"verification_status" toml:"verification_status" yaml:"verification_status"`
	IssueDate                    time.Time         `boil:"issue_date" json:"issue_date" toml:"issue_date" yaml:"issue_date"`
	EndDate                      null.Time         `boil:"end_date" json:"end_date,omitempty" toml:"end_date" yaml:"end_date,omitempty"`
	Status                       string            `boil:"status" json:"status" toml:"status" yaml:"status"`
	PrincipalBalance             types.Decimal     `boil:"principal_balance" json:"principal_balance" toml:"principal_balance" yaml:"principal_balance"`
	TotalPymntTillDate           types.NullDecimal `boil:"total_pymnt_till_date" json:"total_pymnt_till_date,omitempty" toml:"total_pymnt_till_date" yaml:"total_pymnt_till_date,omitempty"`
	TotalRecInt                  types.NullDecimal `boil:"total_rec_int" json:"total_rec_int,omitempty" toml:"total_rec_int" yaml:"total_rec_int,omitempty"`
	TotalRecLateFee              types.NullDecimal `boil:"total_rec_late_fee" json:"total_rec_late_fee,omitempty" toml:"total_rec_late_fee" yaml:"total_rec_late_fee,omitempty"`
	Recoveries                   types.NullDecimal `boil:"recoveries" json:"recoveries,omitempty" toml:"recoveries" yaml:"recoveries,omitempty"`
	CollectionRecoveryFee        types.NullDecimal `boil:"collection_recovery_fee" json:"collection_recovery_fee,omitempty" toml:"collection_recovery_fee" yaml:"collection_recovery_fee,omitempty"`
	LastPymntDate                time.Time         `boil:"last_pymnt_date" json:"last_pymnt_date" toml:"last_pymnt_date" yaml:"last_pymnt_date"`
	LastPymntAmnt                types.Decimal     `boil:"last_pymnt_amnt" json:"last_pymnt_amnt" toml:"last_pymnt_amnt" yaml:"last_pymnt_amnt"`
	NextPymntDate                time.Time         `boil:"next_pymnt_date" json:"next_pymnt_date" toml:"next_pymnt_date" yaml:"next_pymnt_date"`
	TotalRecPRNCP                types.Decimal     `boil:"total_rec_prncp" json:"total_rec_prncp" toml:"total_rec_prncp" yaml:"total_rec_prncp"`
	Term                         string            `boil:"term" json:"term" toml:"term" yaml:"term"`
	CreditOriginRef              null.Int          `boil:"credit_origin_ref" json:"credit_origin_ref,omitempty" toml:"credit_origin_ref" yaml:"credit_origin_ref,omitempty"`
	AssetIDRef                   null.Int          `boil:"asset_id_ref" json:"asset_id_ref,omitempty" toml:"asset_id_ref" yaml:"asset_id_ref,omitempty"`
	LoanContractID               null.String       `boil:"loan_contract_id" json:"loan_contract_id,omitempty" toml:"loan_contract_id" yaml:"loan_contract_id,omitempty"`
	TotalLoanAmountFunded        types.NullDecimal `boil:"total_loan_amount_funded" json:"total_loan_amount_funded,omitempty" toml:"total_loan_amount_funded" yaml:"total_loan_amount_funded,omitempty"`
	ApprovedDate                 null.Time         `boil:"approved_date" json:"approved_date,omitempty" toml:"approved_date" yaml:"approved_date,omitempty"`
	LastSetToArrearsDate         null.Time         `boil:"last_set_to_arrears_date" json:"last_set_to_arrears_date,omitempty" toml:"last_set_to_arrears_date" yaml:"last_set_to_arrears_date,omitempty"`
	ClosedDate                   null.Time         `boil:"closed_date" json:"closed_date,omitempty" toml:"closed_date" yaml:"closed_date,omitempty"`
	SubStatus                    null.String       `boil:"sub_status" json:"sub_status,omitempty" toml:"sub_status" yaml:"sub_status,omitempty"`
	LastLockedDate               null.Time         `boil:"last_locked_date" json:"last_locked_date,omitempty" toml:"last_locked_date" yaml:"last_locked_date,omitempty"`
	ProductKey                   null.Int          `boil:"product_key" json:"product_key,omitempty" toml:"product_key" yaml:"product_key,omitempty"`
	LoanName                     null.String       `boil:"loan_name" json:"loan_name,omitempty" toml:"loan_name" yaml:"loan_name,omitempty"`
	InterestDue                  types.NullDecimal `boil:"interest_due" json:"interest_due,omitempty" toml:"interest_due" yaml:"interest_due,omitempty"`
	FeesDue                      types.NullDecimal `boil:"fees_due" json:"fees_due,omitempty" toml:"fees_due" yaml:"fees_due,omitempty"`
	FeesPaid                     types.NullDecimal `boil:"fees_paid" json:"fees_paid,omitempty" toml:"fees_paid" yaml:"fees_paid,omitempty"`
	PenaltyDue                   types.NullDecimal `boil:"penalty_due" json:"penalty_due,omitempty" toml:"penalty_due" yaml:"penalty_due,omitempty"`
	PenaltyPaid                  types.NullDecimal `boil:"penalty_paid" json:"penalty_paid,omitempty" toml:"penalty_paid" yaml:"penalty_paid,omitempty"`
	RepaymentPeriodCount         null.Int          `boil:"repayment_period_count" json:"repayment_period_count,omitempty" toml:"repayment_period_count" yaml:"repayment_period_count,omitempty"`
	RepaymentPeriodUnit          null.String       `boil:"repayment_period_unit" json:"repayment_period_unit,omitempty" toml:"repayment_period_unit" yaml:"repayment_period_unit,omitempty"`
	RepaymentInstallments        null.Int          `boil:"repayment_installments" json:"repayment_installments,omitempty" toml:"repayment_installments" yaml:"repayment_installments,omitempty"`
	GracePeriodType              null.String       `boil:"grace_period_type" json:"grace_period_type,omitempty" toml:"grace_period_type" yaml:"grace_period_type,omitempty"`
	GracePeriod                  null.Int          `boil:"grace_period" json:"grace_period,omitempty" toml:"grace_period" yaml:"grace_period,omitempty"`
	InterestChargeFrequence      null.String       `boil:"interest_charge_frequence" json:"interest_charge_frequence,omitempty" toml:"interest_charge_frequence" yaml:"interest_charge_frequence,omitempty"`
	InterestCalculationMethod    null.String       `boil:"interest_calculation_method" json:"interest_calculation_method,omitempty" toml:"interest_calculation_method" yaml:"interest_calculation_method,omitempty"`
	InterestSpread               types.NullDecimal `boil:"interest_spread" json:"interest_spread,omitempty" toml:"interest_spread" yaml:"interest_spread,omitempty"`
	LastAccountAppraisalDate     null.Time         `boil:"last_account_appraisal_date" json:"last_account_appraisal_date,omitempty" toml:"last_account_appraisal_date" yaml:"last_account_appraisal_date,omitempty"`
	PrincipalRepaymentInterval   null.Int          `boil:"principal_repayment_interval" json:"principal_repayment_interval,omitempty" toml:"principal_repayment_interval" yaml:"principal_repayment_interval,omitempty"`
	InterestBalance              types.NullDecimal `boil:"interest_balance" json:"interest_balance,omitempty" toml:"interest_balance" yaml:"interest_balance,omitempty"`
	AccruedInterest              types.NullDecimal `boil:"accrued_interest" json:"accrued_interest,omitempty" toml:"accrued_interest" yaml:"accrued_interest,omitempty"`
	LastinterestAppliedDate      null.Time         `boil:"lastinterest_applied_date" json:"lastinterest_applied_date,omitempty" toml:"lastinterest_applied_date" yaml:"lastinterest_applied_date,omitempty"`
	FeesBalance                  types.NullDecimal `boil:"fees_balance" json:"fees_balance,omitempty" toml:"fees_balance" yaml:"fees_balance,omitempty"`
	PenaltyBalance               types.NullDecimal `boil:"penalty_balance" json:"penalty_balance,omitempty" toml:"penalty_balance" yaml:"penalty_balance,omitempty"`
	ScheduleDuedatesMethod       null.String       `boil:"schedule_duedates_method" json:"schedule_duedates_method,omitempty" toml:"schedule_duedates_method" yaml:"schedule_duedates_method,omitempty"`
	TaxRate                      types.NullDecimal `boil:"tax_rate" json:"tax_rate,omitempty" toml:"tax_rate" yaml:"tax_rate,omitempty"`
	LasttaxRateReviewDate        null.Time         `boil:"lasttax_rate_review_date" json:"lasttax_rate_review_date,omitempty" toml:"lasttax_rate_review_date" yaml:"lasttax_rate_review_date,omitempty"`
	InterestApplicationMethod    null.String       `boil:"interest_application_method" json:"interest_application_method,omitempty" toml:"interest_application_method" yaml:"interest_application_method,omitempty"`
	PaymentMethod                null.String       `boil:"payment_method" json:"payment_method,omitempty" toml:"payment_method" yaml:"payment_method,omitempty"`
	RepaymentScheduleMethod      null.String       `boil:"repayment_schedule_method" json:"repayment_schedule_method,omitempty" toml:"repayment_schedule_method" yaml:"repayment_schedule_method,omitempty"`
	LoanPenaltyCalculationMethod null.String       `boil:"loan_penalty_calculation_method" json:"loan_penalty_calculation_method,omitempty" toml:"loan_penalty_calculation_method" yaml:"loan_penalty_calculation_method,omitempty"`
	AccruedPenalty               types.NullDecimal `boil:"accrued_penalty" json:"accrued_penalty,omitempty" toml:"accrued_penalty" yaml:"accrued_penalty,omitempty"`
	HasCustomSchedule            null.String       `boil:"has_custom_schedule" json:"has_custom_schedule,omitempty" toml:"has_custom_schedule" yaml:"has_custom_schedule,omitempty"`
	PeriodicPayment              types.NullDecimal `boil:"periodic_payment" json:"periodic_payment,omitempty" toml:"periodic_payment" yaml:"periodic_payment,omitempty"`
	LineOfCreditID               null.Int          `boil:"line_of_credit_id" json:"line_of_credit_id,omitempty" toml:"line_of_credit_id" yaml:"line_of_credit_id,omitempty"`
	LoanAccountCurrency          null.String       `boil:"loan_account_currency" json:"loan_account_currency,omitempty" toml:"loan_account_currency" yaml:"loan_account_currency,omitempty"`
	BankID                       int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	MakerDate                    time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                  null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                      null.String       `boil:"maker_id" json:"maker_id,omitempty" toml:"maker_id" yaml:"maker_id,omitempty"`
	CheckerID                    null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                   null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate                 null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *loanR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L loanL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var LoanColumns = struct {
	LoanID                       string
	LoanRefNumber                string
	Type                         string
	AccountID                    string
	TotalPrincipleAmnt           string
	Paymentfrequency             string
	InstallmentAmount            string
	VerificationStatus           string
	IssueDate                    string
	EndDate                      string
	Status                       string
	PrincipalBalance             string
	TotalPymntTillDate           string
	TotalRecInt                  string
	TotalRecLateFee              string
	Recoveries                   string
	CollectionRecoveryFee        string
	LastPymntDate                string
	LastPymntAmnt                string
	NextPymntDate                string
	TotalRecPRNCP                string
	Term                         string
	CreditOriginRef              string
	AssetIDRef                   string
	LoanContractID               string
	TotalLoanAmountFunded        string
	ApprovedDate                 string
	LastSetToArrearsDate         string
	ClosedDate                   string
	SubStatus                    string
	LastLockedDate               string
	ProductKey                   string
	LoanName                     string
	InterestDue                  string
	FeesDue                      string
	FeesPaid                     string
	PenaltyDue                   string
	PenaltyPaid                  string
	RepaymentPeriodCount         string
	RepaymentPeriodUnit          string
	RepaymentInstallments        string
	GracePeriodType              string
	GracePeriod                  string
	InterestChargeFrequence      string
	InterestCalculationMethod    string
	InterestSpread               string
	LastAccountAppraisalDate     string
	PrincipalRepaymentInterval   string
	InterestBalance              string
	AccruedInterest              string
	LastinterestAppliedDate      string
	FeesBalance                  string
	PenaltyBalance               string
	ScheduleDuedatesMethod       string
	TaxRate                      string
	LasttaxRateReviewDate        string
	InterestApplicationMethod    string
	PaymentMethod                string
	RepaymentScheduleMethod      string
	LoanPenaltyCalculationMethod string
	AccruedPenalty               string
	HasCustomSchedule            string
	PeriodicPayment              string
	LineOfCreditID               string
	LoanAccountCurrency          string
	BankID                       string
	MakerDate                    string
	CheckerDate                  string
	MakerID                      string
	CheckerID                    string
	ModifiedBy                   string
	ModifiedDate                 string
}{
	LoanID:                       "loan_id",
	LoanRefNumber:                "loan_ref_number",
	Type:                         "type",
	AccountID:                    "account_id",
	TotalPrincipleAmnt:           "total_principle_amnt",
	Paymentfrequency:             "paymentfrequency",
	InstallmentAmount:            "installment_amount",
	VerificationStatus:           "verification_status",
	IssueDate:                    "issue_date",
	EndDate:                      "end_date",
	Status:                       "status",
	PrincipalBalance:             "principal_balance",
	TotalPymntTillDate:           "total_pymnt_till_date",
	TotalRecInt:                  "total_rec_int",
	TotalRecLateFee:              "total_rec_late_fee",
	Recoveries:                   "recoveries",
	CollectionRecoveryFee:        "collection_recovery_fee",
	LastPymntDate:                "last_pymnt_date",
	LastPymntAmnt:                "last_pymnt_amnt",
	NextPymntDate:                "next_pymnt_date",
	TotalRecPRNCP:                "total_rec_prncp",
	Term:                         "term",
	CreditOriginRef:              "credit_origin_ref",
	AssetIDRef:                   "asset_id_ref",
	LoanContractID:               "loan_contract_id",
	TotalLoanAmountFunded:        "total_loan_amount_funded",
	ApprovedDate:                 "approved_date",
	LastSetToArrearsDate:         "last_set_to_arrears_date",
	ClosedDate:                   "closed_date",
	SubStatus:                    "sub_status",
	LastLockedDate:               "last_locked_date",
	ProductKey:                   "product_key",
	LoanName:                     "loan_name",
	InterestDue:                  "interest_due",
	FeesDue:                      "fees_due",
	FeesPaid:                     "fees_paid",
	PenaltyDue:                   "penalty_due",
	PenaltyPaid:                  "penalty_paid",
	RepaymentPeriodCount:         "repayment_period_count",
	RepaymentPeriodUnit:          "repayment_period_unit",
	RepaymentInstallments:        "repayment_installments",
	GracePeriodType:              "grace_period_type",
	GracePeriod:                  "grace_period",
	InterestChargeFrequence:      "interest_charge_frequence",
	InterestCalculationMethod:    "interest_calculation_method",
	InterestSpread:               "interest_spread",
	LastAccountAppraisalDate:     "last_account_appraisal_date",
	PrincipalRepaymentInterval:   "principal_repayment_interval",
	InterestBalance:              "interest_balance",
	AccruedInterest:              "accrued_interest",
	LastinterestAppliedDate:      "lastinterest_applied_date",
	FeesBalance:                  "fees_balance",
	PenaltyBalance:               "penalty_balance",
	ScheduleDuedatesMethod:       "schedule_duedates_method",
	TaxRate:                      "tax_rate",
	LasttaxRateReviewDate:        "lasttax_rate_review_date",
	InterestApplicationMethod:    "interest_application_method",
	PaymentMethod:                "payment_method",
	RepaymentScheduleMethod:      "repayment_schedule_method",
	LoanPenaltyCalculationMethod: "loan_penalty_calculation_method",
	AccruedPenalty:               "accrued_penalty",
	HasCustomSchedule:            "has_custom_schedule",
	PeriodicPayment:              "periodic_payment",
	LineOfCreditID:               "line_of_credit_id",
	LoanAccountCurrency:          "loan_account_currency",
	BankID:                       "bank_id",
	MakerDate:                    "maker_date",
	CheckerDate:                  "checker_date",
	MakerID:                      "maker_id",
	CheckerID:                    "checker_id",
	ModifiedBy:                   "modified_by",
	ModifiedDate:                 "modified_date",
}

// Generated where

var LoanWhere = struct {
	LoanID                       whereHelperint
	LoanRefNumber                whereHelperstring
	Type                         whereHelperstring
	AccountID                    whereHelperint
	TotalPrincipleAmnt           whereHelpertypes_Decimal
	Paymentfrequency             whereHelperstring
	InstallmentAmount            whereHelpertypes_Decimal
	VerificationStatus           whereHelperstring
	IssueDate                    whereHelpertime_Time
	EndDate                      whereHelpernull_Time
	Status                       whereHelperstring
	PrincipalBalance             whereHelpertypes_Decimal
	TotalPymntTillDate           whereHelpertypes_NullDecimal
	TotalRecInt                  whereHelpertypes_NullDecimal
	TotalRecLateFee              whereHelpertypes_NullDecimal
	Recoveries                   whereHelpertypes_NullDecimal
	CollectionRecoveryFee        whereHelpertypes_NullDecimal
	LastPymntDate                whereHelpertime_Time
	LastPymntAmnt                whereHelpertypes_Decimal
	NextPymntDate                whereHelpertime_Time
	TotalRecPRNCP                whereHelpertypes_Decimal
	Term                         whereHelperstring
	CreditOriginRef              whereHelpernull_Int
	AssetIDRef                   whereHelpernull_Int
	LoanContractID               whereHelpernull_String
	TotalLoanAmountFunded        whereHelpertypes_NullDecimal
	ApprovedDate                 whereHelpernull_Time
	LastSetToArrearsDate         whereHelpernull_Time
	ClosedDate                   whereHelpernull_Time
	SubStatus                    whereHelpernull_String
	LastLockedDate               whereHelpernull_Time
	ProductKey                   whereHelpernull_Int
	LoanName                     whereHelpernull_String
	InterestDue                  whereHelpertypes_NullDecimal
	FeesDue                      whereHelpertypes_NullDecimal
	FeesPaid                     whereHelpertypes_NullDecimal
	PenaltyDue                   whereHelpertypes_NullDecimal
	PenaltyPaid                  whereHelpertypes_NullDecimal
	RepaymentPeriodCount         whereHelpernull_Int
	RepaymentPeriodUnit          whereHelpernull_String
	RepaymentInstallments        whereHelpernull_Int
	GracePeriodType              whereHelpernull_String
	GracePeriod                  whereHelpernull_Int
	InterestChargeFrequence      whereHelpernull_String
	InterestCalculationMethod    whereHelpernull_String
	InterestSpread               whereHelpertypes_NullDecimal
	LastAccountAppraisalDate     whereHelpernull_Time
	PrincipalRepaymentInterval   whereHelpernull_Int
	InterestBalance              whereHelpertypes_NullDecimal
	AccruedInterest              whereHelpertypes_NullDecimal
	LastinterestAppliedDate      whereHelpernull_Time
	FeesBalance                  whereHelpertypes_NullDecimal
	PenaltyBalance               whereHelpertypes_NullDecimal
	ScheduleDuedatesMethod       whereHelpernull_String
	TaxRate                      whereHelpertypes_NullDecimal
	LasttaxRateReviewDate        whereHelpernull_Time
	InterestApplicationMethod    whereHelpernull_String
	PaymentMethod                whereHelpernull_String
	RepaymentScheduleMethod      whereHelpernull_String
	LoanPenaltyCalculationMethod whereHelpernull_String
	AccruedPenalty               whereHelpertypes_NullDecimal
	HasCustomSchedule            whereHelpernull_String
	PeriodicPayment              whereHelpertypes_NullDecimal
	LineOfCreditID               whereHelpernull_Int
	LoanAccountCurrency          whereHelpernull_String
	BankID                       whereHelperint
	MakerDate                    whereHelpertime_Time
	CheckerDate                  whereHelpernull_Time
	MakerID                      whereHelpernull_String
	CheckerID                    whereHelpernull_String
	ModifiedBy                   whereHelpernull_String
	ModifiedDate                 whereHelpernull_Time
}{
	LoanID:                       whereHelperint{field: `loan_id`},
	LoanRefNumber:                whereHelperstring{field: `loan_ref_number`},
	Type:                         whereHelperstring{field: `type`},
	AccountID:                    whereHelperint{field: `account_id`},
	TotalPrincipleAmnt:           whereHelpertypes_Decimal{field: `total_principle_amnt`},
	Paymentfrequency:             whereHelperstring{field: `paymentfrequency`},
	InstallmentAmount:            whereHelpertypes_Decimal{field: `installment_amount`},
	VerificationStatus:           whereHelperstring{field: `verification_status`},
	IssueDate:                    whereHelpertime_Time{field: `issue_date`},
	EndDate:                      whereHelpernull_Time{field: `end_date`},
	Status:                       whereHelperstring{field: `status`},
	PrincipalBalance:             whereHelpertypes_Decimal{field: `principal_balance`},
	TotalPymntTillDate:           whereHelpertypes_NullDecimal{field: `total_pymnt_till_date`},
	TotalRecInt:                  whereHelpertypes_NullDecimal{field: `total_rec_int`},
	TotalRecLateFee:              whereHelpertypes_NullDecimal{field: `total_rec_late_fee`},
	Recoveries:                   whereHelpertypes_NullDecimal{field: `recoveries`},
	CollectionRecoveryFee:        whereHelpertypes_NullDecimal{field: `collection_recovery_fee`},
	LastPymntDate:                whereHelpertime_Time{field: `last_pymnt_date`},
	LastPymntAmnt:                whereHelpertypes_Decimal{field: `last_pymnt_amnt`},
	NextPymntDate:                whereHelpertime_Time{field: `next_pymnt_date`},
	TotalRecPRNCP:                whereHelpertypes_Decimal{field: `total_rec_prncp`},
	Term:                         whereHelperstring{field: `term`},
	CreditOriginRef:              whereHelpernull_Int{field: `credit_origin_ref`},
	AssetIDRef:                   whereHelpernull_Int{field: `asset_id_ref`},
	LoanContractID:               whereHelpernull_String{field: `loan_contract_id`},
	TotalLoanAmountFunded:        whereHelpertypes_NullDecimal{field: `total_loan_amount_funded`},
	ApprovedDate:                 whereHelpernull_Time{field: `approved_date`},
	LastSetToArrearsDate:         whereHelpernull_Time{field: `last_set_to_arrears_date`},
	ClosedDate:                   whereHelpernull_Time{field: `closed_date`},
	SubStatus:                    whereHelpernull_String{field: `sub_status`},
	LastLockedDate:               whereHelpernull_Time{field: `last_locked_date`},
	ProductKey:                   whereHelpernull_Int{field: `product_key`},
	LoanName:                     whereHelpernull_String{field: `loan_name`},
	InterestDue:                  whereHelpertypes_NullDecimal{field: `interest_due`},
	FeesDue:                      whereHelpertypes_NullDecimal{field: `fees_due`},
	FeesPaid:                     whereHelpertypes_NullDecimal{field: `fees_paid`},
	PenaltyDue:                   whereHelpertypes_NullDecimal{field: `penalty_due`},
	PenaltyPaid:                  whereHelpertypes_NullDecimal{field: `penalty_paid`},
	RepaymentPeriodCount:         whereHelpernull_Int{field: `repayment_period_count`},
	RepaymentPeriodUnit:          whereHelpernull_String{field: `repayment_period_unit`},
	RepaymentInstallments:        whereHelpernull_Int{field: `repayment_installments`},
	GracePeriodType:              whereHelpernull_String{field: `grace_period_type`},
	GracePeriod:                  whereHelpernull_Int{field: `grace_period`},
	InterestChargeFrequence:      whereHelpernull_String{field: `interest_charge_frequence`},
	InterestCalculationMethod:    whereHelpernull_String{field: `interest_calculation_method`},
	InterestSpread:               whereHelpertypes_NullDecimal{field: `interest_spread`},
	LastAccountAppraisalDate:     whereHelpernull_Time{field: `last_account_appraisal_date`},
	PrincipalRepaymentInterval:   whereHelpernull_Int{field: `principal_repayment_interval`},
	InterestBalance:              whereHelpertypes_NullDecimal{field: `interest_balance`},
	AccruedInterest:              whereHelpertypes_NullDecimal{field: `accrued_interest`},
	LastinterestAppliedDate:      whereHelpernull_Time{field: `lastinterest_applied_date`},
	FeesBalance:                  whereHelpertypes_NullDecimal{field: `fees_balance`},
	PenaltyBalance:               whereHelpertypes_NullDecimal{field: `penalty_balance`},
	ScheduleDuedatesMethod:       whereHelpernull_String{field: `schedule_duedates_method`},
	TaxRate:                      whereHelpertypes_NullDecimal{field: `tax_rate`},
	LasttaxRateReviewDate:        whereHelpernull_Time{field: `lasttax_rate_review_date`},
	InterestApplicationMethod:    whereHelpernull_String{field: `interest_application_method`},
	PaymentMethod:                whereHelpernull_String{field: `payment_method`},
	RepaymentScheduleMethod:      whereHelpernull_String{field: `repayment_schedule_method`},
	LoanPenaltyCalculationMethod: whereHelpernull_String{field: `loan_penalty_calculation_method`},
	AccruedPenalty:               whereHelpertypes_NullDecimal{field: `accrued_penalty`},
	HasCustomSchedule:            whereHelpernull_String{field: `has_custom_schedule`},
	PeriodicPayment:              whereHelpertypes_NullDecimal{field: `periodic_payment`},
	LineOfCreditID:               whereHelpernull_Int{field: `line_of_credit_id`},
	LoanAccountCurrency:          whereHelpernull_String{field: `loan_account_currency`},
	BankID:                       whereHelperint{field: `bank_id`},
	MakerDate:                    whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                  whereHelpernull_Time{field: `checker_date`},
	MakerID:                      whereHelpernull_String{field: `maker_id`},
	CheckerID:                    whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                   whereHelpernull_String{field: `modified_by`},
	ModifiedDate:                 whereHelpernull_Time{field: `modified_date`},
}

// LoanRels is where relationship names are stored.
var LoanRels = struct {
	Account                  string
	AssetIDRef               string
	CreditOriginRef          string
	LoanBorrowers            string
	LoanInvestmentInLendings string
	LoanLoanInterests        string
	LoanLoanSchedules        string
	LoanPaymentLoans         string
}{
	Account:                  "Account",
	AssetIDRef:               "AssetIDRef",
	CreditOriginRef:          "CreditOriginRef",
	LoanBorrowers:            "LoanBorrowers",
	LoanInvestmentInLendings: "LoanInvestmentInLendings",
	LoanLoanInterests:        "LoanLoanInterests",
	LoanLoanSchedules:        "LoanLoanSchedules",
	LoanPaymentLoans:         "LoanPaymentLoans",
}

// loanR is where relationships are stored.
type loanR struct {
	Account                  *Account
	AssetIDRef               *Asset
	CreditOriginRef          *CreditOrigination
	LoanBorrowers            BorrowerSlice
	LoanInvestmentInLendings InvestmentInLendingSlice
	LoanLoanInterests        LoanInterestSlice
	LoanLoanSchedules        LoanScheduleSlice
	LoanPaymentLoans         PaymentLoanSlice
}

// NewStruct creates a new relationship struct
func (*loanR) NewStruct() *loanR {
	return &loanR{}
}

// loanL is where Load methods for each relationship are stored.
type loanL struct{}

var (
	loanColumns               = []string{"loan_id", "loan_ref_number", "type", "account_id", "total_principle_amnt", "paymentfrequency", "installment_amount", "verification_status", "issue_date", "end_date", "status", "principal_balance", "total_pymnt_till_date", "total_rec_int", "total_rec_late_fee", "recoveries", "collection_recovery_fee", "last_pymnt_date", "last_pymnt_amnt", "next_pymnt_date", "total_rec_prncp", "term", "credit_origin_ref", "asset_id_ref", "loan_contract_id", "total_loan_amount_funded", "approved_date", "last_set_to_arrears_date", "closed_date", "sub_status", "last_locked_date", "product_key", "loan_name", "interest_due", "fees_due", "fees_paid", "penalty_due", "penalty_paid", "repayment_period_count", "repayment_period_unit", "repayment_installments", "grace_period_type", "grace_period", "interest_charge_frequence", "interest_calculation_method", "interest_spread", "last_account_appraisal_date", "principal_repayment_interval", "interest_balance", "accrued_interest", "lastinterest_applied_date", "fees_balance", "penalty_balance", "schedule_duedates_method", "tax_rate", "lasttax_rate_review_date", "interest_application_method", "payment_method", "repayment_schedule_method", "loan_penalty_calculation_method", "accrued_penalty", "has_custom_schedule", "periodic_payment", "line_of_credit_id", "loan_account_currency", "bank_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	loanColumnsWithoutDefault = []string{"loan_id", "loan_ref_number", "type", "account_id", "total_principle_amnt", "paymentfrequency", "installment_amount", "verification_status", "issue_date", "end_date", "status", "principal_balance", "total_pymnt_till_date", "total_rec_int", "total_rec_late_fee", "recoveries", "collection_recovery_fee", "last_pymnt_date", "last_pymnt_amnt", "next_pymnt_date", "total_rec_prncp", "term", "credit_origin_ref", "asset_id_ref", "loan_contract_id", "approved_date", "last_set_to_arrears_date", "closed_date", "sub_status", "last_locked_date", "product_key", "loan_name", "interest_due", "fees_due", "fees_paid", "penalty_due", "penalty_paid", "repayment_period_count", "repayment_period_unit", "repayment_installments", "grace_period_type", "grace_period", "interest_charge_frequence", "interest_calculation_method", "interest_spread", "last_account_appraisal_date", "principal_repayment_interval", "interest_balance", "accrued_interest", "lastinterest_applied_date", "fees_balance", "penalty_balance", "schedule_duedates_method", "tax_rate", "lasttax_rate_review_date", "interest_application_method", "payment_method", "repayment_schedule_method", "loan_penalty_calculation_method", "accrued_penalty", "has_custom_schedule", "periodic_payment", "line_of_credit_id", "loan_account_currency", "bank_id", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	loanColumnsWithDefault    = []string{"total_loan_amount_funded"}
	loanPrimaryKeyColumns     = []string{"loan_id"}
)

type (
	// LoanSlice is an alias for a slice of pointers to Loan.
	// This should generally be used opposed to []Loan.
	LoanSlice []*Loan
	// LoanHook is the signature for custom Loan hook methods
	LoanHook func(context.Context, boil.ContextExecutor, *Loan) error

	loanQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	loanType                 = reflect.TypeOf(&Loan{})
	loanMapping              = queries.MakeStructMapping(loanType)
	loanPrimaryKeyMapping, _ = queries.BindMapping(loanType, loanMapping, loanPrimaryKeyColumns)
	loanInsertCacheMut       sync.RWMutex
	loanInsertCache          = make(map[string]insertCache)
	loanUpdateCacheMut       sync.RWMutex
	loanUpdateCache          = make(map[string]updateCache)
	loanUpsertCacheMut       sync.RWMutex
	loanUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var loanBeforeInsertHooks []LoanHook
var loanBeforeUpdateHooks []LoanHook
var loanBeforeDeleteHooks []LoanHook
var loanBeforeUpsertHooks []LoanHook

var loanAfterInsertHooks []LoanHook
var loanAfterSelectHooks []LoanHook
var loanAfterUpdateHooks []LoanHook
var loanAfterDeleteHooks []LoanHook
var loanAfterUpsertHooks []LoanHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Loan) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Loan) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Loan) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Loan) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Loan) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Loan) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Loan) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Loan) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Loan) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range loanAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddLoanHook registers your hook function for all future operations.
func AddLoanHook(hookPoint boil.HookPoint, loanHook LoanHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		loanBeforeInsertHooks = append(loanBeforeInsertHooks, loanHook)
	case boil.BeforeUpdateHook:
		loanBeforeUpdateHooks = append(loanBeforeUpdateHooks, loanHook)
	case boil.BeforeDeleteHook:
		loanBeforeDeleteHooks = append(loanBeforeDeleteHooks, loanHook)
	case boil.BeforeUpsertHook:
		loanBeforeUpsertHooks = append(loanBeforeUpsertHooks, loanHook)
	case boil.AfterInsertHook:
		loanAfterInsertHooks = append(loanAfterInsertHooks, loanHook)
	case boil.AfterSelectHook:
		loanAfterSelectHooks = append(loanAfterSelectHooks, loanHook)
	case boil.AfterUpdateHook:
		loanAfterUpdateHooks = append(loanAfterUpdateHooks, loanHook)
	case boil.AfterDeleteHook:
		loanAfterDeleteHooks = append(loanAfterDeleteHooks, loanHook)
	case boil.AfterUpsertHook:
		loanAfterUpsertHooks = append(loanAfterUpsertHooks, loanHook)
	}
}

// One returns a single loan record from the query.
func (q loanQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Loan, error) {
	o := &Loan{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for Loan")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Loan records from the query.
func (q loanQuery) All(ctx context.Context, exec boil.ContextExecutor) (LoanSlice, error) {
	var o []*Loan

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Loan slice")
	}

	if len(loanAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Loan records in the query.
func (q loanQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count Loan rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q loanQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if Loan exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *Loan) Account(mods ...qm.QueryMod) accountQuery {
	queryMods := []qm.QueryMod{
		qm.Where("account_id=?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	query := Accounts(queryMods...)
	queries.SetFrom(query.Query, "`Account`")

	return query
}

// AssetIDRef pointed to by the foreign key.
func (o *Loan) AssetIDRef1(mods ...qm.QueryMod) assetQuery {
	queryMods := []qm.QueryMod{
		qm.Where("asset_id=?", o.AssetIDRef),
	}

	queryMods = append(queryMods, mods...)

	query := Assets(queryMods...)
	queries.SetFrom(query.Query, "`Assets`")

	return query
}

// CreditOriginRef pointed to by the foreign key.
func (o *Loan) CreditOriginRef1(mods ...qm.QueryMod) creditOriginationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("credit_origination_id=?", o.CreditOriginRef),
	}

	queryMods = append(queryMods, mods...)

	query := CreditOriginations(queryMods...)
	queries.SetFrom(query.Query, "`CreditOrigination`")

	return query
}

// LoanBorrowers retrieves all the Borrower's Borrowers with an executor via loan_id column.
func (o *Loan) LoanBorrowers(mods ...qm.QueryMod) borrowerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`Borrower`.`loan_id`=?", o.LoanID),
	)

	query := Borrowers(queryMods...)
	queries.SetFrom(query.Query, "`Borrower`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`Borrower`.*"})
	}

	return query
}

// LoanInvestmentInLendings retrieves all the InvestmentInLending's InvestmentInLendings with an executor via loan_id column.
func (o *Loan) LoanInvestmentInLendings(mods ...qm.QueryMod) investmentInLendingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`InvestmentInLending`.`loan_id`=?", o.LoanID),
	)

	query := InvestmentInLendings(queryMods...)
	queries.SetFrom(query.Query, "`InvestmentInLending`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`InvestmentInLending`.*"})
	}

	return query
}

// LoanLoanInterests retrieves all the LoanInterest's LoanInterests with an executor via loan_id column.
func (o *Loan) LoanLoanInterests(mods ...qm.QueryMod) loanInterestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`LoanInterest`.`loan_id`=?", o.LoanID),
	)

	query := LoanInterests(queryMods...)
	queries.SetFrom(query.Query, "`LoanInterest`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`LoanInterest`.*"})
	}

	return query
}

// LoanLoanSchedules retrieves all the LoanSchedule's LoanSchedules with an executor via loan_id column.
func (o *Loan) LoanLoanSchedules(mods ...qm.QueryMod) loanScheduleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`LoanSchedule`.`loan_id`=?", o.LoanID),
	)

	query := LoanSchedules(queryMods...)
	queries.SetFrom(query.Query, "`LoanSchedule`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`LoanSchedule`.*"})
	}

	return query
}

// LoanPaymentLoans retrieves all the PaymentLoan's PaymentLoans with an executor via loan_id column.
func (o *Loan) LoanPaymentLoans(mods ...qm.QueryMod) paymentLoanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`PaymentLoan`.`loan_id`=?", o.LoanID),
	)

	query := PaymentLoans(queryMods...)
	queries.SetFrom(query.Query, "`PaymentLoan`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`PaymentLoan`.*"})
	}

	return query
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (loanL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.AccountID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Account`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Account")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Account")
	}

	if len(loanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &accountR{}
		}
		foreign.R.AccountLoans = append(foreign.R.AccountLoans, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AccountID == foreign.AccountID {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.AccountLoans = append(foreign.R.AccountLoans, local)
				break
			}
		}
	}

	return nil
}

// LoadAssetIDRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (loanL) LoadAssetIDRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		if !queries.IsNil(object.AssetIDRef) {
			args = append(args, object.AssetIDRef)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AssetIDRef) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AssetIDRef) {
				args = append(args, obj.AssetIDRef)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Assets`), qm.WhereIn(`asset_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Asset")
	}

	var resultSlice []*Asset
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Asset")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Assets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Assets")
	}

	if len(loanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AssetIDRef = foreign
		if foreign.R == nil {
			foreign.R = &assetR{}
		}
		foreign.R.AssetIDRefLoans = append(foreign.R.AssetIDRefLoans, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AssetIDRef, foreign.AssetID) {
				local.R.AssetIDRef = foreign
				if foreign.R == nil {
					foreign.R = &assetR{}
				}
				foreign.R.AssetIDRefLoans = append(foreign.R.AssetIDRefLoans, local)
				break
			}
		}
	}

	return nil
}

// LoadCreditOriginRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (loanL) LoadCreditOriginRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		if !queries.IsNil(object.CreditOriginRef) {
			args = append(args, object.CreditOriginRef)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CreditOriginRef) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CreditOriginRef) {
				args = append(args, obj.CreditOriginRef)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`CreditOrigination`), qm.WhereIn(`credit_origination_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CreditOrigination")
	}

	var resultSlice []*CreditOrigination
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CreditOrigination")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for CreditOrigination")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for CreditOrigination")
	}

	if len(loanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreditOriginRef = foreign
		if foreign.R == nil {
			foreign.R = &creditOriginationR{}
		}
		foreign.R.CreditOriginRefLoans = append(foreign.R.CreditOriginRefLoans, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreditOriginRef, foreign.CreditOriginationID) {
				local.R.CreditOriginRef = foreign
				if foreign.R == nil {
					foreign.R = &creditOriginationR{}
				}
				foreign.R.CreditOriginRefLoans = append(foreign.R.CreditOriginRefLoans, local)
				break
			}
		}
	}

	return nil
}

// LoadLoanBorrowers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (loanL) LoadLoanBorrowers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.LoanID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Borrower`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Borrower")
	}

	var resultSlice []*Borrower
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Borrower")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on Borrower")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Borrower")
	}

	if len(borrowerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoanBorrowers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &borrowerR{}
			}
			foreign.R.Loan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.LoanID == foreign.LoanID {
				local.R.LoanBorrowers = append(local.R.LoanBorrowers, foreign)
				if foreign.R == nil {
					foreign.R = &borrowerR{}
				}
				foreign.R.Loan = local
				break
			}
		}
	}

	return nil
}

// LoadLoanInvestmentInLendings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (loanL) LoadLoanInvestmentInLendings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.LoanID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`InvestmentInLending`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load InvestmentInLending")
	}

	var resultSlice []*InvestmentInLending
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice InvestmentInLending")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on InvestmentInLending")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for InvestmentInLending")
	}

	if len(investmentInLendingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoanInvestmentInLendings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &investmentInLendingR{}
			}
			foreign.R.Loan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.LoanID == foreign.LoanID {
				local.R.LoanInvestmentInLendings = append(local.R.LoanInvestmentInLendings, foreign)
				if foreign.R == nil {
					foreign.R = &investmentInLendingR{}
				}
				foreign.R.Loan = local
				break
			}
		}
	}

	return nil
}

// LoadLoanLoanInterests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (loanL) LoadLoanLoanInterests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.LoanID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`LoanInterest`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LoanInterest")
	}

	var resultSlice []*LoanInterest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LoanInterest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on LoanInterest")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for LoanInterest")
	}

	if len(loanInterestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoanLoanInterests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loanInterestR{}
			}
			foreign.R.Loan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.LoanID == foreign.LoanID {
				local.R.LoanLoanInterests = append(local.R.LoanLoanInterests, foreign)
				if foreign.R == nil {
					foreign.R = &loanInterestR{}
				}
				foreign.R.Loan = local
				break
			}
		}
	}

	return nil
}

// LoadLoanLoanSchedules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (loanL) LoadLoanLoanSchedules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.LoanID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`LoanSchedule`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LoanSchedule")
	}

	var resultSlice []*LoanSchedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LoanSchedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on LoanSchedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for LoanSchedule")
	}

	if len(loanScheduleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoanLoanSchedules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loanScheduleR{}
			}
			foreign.R.Loan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.LoanID == foreign.LoanID {
				local.R.LoanLoanSchedules = append(local.R.LoanLoanSchedules, foreign)
				if foreign.R == nil {
					foreign.R = &loanScheduleR{}
				}
				foreign.R.Loan = local
				break
			}
		}
	}

	return nil
}

// LoadLoanPaymentLoans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (loanL) LoadLoanPaymentLoans(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLoan interface{}, mods queries.Applicator) error {
	var slice []*Loan
	var object *Loan

	if singular {
		object = maybeLoan.(*Loan)
	} else {
		slice = *maybeLoan.(*[]*Loan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &loanR{}
		}
		args = append(args, object.LoanID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &loanR{}
			}

			for _, a := range args {
				if a == obj.LoanID {
					continue Outer
				}
			}

			args = append(args, obj.LoanID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`PaymentLoan`), qm.WhereIn(`loan_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentLoan")
	}

	var resultSlice []*PaymentLoan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentLoan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on PaymentLoan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for PaymentLoan")
	}

	if len(paymentLoanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoanPaymentLoans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentLoanR{}
			}
			foreign.R.Loan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.LoanID == foreign.LoanID {
				local.R.LoanPaymentLoans = append(local.R.LoanPaymentLoans, foreign)
				if foreign.R == nil {
					foreign.R = &paymentLoanR{}
				}
				foreign.R.Loan = local
				break
			}
		}
	}

	return nil
}

// SetAccount of the loan to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountLoans.
func (o *Loan) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Account) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Loan` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
		strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns),
	)
	values := []interface{}{related.AccountID, o.LoanID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AccountID = related.AccountID
	if o.R == nil {
		o.R = &loanR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &accountR{
			AccountLoans: LoanSlice{o},
		}
	} else {
		related.R.AccountLoans = append(related.R.AccountLoans, o)
	}

	return nil
}

// SetAssetIDRef of the loan to the related item.
// Sets o.R.AssetIDRef to related.
// Adds o to related.R.AssetIDRefLoans.
func (o *Loan) SetAssetIDRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Asset) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Loan` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"asset_id_ref"}),
		strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns),
	)
	values := []interface{}{related.AssetID, o.LoanID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AssetIDRef, related.AssetID)
	if o.R == nil {
		o.R = &loanR{
			AssetIDRef: related,
		}
	} else {
		o.R.AssetIDRef = related
	}

	if related.R == nil {
		related.R = &assetR{
			AssetIDRefLoans: LoanSlice{o},
		}
	} else {
		related.R.AssetIDRefLoans = append(related.R.AssetIDRefLoans, o)
	}

	return nil
}

// RemoveAssetIDRef relationship.
// Sets o.R.AssetIDRef to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Loan) RemoveAssetIDRef(ctx context.Context, exec boil.ContextExecutor, related *Asset) error {
	var err error

	queries.SetScanner(&o.AssetIDRef, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("asset_id_ref")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.AssetIDRef = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AssetIDRefLoans {
		if queries.Equal(o.AssetIDRef, ri.AssetIDRef) {
			continue
		}

		ln := len(related.R.AssetIDRefLoans)
		if ln > 1 && i < ln-1 {
			related.R.AssetIDRefLoans[i] = related.R.AssetIDRefLoans[ln-1]
		}
		related.R.AssetIDRefLoans = related.R.AssetIDRefLoans[:ln-1]
		break
	}
	return nil
}

// SetCreditOriginRef of the loan to the related item.
// Sets o.R.CreditOriginRef to related.
// Adds o to related.R.CreditOriginRefLoans.
func (o *Loan) SetCreditOriginRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CreditOrigination) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `Loan` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"credit_origin_ref"}),
		strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns),
	)
	values := []interface{}{related.CreditOriginationID, o.LoanID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreditOriginRef, related.CreditOriginationID)
	if o.R == nil {
		o.R = &loanR{
			CreditOriginRef: related,
		}
	} else {
		o.R.CreditOriginRef = related
	}

	if related.R == nil {
		related.R = &creditOriginationR{
			CreditOriginRefLoans: LoanSlice{o},
		}
	} else {
		related.R.CreditOriginRefLoans = append(related.R.CreditOriginRefLoans, o)
	}

	return nil
}

// RemoveCreditOriginRef relationship.
// Sets o.R.CreditOriginRef to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Loan) RemoveCreditOriginRef(ctx context.Context, exec boil.ContextExecutor, related *CreditOrigination) error {
	var err error

	queries.SetScanner(&o.CreditOriginRef, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("credit_origin_ref")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.CreditOriginRef = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreditOriginRefLoans {
		if queries.Equal(o.CreditOriginRef, ri.CreditOriginRef) {
			continue
		}

		ln := len(related.R.CreditOriginRefLoans)
		if ln > 1 && i < ln-1 {
			related.R.CreditOriginRefLoans[i] = related.R.CreditOriginRefLoans[ln-1]
		}
		related.R.CreditOriginRefLoans = related.R.CreditOriginRefLoans[:ln-1]
		break
	}
	return nil
}

// AddLoanBorrowers adds the given related objects to the existing relationships
// of the Loan, optionally inserting them as new records.
// Appends related to o.R.LoanBorrowers.
// Sets related.R.Loan appropriately.
func (o *Loan) AddLoanBorrowers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Borrower) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LoanID = o.LoanID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `Borrower` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
				strmangle.WhereClause("`", "`", 0, borrowerPrimaryKeyColumns),
			)
			values := []interface{}{o.LoanID, rel.BorrowerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LoanID = o.LoanID
		}
	}

	if o.R == nil {
		o.R = &loanR{
			LoanBorrowers: related,
		}
	} else {
		o.R.LoanBorrowers = append(o.R.LoanBorrowers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &borrowerR{
				Loan: o,
			}
		} else {
			rel.R.Loan = o
		}
	}
	return nil
}

// AddLoanInvestmentInLendings adds the given related objects to the existing relationships
// of the Loan, optionally inserting them as new records.
// Appends related to o.R.LoanInvestmentInLendings.
// Sets related.R.Loan appropriately.
func (o *Loan) AddLoanInvestmentInLendings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InvestmentInLending) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LoanID = o.LoanID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `InvestmentInLending` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
				strmangle.WhereClause("`", "`", 0, investmentInLendingPrimaryKeyColumns),
			)
			values := []interface{}{o.LoanID, rel.InvestmentLendingID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LoanID = o.LoanID
		}
	}

	if o.R == nil {
		o.R = &loanR{
			LoanInvestmentInLendings: related,
		}
	} else {
		o.R.LoanInvestmentInLendings = append(o.R.LoanInvestmentInLendings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &investmentInLendingR{
				Loan: o,
			}
		} else {
			rel.R.Loan = o
		}
	}
	return nil
}

// AddLoanLoanInterests adds the given related objects to the existing relationships
// of the Loan, optionally inserting them as new records.
// Appends related to o.R.LoanLoanInterests.
// Sets related.R.Loan appropriately.
func (o *Loan) AddLoanLoanInterests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoanInterest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LoanID = o.LoanID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `LoanInterest` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
				strmangle.WhereClause("`", "`", 0, loanInterestPrimaryKeyColumns),
			)
			values := []interface{}{o.LoanID, rel.LoanInterestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LoanID = o.LoanID
		}
	}

	if o.R == nil {
		o.R = &loanR{
			LoanLoanInterests: related,
		}
	} else {
		o.R.LoanLoanInterests = append(o.R.LoanLoanInterests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loanInterestR{
				Loan: o,
			}
		} else {
			rel.R.Loan = o
		}
	}
	return nil
}

// AddLoanLoanSchedules adds the given related objects to the existing relationships
// of the Loan, optionally inserting them as new records.
// Appends related to o.R.LoanLoanSchedules.
// Sets related.R.Loan appropriately.
func (o *Loan) AddLoanLoanSchedules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoanSchedule) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LoanID = o.LoanID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `LoanSchedule` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
				strmangle.WhereClause("`", "`", 0, loanSchedulePrimaryKeyColumns),
			)
			values := []interface{}{o.LoanID, rel.LoanScheduleID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LoanID = o.LoanID
		}
	}

	if o.R == nil {
		o.R = &loanR{
			LoanLoanSchedules: related,
		}
	} else {
		o.R.LoanLoanSchedules = append(o.R.LoanLoanSchedules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loanScheduleR{
				Loan: o,
			}
		} else {
			rel.R.Loan = o
		}
	}
	return nil
}

// AddLoanPaymentLoans adds the given related objects to the existing relationships
// of the Loan, optionally inserting them as new records.
// Appends related to o.R.LoanPaymentLoans.
// Sets related.R.Loan appropriately.
func (o *Loan) AddLoanPaymentLoans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLoan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LoanID = o.LoanID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `PaymentLoan` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"loan_id"}),
				strmangle.WhereClause("`", "`", 0, paymentLoanPrimaryKeyColumns),
			)
			values := []interface{}{o.LoanID, rel.PaymentLoanID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LoanID = o.LoanID
		}
	}

	if o.R == nil {
		o.R = &loanR{
			LoanPaymentLoans: related,
		}
	} else {
		o.R.LoanPaymentLoans = append(o.R.LoanPaymentLoans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentLoanR{
				Loan: o,
			}
		} else {
			rel.R.Loan = o
		}
	}
	return nil
}

// Loans retrieves all the records using an executor.
func Loans(mods ...qm.QueryMod) loanQuery {
	mods = append(mods, qm.From("`Loan`"))
	return loanQuery{NewQuery(mods...)}
}

// FindLoan retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindLoan(ctx context.Context, exec boil.ContextExecutor, loanID int, selectCols ...string) (*Loan, error) {
	loanObj := &Loan{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `Loan` where `loan_id`=?", sel,
	)

	q := queries.Raw(query, loanID)

	err := q.Bind(ctx, exec, loanObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from Loan")
	}

	return loanObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Loan) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Loan provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(loanColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	loanInsertCacheMut.RLock()
	cache, cached := loanInsertCache[key]
	loanInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			loanColumns,
			loanColumnsWithDefault,
			loanColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(loanType, loanMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(loanType, loanMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `Loan` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `Loan` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `Loan` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into Loan")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.LoanID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Loan")
	}

CacheNoHooks:
	if !cached {
		loanInsertCacheMut.Lock()
		loanInsertCache[key] = cache
		loanInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Loan.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Loan) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	loanUpdateCacheMut.RLock()
	cache, cached := loanUpdateCache[key]
	loanUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			loanColumns,
			loanPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update Loan, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `Loan` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, loanPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(loanType, loanMapping, append(wl, loanPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update Loan row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for Loan")
	}

	if !cached {
		loanUpdateCacheMut.Lock()
		loanUpdateCache[key] = cache
		loanUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q loanQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for Loan")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for Loan")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o LoanSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), loanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `Loan` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, loanPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in loan slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all loan")
	}
	return rowsAff, nil
}

var mySQLLoanUniqueColumns = []string{
	"loan_id",
	"loan_ref_number",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Loan) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no Loan provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(loanColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLLoanUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	loanUpsertCacheMut.RLock()
	cache, cached := loanUpsertCache[key]
	loanUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			loanColumns,
			loanColumnsWithDefault,
			loanColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			loanColumns,
			loanPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert Loan, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "Loan", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `Loan` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(loanType, loanMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(loanType, loanMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for Loan")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(loanType, loanMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for Loan")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for Loan")
	}

CacheNoHooks:
	if !cached {
		loanUpsertCacheMut.Lock()
		loanUpsertCache[key] = cache
		loanUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Loan record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Loan) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Loan provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), loanPrimaryKeyMapping)
	sql := "DELETE FROM `Loan` WHERE `loan_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from Loan")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for Loan")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q loanQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no loanQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from Loan")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Loan")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o LoanSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Loan slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(loanBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), loanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `Loan` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, loanPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from loan slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for Loan")
	}

	if len(loanAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Loan) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindLoan(ctx, exec, o.LoanID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *LoanSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := LoanSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), loanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `Loan`.* FROM `Loan` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, loanPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in LoanSlice")
	}

	*o = slice

	return nil
}

// LoanExists checks if the Loan row exists.
func LoanExists(ctx context.Context, exec boil.ContextExecutor, loanID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `Loan` where `loan_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, loanID)
	}

	row := exec.QueryRowContext(ctx, sql, loanID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if Loan exists")
	}

	return exists, nil
}
