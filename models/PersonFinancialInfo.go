// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// PersonFinancialInfo is an object representing the database table.
type PersonFinancialInfo struct {
	PersonFinancialInfoID      int               `boil:"person_financial_info_id" json:"person_financial_info_id" toml:"person_financial_info_id" yaml:"person_financial_info_id"`
	PartyID                    int               `boil:"party_id" json:"party_id" toml:"party_id" yaml:"party_id"`
	BankID                     int               `boil:"bank_id" json:"bank_id" toml:"bank_id" yaml:"bank_id"`
	InvestmentGoal             null.String       `boil:"investment_goal" json:"investment_goal,omitempty" toml:"investment_goal" yaml:"investment_goal,omitempty"`
	AnnualFinancialCommitments types.NullDecimal `boil:"annual_financial_commitments" json:"annual_financial_commitments,omitempty" toml:"annual_financial_commitments" yaml:"annual_financial_commitments,omitempty"`
	TaxTatus                   null.String       `boil:"tax_tatus" json:"tax_tatus,omitempty" toml:"tax_tatus" yaml:"tax_tatus,omitempty"`
	TaxBracket                 null.String       `boil:"tax_bracket" json:"tax_bracket,omitempty" toml:"tax_bracket" yaml:"tax_bracket,omitempty"`
	AnnualIncome               types.NullDecimal `boil:"annual_income" json:"annual_income,omitempty" toml:"annual_income" yaml:"annual_income,omitempty"`
	NetWorth                   types.NullDecimal `boil:"net_worth" json:"net_worth,omitempty" toml:"net_worth" yaml:"net_worth,omitempty"`
	RiskTolerance              null.String       `boil:"risk_tolerance" json:"risk_tolerance,omitempty" toml:"risk_tolerance" yaml:"risk_tolerance,omitempty"`
	MaxVolatilityLevel         null.String       `boil:"max_volatility_level" json:"max_volatility_level,omitempty" toml:"max_volatility_level" yaml:"max_volatility_level,omitempty"`
	TargetRateOfReturn         types.NullDecimal `boil:"target_rate_of_return" json:"target_rate_of_return,omitempty" toml:"target_rate_of_return" yaml:"target_rate_of_return,omitempty"`
	InvestmentHorizon          null.String       `boil:"investment_horizon" json:"investment_horizon,omitempty" toml:"investment_horizon" yaml:"investment_horizon,omitempty"`
	DebitCardHolderIndicator   string            `boil:"debit_card_holder_indicator" json:"debit_card_holder_indicator" toml:"debit_card_holder_indicator" yaml:"debit_card_holder_indicator"`
	CreditCardHolderIndicator  string            `boil:"credit_card_holder_indicator" json:"credit_card_holder_indicator" toml:"credit_card_holder_indicator" yaml:"credit_card_holder_indicator"`
	TotalMonthlyIncome         types.Decimal     `boil:"total_monthly_income" json:"total_monthly_income" toml:"total_monthly_income" yaml:"total_monthly_income"`
	MakerDate                  time.Time         `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate                null.Time         `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                    string            `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                  null.String       `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy                 null.String       `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate               null.Time         `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *personFinancialInfoR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L personFinancialInfoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PersonFinancialInfoColumns = struct {
	PersonFinancialInfoID      string
	PartyID                    string
	BankID                     string
	InvestmentGoal             string
	AnnualFinancialCommitments string
	TaxTatus                   string
	TaxBracket                 string
	AnnualIncome               string
	NetWorth                   string
	RiskTolerance              string
	MaxVolatilityLevel         string
	TargetRateOfReturn         string
	InvestmentHorizon          string
	DebitCardHolderIndicator   string
	CreditCardHolderIndicator  string
	TotalMonthlyIncome         string
	MakerDate                  string
	CheckerDate                string
	MakerID                    string
	CheckerID                  string
	ModifiedBy                 string
	ModifiedDate               string
}{
	PersonFinancialInfoID:      "person_financial_info_id",
	PartyID:                    "party_id",
	BankID:                     "bank_id",
	InvestmentGoal:             "investment_goal",
	AnnualFinancialCommitments: "annual_financial_commitments",
	TaxTatus:                   "tax_tatus",
	TaxBracket:                 "tax_bracket",
	AnnualIncome:               "annual_income",
	NetWorth:                   "net_worth",
	RiskTolerance:              "risk_tolerance",
	MaxVolatilityLevel:         "max_volatility_level",
	TargetRateOfReturn:         "target_rate_of_return",
	InvestmentHorizon:          "investment_horizon",
	DebitCardHolderIndicator:   "debit_card_holder_indicator",
	CreditCardHolderIndicator:  "credit_card_holder_indicator",
	TotalMonthlyIncome:         "total_monthly_income",
	MakerDate:                  "maker_date",
	CheckerDate:                "checker_date",
	MakerID:                    "maker_id",
	CheckerID:                  "checker_id",
	ModifiedBy:                 "modified_by",
	ModifiedDate:               "modified_date",
}

// Generated where

var PersonFinancialInfoWhere = struct {
	PersonFinancialInfoID      whereHelperint
	PartyID                    whereHelperint
	BankID                     whereHelperint
	InvestmentGoal             whereHelpernull_String
	AnnualFinancialCommitments whereHelpertypes_NullDecimal
	TaxTatus                   whereHelpernull_String
	TaxBracket                 whereHelpernull_String
	AnnualIncome               whereHelpertypes_NullDecimal
	NetWorth                   whereHelpertypes_NullDecimal
	RiskTolerance              whereHelpernull_String
	MaxVolatilityLevel         whereHelpernull_String
	TargetRateOfReturn         whereHelpertypes_NullDecimal
	InvestmentHorizon          whereHelpernull_String
	DebitCardHolderIndicator   whereHelperstring
	CreditCardHolderIndicator  whereHelperstring
	TotalMonthlyIncome         whereHelpertypes_Decimal
	MakerDate                  whereHelpertime_Time
	CheckerDate                whereHelpernull_Time
	MakerID                    whereHelperstring
	CheckerID                  whereHelpernull_String
	ModifiedBy                 whereHelpernull_String
	ModifiedDate               whereHelpernull_Time
}{
	PersonFinancialInfoID:      whereHelperint{field: `person_financial_info_id`},
	PartyID:                    whereHelperint{field: `party_id`},
	BankID:                     whereHelperint{field: `bank_id`},
	InvestmentGoal:             whereHelpernull_String{field: `investment_goal`},
	AnnualFinancialCommitments: whereHelpertypes_NullDecimal{field: `annual_financial_commitments`},
	TaxTatus:                   whereHelpernull_String{field: `tax_tatus`},
	TaxBracket:                 whereHelpernull_String{field: `tax_bracket`},
	AnnualIncome:               whereHelpertypes_NullDecimal{field: `annual_income`},
	NetWorth:                   whereHelpertypes_NullDecimal{field: `net_worth`},
	RiskTolerance:              whereHelpernull_String{field: `risk_tolerance`},
	MaxVolatilityLevel:         whereHelpernull_String{field: `max_volatility_level`},
	TargetRateOfReturn:         whereHelpertypes_NullDecimal{field: `target_rate_of_return`},
	InvestmentHorizon:          whereHelpernull_String{field: `investment_horizon`},
	DebitCardHolderIndicator:   whereHelperstring{field: `debit_card_holder_indicator`},
	CreditCardHolderIndicator:  whereHelperstring{field: `credit_card_holder_indicator`},
	TotalMonthlyIncome:         whereHelpertypes_Decimal{field: `total_monthly_income`},
	MakerDate:                  whereHelpertime_Time{field: `maker_date`},
	CheckerDate:                whereHelpernull_Time{field: `checker_date`},
	MakerID:                    whereHelperstring{field: `maker_id`},
	CheckerID:                  whereHelpernull_String{field: `checker_id`},
	ModifiedBy:                 whereHelpernull_String{field: `modified_by`},
	ModifiedDate:               whereHelpernull_Time{field: `modified_date`},
}

// PersonFinancialInfoRels is where relationship names are stored.
var PersonFinancialInfoRels = struct {
	Bank  string
	Party string
}{
	Bank:  "Bank",
	Party: "Party",
}

// personFinancialInfoR is where relationships are stored.
type personFinancialInfoR struct {
	Bank  *Bank
	Party *Party
}

// NewStruct creates a new relationship struct
func (*personFinancialInfoR) NewStruct() *personFinancialInfoR {
	return &personFinancialInfoR{}
}

// personFinancialInfoL is where Load methods for each relationship are stored.
type personFinancialInfoL struct{}

var (
	personFinancialInfoColumns               = []string{"person_financial_info_id", "party_id", "bank_id", "investment_goal", "annual_financial_commitments", "tax_tatus", "tax_bracket", "annual_income", "net_worth", "risk_tolerance", "max_volatility_level", "target_rate_of_return", "investment_horizon", "debit_card_holder_indicator", "credit_card_holder_indicator", "total_monthly_income", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	personFinancialInfoColumnsWithoutDefault = []string{"party_id", "bank_id", "investment_goal", "annual_financial_commitments", "tax_tatus", "tax_bracket", "annual_income", "net_worth", "risk_tolerance", "max_volatility_level", "target_rate_of_return", "investment_horizon", "debit_card_holder_indicator", "credit_card_holder_indicator", "total_monthly_income", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	personFinancialInfoColumnsWithDefault    = []string{"person_financial_info_id"}
	personFinancialInfoPrimaryKeyColumns     = []string{"person_financial_info_id"}
)

type (
	// PersonFinancialInfoSlice is an alias for a slice of pointers to PersonFinancialInfo.
	// This should generally be used opposed to []PersonFinancialInfo.
	PersonFinancialInfoSlice []*PersonFinancialInfo
	// PersonFinancialInfoHook is the signature for custom PersonFinancialInfo hook methods
	PersonFinancialInfoHook func(context.Context, boil.ContextExecutor, *PersonFinancialInfo) error

	personFinancialInfoQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	personFinancialInfoType                 = reflect.TypeOf(&PersonFinancialInfo{})
	personFinancialInfoMapping              = queries.MakeStructMapping(personFinancialInfoType)
	personFinancialInfoPrimaryKeyMapping, _ = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, personFinancialInfoPrimaryKeyColumns)
	personFinancialInfoInsertCacheMut       sync.RWMutex
	personFinancialInfoInsertCache          = make(map[string]insertCache)
	personFinancialInfoUpdateCacheMut       sync.RWMutex
	personFinancialInfoUpdateCache          = make(map[string]updateCache)
	personFinancialInfoUpsertCacheMut       sync.RWMutex
	personFinancialInfoUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var personFinancialInfoBeforeInsertHooks []PersonFinancialInfoHook
var personFinancialInfoBeforeUpdateHooks []PersonFinancialInfoHook
var personFinancialInfoBeforeDeleteHooks []PersonFinancialInfoHook
var personFinancialInfoBeforeUpsertHooks []PersonFinancialInfoHook

var personFinancialInfoAfterInsertHooks []PersonFinancialInfoHook
var personFinancialInfoAfterSelectHooks []PersonFinancialInfoHook
var personFinancialInfoAfterUpdateHooks []PersonFinancialInfoHook
var personFinancialInfoAfterDeleteHooks []PersonFinancialInfoHook
var personFinancialInfoAfterUpsertHooks []PersonFinancialInfoHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PersonFinancialInfo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PersonFinancialInfo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PersonFinancialInfo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PersonFinancialInfo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PersonFinancialInfo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PersonFinancialInfo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PersonFinancialInfo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PersonFinancialInfo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PersonFinancialInfo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personFinancialInfoAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPersonFinancialInfoHook registers your hook function for all future operations.
func AddPersonFinancialInfoHook(hookPoint boil.HookPoint, personFinancialInfoHook PersonFinancialInfoHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		personFinancialInfoBeforeInsertHooks = append(personFinancialInfoBeforeInsertHooks, personFinancialInfoHook)
	case boil.BeforeUpdateHook:
		personFinancialInfoBeforeUpdateHooks = append(personFinancialInfoBeforeUpdateHooks, personFinancialInfoHook)
	case boil.BeforeDeleteHook:
		personFinancialInfoBeforeDeleteHooks = append(personFinancialInfoBeforeDeleteHooks, personFinancialInfoHook)
	case boil.BeforeUpsertHook:
		personFinancialInfoBeforeUpsertHooks = append(personFinancialInfoBeforeUpsertHooks, personFinancialInfoHook)
	case boil.AfterInsertHook:
		personFinancialInfoAfterInsertHooks = append(personFinancialInfoAfterInsertHooks, personFinancialInfoHook)
	case boil.AfterSelectHook:
		personFinancialInfoAfterSelectHooks = append(personFinancialInfoAfterSelectHooks, personFinancialInfoHook)
	case boil.AfterUpdateHook:
		personFinancialInfoAfterUpdateHooks = append(personFinancialInfoAfterUpdateHooks, personFinancialInfoHook)
	case boil.AfterDeleteHook:
		personFinancialInfoAfterDeleteHooks = append(personFinancialInfoAfterDeleteHooks, personFinancialInfoHook)
	case boil.AfterUpsertHook:
		personFinancialInfoAfterUpsertHooks = append(personFinancialInfoAfterUpsertHooks, personFinancialInfoHook)
	}
}

// One returns a single personFinancialInfo record from the query.
func (q personFinancialInfoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PersonFinancialInfo, error) {
	o := &PersonFinancialInfo{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for PersonFinancialInfo")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PersonFinancialInfo records from the query.
func (q personFinancialInfoQuery) All(ctx context.Context, exec boil.ContextExecutor) (PersonFinancialInfoSlice, error) {
	var o []*PersonFinancialInfo

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to PersonFinancialInfo slice")
	}

	if len(personFinancialInfoAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PersonFinancialInfo records in the query.
func (q personFinancialInfoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count PersonFinancialInfo rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q personFinancialInfoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if PersonFinancialInfo exists")
	}

	return count > 0, nil
}

// Bank pointed to by the foreign key.
func (o *PersonFinancialInfo) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// Party pointed to by the foreign key.
func (o *PersonFinancialInfo) Party(mods ...qm.QueryMod) partyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("party_id=?", o.PartyID),
	}

	queryMods = append(queryMods, mods...)

	query := Parties(queryMods...)
	queries.SetFrom(query.Query, "`Parties`")

	return query
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (personFinancialInfoL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybePersonFinancialInfo interface{}, mods queries.Applicator) error {
	var slice []*PersonFinancialInfo
	var object *PersonFinancialInfo

	if singular {
		object = maybePersonFinancialInfo.(*PersonFinancialInfo)
	} else {
		slice = *maybePersonFinancialInfo.(*[]*PersonFinancialInfo)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &personFinancialInfoR{}
		}
		args = append(args, object.BankID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &personFinancialInfoR{}
			}

			for _, a := range args {
				if a == obj.BankID {
					continue Outer
				}
			}

			args = append(args, obj.BankID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(personFinancialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankPersonFinancialInfos = append(foreign.R.BankPersonFinancialInfos, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BankID == foreign.BankID {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankPersonFinancialInfos = append(foreign.R.BankPersonFinancialInfos, local)
				break
			}
		}
	}

	return nil
}

// LoadParty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (personFinancialInfoL) LoadParty(ctx context.Context, e boil.ContextExecutor, singular bool, maybePersonFinancialInfo interface{}, mods queries.Applicator) error {
	var slice []*PersonFinancialInfo
	var object *PersonFinancialInfo

	if singular {
		object = maybePersonFinancialInfo.(*PersonFinancialInfo)
	} else {
		slice = *maybePersonFinancialInfo.(*[]*PersonFinancialInfo)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &personFinancialInfoR{}
		}
		args = append(args, object.PartyID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &personFinancialInfoR{}
			}

			for _, a := range args {
				if a == obj.PartyID {
					continue Outer
				}
			}

			args = append(args, obj.PartyID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Parties`), qm.WhereIn(`party_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Party")
	}

	var resultSlice []*Party
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Party")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Parties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Parties")
	}

	if len(personFinancialInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Party = foreign
		if foreign.R == nil {
			foreign.R = &partyR{}
		}
		foreign.R.PartyPersonFinancialInfo = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PartyID == foreign.PartyID {
				local.R.Party = foreign
				if foreign.R == nil {
					foreign.R = &partyR{}
				}
				foreign.R.PartyPersonFinancialInfo = local
				break
			}
		}
	}

	return nil
}

// SetBank of the personFinancialInfo to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankPersonFinancialInfos.
func (o *PersonFinancialInfo) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `PersonFinancialInfo` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.PersonFinancialInfoID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BankID = related.BankID
	if o.R == nil {
		o.R = &personFinancialInfoR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankPersonFinancialInfos: PersonFinancialInfoSlice{o},
		}
	} else {
		related.R.BankPersonFinancialInfos = append(related.R.BankPersonFinancialInfos, o)
	}

	return nil
}

// SetParty of the personFinancialInfo to the related item.
// Sets o.R.Party to related.
// Adds o to related.R.PartyPersonFinancialInfo.
func (o *PersonFinancialInfo) SetParty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Party) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `PersonFinancialInfo` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"party_id"}),
		strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns),
	)
	values := []interface{}{related.PartyID, o.PersonFinancialInfoID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PartyID = related.PartyID
	if o.R == nil {
		o.R = &personFinancialInfoR{
			Party: related,
		}
	} else {
		o.R.Party = related
	}

	if related.R == nil {
		related.R = &partyR{
			PartyPersonFinancialInfo: o,
		}
	} else {
		related.R.PartyPersonFinancialInfo = o
	}

	return nil
}

// PersonFinancialInfos retrieves all the records using an executor.
func PersonFinancialInfos(mods ...qm.QueryMod) personFinancialInfoQuery {
	mods = append(mods, qm.From("`PersonFinancialInfo`"))
	return personFinancialInfoQuery{NewQuery(mods...)}
}

// FindPersonFinancialInfo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPersonFinancialInfo(ctx context.Context, exec boil.ContextExecutor, personFinancialInfoID int, selectCols ...string) (*PersonFinancialInfo, error) {
	personFinancialInfoObj := &PersonFinancialInfo{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `PersonFinancialInfo` where `person_financial_info_id`=?", sel,
	)

	q := queries.Raw(query, personFinancialInfoID)

	err := q.Bind(ctx, exec, personFinancialInfoObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from PersonFinancialInfo")
	}

	return personFinancialInfoObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PersonFinancialInfo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PersonFinancialInfo provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(personFinancialInfoColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	personFinancialInfoInsertCacheMut.RLock()
	cache, cached := personFinancialInfoInsertCache[key]
	personFinancialInfoInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			personFinancialInfoColumns,
			personFinancialInfoColumnsWithDefault,
			personFinancialInfoColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `PersonFinancialInfo` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `PersonFinancialInfo` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `PersonFinancialInfo` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into PersonFinancialInfo")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PersonFinancialInfoID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == personFinancialInfoMapping["PersonFinancialInfoID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PersonFinancialInfoID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PersonFinancialInfo")
	}

CacheNoHooks:
	if !cached {
		personFinancialInfoInsertCacheMut.Lock()
		personFinancialInfoInsertCache[key] = cache
		personFinancialInfoInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the PersonFinancialInfo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PersonFinancialInfo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	personFinancialInfoUpdateCacheMut.RLock()
	cache, cached := personFinancialInfoUpdateCache[key]
	personFinancialInfoUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			personFinancialInfoColumns,
			personFinancialInfoPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update PersonFinancialInfo, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `PersonFinancialInfo` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, personFinancialInfoPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, append(wl, personFinancialInfoPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update PersonFinancialInfo row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for PersonFinancialInfo")
	}

	if !cached {
		personFinancialInfoUpdateCacheMut.Lock()
		personFinancialInfoUpdateCache[key] = cache
		personFinancialInfoUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q personFinancialInfoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for PersonFinancialInfo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for PersonFinancialInfo")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PersonFinancialInfoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), personFinancialInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `PersonFinancialInfo` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, personFinancialInfoPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in personFinancialInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all personFinancialInfo")
	}
	return rowsAff, nil
}

var mySQLPersonFinancialInfoUniqueColumns = []string{
	"person_financial_info_id",
	"party_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PersonFinancialInfo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no PersonFinancialInfo provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(personFinancialInfoColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPersonFinancialInfoUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	personFinancialInfoUpsertCacheMut.RLock()
	cache, cached := personFinancialInfoUpsertCache[key]
	personFinancialInfoUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			personFinancialInfoColumns,
			personFinancialInfoColumnsWithDefault,
			personFinancialInfoColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			personFinancialInfoColumns,
			personFinancialInfoPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert PersonFinancialInfo, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "PersonFinancialInfo", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `PersonFinancialInfo` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for PersonFinancialInfo")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.PersonFinancialInfoID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == personFinancialInfoMapping["person_financial_info_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(personFinancialInfoType, personFinancialInfoMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for PersonFinancialInfo")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for PersonFinancialInfo")
	}

CacheNoHooks:
	if !cached {
		personFinancialInfoUpsertCacheMut.Lock()
		personFinancialInfoUpsertCache[key] = cache
		personFinancialInfoUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single PersonFinancialInfo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PersonFinancialInfo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PersonFinancialInfo provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), personFinancialInfoPrimaryKeyMapping)
	sql := "DELETE FROM `PersonFinancialInfo` WHERE `person_financial_info_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from PersonFinancialInfo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for PersonFinancialInfo")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q personFinancialInfoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no personFinancialInfoQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from PersonFinancialInfo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PersonFinancialInfo")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PersonFinancialInfoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PersonFinancialInfo slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(personFinancialInfoBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), personFinancialInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `PersonFinancialInfo` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, personFinancialInfoPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from personFinancialInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for PersonFinancialInfo")
	}

	if len(personFinancialInfoAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PersonFinancialInfo) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPersonFinancialInfo(ctx, exec, o.PersonFinancialInfoID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PersonFinancialInfoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PersonFinancialInfoSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), personFinancialInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `PersonFinancialInfo`.* FROM `PersonFinancialInfo` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, personFinancialInfoPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PersonFinancialInfoSlice")
	}

	*o = slice

	return nil
}

// PersonFinancialInfoExists checks if the PersonFinancialInfo row exists.
func PersonFinancialInfoExists(ctx context.Context, exec boil.ContextExecutor, personFinancialInfoID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `PersonFinancialInfo` where `person_financial_info_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, personFinancialInfoID)
	}

	row := exec.QueryRowContext(ctx, sql, personFinancialInfoID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if PersonFinancialInfo exists")
	}

	return exists, nil
}
