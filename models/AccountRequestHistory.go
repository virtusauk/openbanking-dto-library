// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// AccountRequestHistory is an object representing the database table.
type AccountRequestHistory struct {
	AccountRequestHistoryID  int         `boil:"account_request_history_id" json:"account_request_history_id" toml:"account_request_history_id" yaml:"account_request_history_id"`
	AccountIDRef             string      `boil:"account_id_ref" json:"account_id_ref" toml:"account_id_ref" yaml:"account_id_ref"`
	AccountRequestReference  string      `boil:"account_request_reference" json:"account_request_reference" toml:"account_request_reference" yaml:"account_request_reference"`
	AccountID                null.Int    `boil:"account_id" json:"account_id,omitempty" toml:"account_id" yaml:"account_id,omitempty"`
	SchemeName               string      `boil:"scheme_name" json:"scheme_name" toml:"scheme_name" yaml:"scheme_name"`
	AccountIdentification    string      `boil:"account_identification" json:"account_identification" toml:"account_identification" yaml:"account_identification"`
	PartyID                  null.Int    `boil:"party_id" json:"party_id,omitempty" toml:"party_id" yaml:"party_id,omitempty"`
	BankID                   null.Int    `boil:"bank_id" json:"bank_id,omitempty" toml:"bank_id" yaml:"bank_id,omitempty"`
	Name                     string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Status                   string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	ReadAccountsBasic        string      `boil:"read_accounts_basic" json:"read_accounts_basic" toml:"read_accounts_basic" yaml:"read_accounts_basic"`
	ReadAccountsDetail       string      `boil:"read_accounts_detail" json:"read_accounts_detail" toml:"read_accounts_detail" yaml:"read_accounts_detail"`
	ReadBalances             string      `boil:"read_balances" json:"read_balances" toml:"read_balances" yaml:"read_balances"`
	ReadBeneficiariesBasic   string      `boil:"read_beneficiaries_basic" json:"read_beneficiaries_basic" toml:"read_beneficiaries_basic" yaml:"read_beneficiaries_basic"`
	ReadBeneficiariesDetail  string      `boil:"read_beneficiaries_detail" json:"read_beneficiaries_detail" toml:"read_beneficiaries_detail" yaml:"read_beneficiaries_detail"`
	ReadDirectDebits         string      `boil:"read_direct_debits" json:"read_direct_debits" toml:"read_direct_debits" yaml:"read_direct_debits"`
	ReadProducts             string      `boil:"read_products" json:"read_products" toml:"read_products" yaml:"read_products"`
	ReadStandingOrdersBasic  string      `boil:"read_standing_orders_basic" json:"read_standing_orders_basic" toml:"read_standing_orders_basic" yaml:"read_standing_orders_basic"`
	ReadStandingOrdersDetail string      `boil:"read_standing_orders_detail" json:"read_standing_orders_detail" toml:"read_standing_orders_detail" yaml:"read_standing_orders_detail"`
	ReadTransactionsBasic    string      `boil:"read_transactions_basic" json:"read_transactions_basic" toml:"read_transactions_basic" yaml:"read_transactions_basic"`
	ReadTransactionsCredits  string      `boil:"read_transactions_credits" json:"read_transactions_credits" toml:"read_transactions_credits" yaml:"read_transactions_credits"`
	ReadTransactionsDebits   string      `boil:"read_transactions_debits" json:"read_transactions_debits" toml:"read_transactions_debits" yaml:"read_transactions_debits"`
	ReadTransactionsDetail   string      `boil:"read_transactions_detail" json:"read_transactions_detail" toml:"read_transactions_detail" yaml:"read_transactions_detail"`
	ExpirationDateTime       time.Time   `boil:"expiration_date_time" json:"expiration_date_time" toml:"expiration_date_time" yaml:"expiration_date_time"`
	TransactionFromDateTime  time.Time   `boil:"transaction_from_date_time" json:"transaction_from_date_time" toml:"transaction_from_date_time" yaml:"transaction_from_date_time"`
	TransactionToDateTime    time.Time   `boil:"transaction_to_date_time" json:"transaction_to_date_time" toml:"transaction_to_date_time" yaml:"transaction_to_date_time"`
	MakerDate                time.Time   `boil:"maker_date" json:"maker_date" toml:"maker_date" yaml:"maker_date"`
	CheckerDate              null.Time   `boil:"checker_date" json:"checker_date,omitempty" toml:"checker_date" yaml:"checker_date,omitempty"`
	MakerID                  string      `boil:"maker_id" json:"maker_id" toml:"maker_id" yaml:"maker_id"`
	CheckerID                null.String `boil:"checker_id" json:"checker_id,omitempty" toml:"checker_id" yaml:"checker_id,omitempty"`
	ModifiedBy               null.String `boil:"modified_by" json:"modified_by,omitempty" toml:"modified_by" yaml:"modified_by,omitempty"`
	ModifiedDate             null.Time   `boil:"modified_date" json:"modified_date,omitempty" toml:"modified_date" yaml:"modified_date,omitempty"`

	R *accountRequestHistoryR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountRequestHistoryL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountRequestHistoryColumns = struct {
	AccountRequestHistoryID  string
	AccountIDRef             string
	AccountRequestReference  string
	AccountID                string
	SchemeName               string
	AccountIdentification    string
	PartyID                  string
	BankID                   string
	Name                     string
	Status                   string
	ReadAccountsBasic        string
	ReadAccountsDetail       string
	ReadBalances             string
	ReadBeneficiariesBasic   string
	ReadBeneficiariesDetail  string
	ReadDirectDebits         string
	ReadProducts             string
	ReadStandingOrdersBasic  string
	ReadStandingOrdersDetail string
	ReadTransactionsBasic    string
	ReadTransactionsCredits  string
	ReadTransactionsDebits   string
	ReadTransactionsDetail   string
	ExpirationDateTime       string
	TransactionFromDateTime  string
	TransactionToDateTime    string
	MakerDate                string
	CheckerDate              string
	MakerID                  string
	CheckerID                string
	ModifiedBy               string
	ModifiedDate             string
}{
	AccountRequestHistoryID:  "account_request_history_id",
	AccountIDRef:             "account_id_ref",
	AccountRequestReference:  "account_request_reference",
	AccountID:                "account_id",
	SchemeName:               "scheme_name",
	AccountIdentification:    "account_identification",
	PartyID:                  "party_id",
	BankID:                   "bank_id",
	Name:                     "name",
	Status:                   "status",
	ReadAccountsBasic:        "read_accounts_basic",
	ReadAccountsDetail:       "read_accounts_detail",
	ReadBalances:             "read_balances",
	ReadBeneficiariesBasic:   "read_beneficiaries_basic",
	ReadBeneficiariesDetail:  "read_beneficiaries_detail",
	ReadDirectDebits:         "read_direct_debits",
	ReadProducts:             "read_products",
	ReadStandingOrdersBasic:  "read_standing_orders_basic",
	ReadStandingOrdersDetail: "read_standing_orders_detail",
	ReadTransactionsBasic:    "read_transactions_basic",
	ReadTransactionsCredits:  "read_transactions_credits",
	ReadTransactionsDebits:   "read_transactions_debits",
	ReadTransactionsDetail:   "read_transactions_detail",
	ExpirationDateTime:       "expiration_date_time",
	TransactionFromDateTime:  "transaction_from_date_time",
	TransactionToDateTime:    "transaction_to_date_time",
	MakerDate:                "maker_date",
	CheckerDate:              "checker_date",
	MakerID:                  "maker_id",
	CheckerID:                "checker_id",
	ModifiedBy:               "modified_by",
	ModifiedDate:             "modified_date",
}

// Generated where

var AccountRequestHistoryWhere = struct {
	AccountRequestHistoryID  whereHelperint
	AccountIDRef             whereHelperstring
	AccountRequestReference  whereHelperstring
	AccountID                whereHelpernull_Int
	SchemeName               whereHelperstring
	AccountIdentification    whereHelperstring
	PartyID                  whereHelpernull_Int
	BankID                   whereHelpernull_Int
	Name                     whereHelperstring
	Status                   whereHelperstring
	ReadAccountsBasic        whereHelperstring
	ReadAccountsDetail       whereHelperstring
	ReadBalances             whereHelperstring
	ReadBeneficiariesBasic   whereHelperstring
	ReadBeneficiariesDetail  whereHelperstring
	ReadDirectDebits         whereHelperstring
	ReadProducts             whereHelperstring
	ReadStandingOrdersBasic  whereHelperstring
	ReadStandingOrdersDetail whereHelperstring
	ReadTransactionsBasic    whereHelperstring
	ReadTransactionsCredits  whereHelperstring
	ReadTransactionsDebits   whereHelperstring
	ReadTransactionsDetail   whereHelperstring
	ExpirationDateTime       whereHelpertime_Time
	TransactionFromDateTime  whereHelpertime_Time
	TransactionToDateTime    whereHelpertime_Time
	MakerDate                whereHelpertime_Time
	CheckerDate              whereHelpernull_Time
	MakerID                  whereHelperstring
	CheckerID                whereHelpernull_String
	ModifiedBy               whereHelpernull_String
	ModifiedDate             whereHelpernull_Time
}{
	AccountRequestHistoryID:  whereHelperint{field: `account_request_history_id`},
	AccountIDRef:             whereHelperstring{field: `account_id_ref`},
	AccountRequestReference:  whereHelperstring{field: `account_request_reference`},
	AccountID:                whereHelpernull_Int{field: `account_id`},
	SchemeName:               whereHelperstring{field: `scheme_name`},
	AccountIdentification:    whereHelperstring{field: `account_identification`},
	PartyID:                  whereHelpernull_Int{field: `party_id`},
	BankID:                   whereHelpernull_Int{field: `bank_id`},
	Name:                     whereHelperstring{field: `name`},
	Status:                   whereHelperstring{field: `status`},
	ReadAccountsBasic:        whereHelperstring{field: `read_accounts_basic`},
	ReadAccountsDetail:       whereHelperstring{field: `read_accounts_detail`},
	ReadBalances:             whereHelperstring{field: `read_balances`},
	ReadBeneficiariesBasic:   whereHelperstring{field: `read_beneficiaries_basic`},
	ReadBeneficiariesDetail:  whereHelperstring{field: `read_beneficiaries_detail`},
	ReadDirectDebits:         whereHelperstring{field: `read_direct_debits`},
	ReadProducts:             whereHelperstring{field: `read_products`},
	ReadStandingOrdersBasic:  whereHelperstring{field: `read_standing_orders_basic`},
	ReadStandingOrdersDetail: whereHelperstring{field: `read_standing_orders_detail`},
	ReadTransactionsBasic:    whereHelperstring{field: `read_transactions_basic`},
	ReadTransactionsCredits:  whereHelperstring{field: `read_transactions_credits`},
	ReadTransactionsDebits:   whereHelperstring{field: `read_transactions_debits`},
	ReadTransactionsDetail:   whereHelperstring{field: `read_transactions_detail`},
	ExpirationDateTime:       whereHelpertime_Time{field: `expiration_date_time`},
	TransactionFromDateTime:  whereHelpertime_Time{field: `transaction_from_date_time`},
	TransactionToDateTime:    whereHelpertime_Time{field: `transaction_to_date_time`},
	MakerDate:                whereHelpertime_Time{field: `maker_date`},
	CheckerDate:              whereHelpernull_Time{field: `checker_date`},
	MakerID:                  whereHelperstring{field: `maker_id`},
	CheckerID:                whereHelpernull_String{field: `checker_id`},
	ModifiedBy:               whereHelpernull_String{field: `modified_by`},
	ModifiedDate:             whereHelpernull_Time{field: `modified_date`},
}

// AccountRequestHistoryRels is where relationship names are stored.
var AccountRequestHistoryRels = struct {
	Account string
	Bank    string
}{
	Account: "Account",
	Bank:    "Bank",
}

// accountRequestHistoryR is where relationships are stored.
type accountRequestHistoryR struct {
	Account *Account
	Bank    *Bank
}

// NewStruct creates a new relationship struct
func (*accountRequestHistoryR) NewStruct() *accountRequestHistoryR {
	return &accountRequestHistoryR{}
}

// accountRequestHistoryL is where Load methods for each relationship are stored.
type accountRequestHistoryL struct{}

var (
	accountRequestHistoryColumns               = []string{"account_request_history_id", "account_id_ref", "account_request_reference", "account_id", "scheme_name", "account_identification", "party_id", "bank_id", "name", "status", "read_accounts_basic", "read_accounts_detail", "read_balances", "read_beneficiaries_basic", "read_beneficiaries_detail", "read_direct_debits", "read_products", "read_standing_orders_basic", "read_standing_orders_detail", "read_transactions_basic", "read_transactions_credits", "read_transactions_debits", "read_transactions_detail", "expiration_date_time", "transaction_from_date_time", "transaction_to_date_time", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	accountRequestHistoryColumnsWithoutDefault = []string{"account_request_history_id", "account_id_ref", "account_request_reference", "account_id", "scheme_name", "account_identification", "party_id", "bank_id", "name", "status", "read_accounts_basic", "read_accounts_detail", "read_balances", "read_beneficiaries_basic", "read_beneficiaries_detail", "read_direct_debits", "read_products", "read_standing_orders_basic", "read_standing_orders_detail", "read_transactions_basic", "read_transactions_credits", "read_transactions_debits", "read_transactions_detail", "expiration_date_time", "transaction_from_date_time", "transaction_to_date_time", "maker_date", "checker_date", "maker_id", "checker_id", "modified_by", "modified_date"}
	accountRequestHistoryColumnsWithDefault    = []string{}
	accountRequestHistoryPrimaryKeyColumns     = []string{"account_request_history_id"}
)

type (
	// AccountRequestHistorySlice is an alias for a slice of pointers to AccountRequestHistory.
	// This should generally be used opposed to []AccountRequestHistory.
	AccountRequestHistorySlice []*AccountRequestHistory
	// AccountRequestHistoryHook is the signature for custom AccountRequestHistory hook methods
	AccountRequestHistoryHook func(context.Context, boil.ContextExecutor, *AccountRequestHistory) error

	accountRequestHistoryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountRequestHistoryType                 = reflect.TypeOf(&AccountRequestHistory{})
	accountRequestHistoryMapping              = queries.MakeStructMapping(accountRequestHistoryType)
	accountRequestHistoryPrimaryKeyMapping, _ = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, accountRequestHistoryPrimaryKeyColumns)
	accountRequestHistoryInsertCacheMut       sync.RWMutex
	accountRequestHistoryInsertCache          = make(map[string]insertCache)
	accountRequestHistoryUpdateCacheMut       sync.RWMutex
	accountRequestHistoryUpdateCache          = make(map[string]updateCache)
	accountRequestHistoryUpsertCacheMut       sync.RWMutex
	accountRequestHistoryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var accountRequestHistoryBeforeInsertHooks []AccountRequestHistoryHook
var accountRequestHistoryBeforeUpdateHooks []AccountRequestHistoryHook
var accountRequestHistoryBeforeDeleteHooks []AccountRequestHistoryHook
var accountRequestHistoryBeforeUpsertHooks []AccountRequestHistoryHook

var accountRequestHistoryAfterInsertHooks []AccountRequestHistoryHook
var accountRequestHistoryAfterSelectHooks []AccountRequestHistoryHook
var accountRequestHistoryAfterUpdateHooks []AccountRequestHistoryHook
var accountRequestHistoryAfterDeleteHooks []AccountRequestHistoryHook
var accountRequestHistoryAfterUpsertHooks []AccountRequestHistoryHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AccountRequestHistory) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AccountRequestHistory) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AccountRequestHistory) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AccountRequestHistory) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AccountRequestHistory) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AccountRequestHistory) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AccountRequestHistory) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AccountRequestHistory) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AccountRequestHistory) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range accountRequestHistoryAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAccountRequestHistoryHook registers your hook function for all future operations.
func AddAccountRequestHistoryHook(hookPoint boil.HookPoint, accountRequestHistoryHook AccountRequestHistoryHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		accountRequestHistoryBeforeInsertHooks = append(accountRequestHistoryBeforeInsertHooks, accountRequestHistoryHook)
	case boil.BeforeUpdateHook:
		accountRequestHistoryBeforeUpdateHooks = append(accountRequestHistoryBeforeUpdateHooks, accountRequestHistoryHook)
	case boil.BeforeDeleteHook:
		accountRequestHistoryBeforeDeleteHooks = append(accountRequestHistoryBeforeDeleteHooks, accountRequestHistoryHook)
	case boil.BeforeUpsertHook:
		accountRequestHistoryBeforeUpsertHooks = append(accountRequestHistoryBeforeUpsertHooks, accountRequestHistoryHook)
	case boil.AfterInsertHook:
		accountRequestHistoryAfterInsertHooks = append(accountRequestHistoryAfterInsertHooks, accountRequestHistoryHook)
	case boil.AfterSelectHook:
		accountRequestHistoryAfterSelectHooks = append(accountRequestHistoryAfterSelectHooks, accountRequestHistoryHook)
	case boil.AfterUpdateHook:
		accountRequestHistoryAfterUpdateHooks = append(accountRequestHistoryAfterUpdateHooks, accountRequestHistoryHook)
	case boil.AfterDeleteHook:
		accountRequestHistoryAfterDeleteHooks = append(accountRequestHistoryAfterDeleteHooks, accountRequestHistoryHook)
	case boil.AfterUpsertHook:
		accountRequestHistoryAfterUpsertHooks = append(accountRequestHistoryAfterUpsertHooks, accountRequestHistoryHook)
	}
}

// One returns a single accountRequestHistory record from the query.
func (q accountRequestHistoryQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AccountRequestHistory, error) {
	o := &AccountRequestHistory{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for AccountRequestHistory")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AccountRequestHistory records from the query.
func (q accountRequestHistoryQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountRequestHistorySlice, error) {
	var o []*AccountRequestHistory

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to AccountRequestHistory slice")
	}

	if len(accountRequestHistoryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AccountRequestHistory records in the query.
func (q accountRequestHistoryQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count AccountRequestHistory rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountRequestHistoryQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if AccountRequestHistory exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *AccountRequestHistory) Account(mods ...qm.QueryMod) accountQuery {
	queryMods := []qm.QueryMod{
		qm.Where("account_id=?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	query := Accounts(queryMods...)
	queries.SetFrom(query.Query, "`Account`")

	return query
}

// Bank pointed to by the foreign key.
func (o *AccountRequestHistory) Bank(mods ...qm.QueryMod) bankQuery {
	queryMods := []qm.QueryMod{
		qm.Where("bank_id=?", o.BankID),
	}

	queryMods = append(queryMods, mods...)

	query := Banks(queryMods...)
	queries.SetFrom(query.Query, "`Banks`")

	return query
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountRequestHistoryL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccountRequestHistory interface{}, mods queries.Applicator) error {
	var slice []*AccountRequestHistory
	var object *AccountRequestHistory

	if singular {
		object = maybeAccountRequestHistory.(*AccountRequestHistory)
	} else {
		slice = *maybeAccountRequestHistory.(*[]*AccountRequestHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountRequestHistoryR{}
		}
		if !queries.IsNil(object.AccountID) {
			args = append(args, object.AccountID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountRequestHistoryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AccountID) {
				args = append(args, obj.AccountID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Account`), qm.WhereIn(`account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Account")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Account")
	}

	if len(accountRequestHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &accountR{}
		}
		foreign.R.AccountAccountRequestHistories = append(foreign.R.AccountAccountRequestHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AccountID, foreign.AccountID) {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.AccountAccountRequestHistories = append(foreign.R.AccountAccountRequestHistories, local)
				break
			}
		}
	}

	return nil
}

// LoadBank allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (accountRequestHistoryL) LoadBank(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccountRequestHistory interface{}, mods queries.Applicator) error {
	var slice []*AccountRequestHistory
	var object *AccountRequestHistory

	if singular {
		object = maybeAccountRequestHistory.(*AccountRequestHistory)
	} else {
		slice = *maybeAccountRequestHistory.(*[]*AccountRequestHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountRequestHistoryR{}
		}
		if !queries.IsNil(object.BankID) {
			args = append(args, object.BankID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountRequestHistoryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BankID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BankID) {
				args = append(args, obj.BankID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`Banks`), qm.WhereIn(`bank_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Bank")
	}

	var resultSlice []*Bank
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Bank")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for Banks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for Banks")
	}

	if len(accountRequestHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Bank = foreign
		if foreign.R == nil {
			foreign.R = &bankR{}
		}
		foreign.R.BankAccountRequestHistories = append(foreign.R.BankAccountRequestHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BankID, foreign.BankID) {
				local.R.Bank = foreign
				if foreign.R == nil {
					foreign.R = &bankR{}
				}
				foreign.R.BankAccountRequestHistories = append(foreign.R.BankAccountRequestHistories, local)
				break
			}
		}
	}

	return nil
}

// SetAccount of the accountRequestHistory to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountAccountRequestHistories.
func (o *AccountRequestHistory) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Account) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `AccountRequestHistory` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"account_id"}),
		strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.AccountID, o.AccountRequestHistoryID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AccountID, related.AccountID)
	if o.R == nil {
		o.R = &accountRequestHistoryR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &accountR{
			AccountAccountRequestHistories: AccountRequestHistorySlice{o},
		}
	} else {
		related.R.AccountAccountRequestHistories = append(related.R.AccountAccountRequestHistories, o)
	}

	return nil
}

// RemoveAccount relationship.
// Sets o.R.Account to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *AccountRequestHistory) RemoveAccount(ctx context.Context, exec boil.ContextExecutor, related *Account) error {
	var err error

	queries.SetScanner(&o.AccountID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Account = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AccountAccountRequestHistories {
		if queries.Equal(o.AccountID, ri.AccountID) {
			continue
		}

		ln := len(related.R.AccountAccountRequestHistories)
		if ln > 1 && i < ln-1 {
			related.R.AccountAccountRequestHistories[i] = related.R.AccountAccountRequestHistories[ln-1]
		}
		related.R.AccountAccountRequestHistories = related.R.AccountAccountRequestHistories[:ln-1]
		break
	}
	return nil
}

// SetBank of the accountRequestHistory to the related item.
// Sets o.R.Bank to related.
// Adds o to related.R.BankAccountRequestHistories.
func (o *AccountRequestHistory) SetBank(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Bank) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `AccountRequestHistory` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"bank_id"}),
		strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.BankID, o.AccountRequestHistoryID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BankID, related.BankID)
	if o.R == nil {
		o.R = &accountRequestHistoryR{
			Bank: related,
		}
	} else {
		o.R.Bank = related
	}

	if related.R == nil {
		related.R = &bankR{
			BankAccountRequestHistories: AccountRequestHistorySlice{o},
		}
	} else {
		related.R.BankAccountRequestHistories = append(related.R.BankAccountRequestHistories, o)
	}

	return nil
}

// RemoveBank relationship.
// Sets o.R.Bank to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *AccountRequestHistory) RemoveBank(ctx context.Context, exec boil.ContextExecutor, related *Bank) error {
	var err error

	queries.SetScanner(&o.BankID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("bank_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Bank = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BankAccountRequestHistories {
		if queries.Equal(o.BankID, ri.BankID) {
			continue
		}

		ln := len(related.R.BankAccountRequestHistories)
		if ln > 1 && i < ln-1 {
			related.R.BankAccountRequestHistories[i] = related.R.BankAccountRequestHistories[ln-1]
		}
		related.R.BankAccountRequestHistories = related.R.BankAccountRequestHistories[:ln-1]
		break
	}
	return nil
}

// AccountRequestHistories retrieves all the records using an executor.
func AccountRequestHistories(mods ...qm.QueryMod) accountRequestHistoryQuery {
	mods = append(mods, qm.From("`AccountRequestHistory`"))
	return accountRequestHistoryQuery{NewQuery(mods...)}
}

// FindAccountRequestHistory retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccountRequestHistory(ctx context.Context, exec boil.ContextExecutor, accountRequestHistoryID int, selectCols ...string) (*AccountRequestHistory, error) {
	accountRequestHistoryObj := &AccountRequestHistory{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `AccountRequestHistory` where `account_request_history_id`=?", sel,
	)

	q := queries.Raw(query, accountRequestHistoryID)

	err := q.Bind(ctx, exec, accountRequestHistoryObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from AccountRequestHistory")
	}

	return accountRequestHistoryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AccountRequestHistory) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no AccountRequestHistory provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountRequestHistoryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountRequestHistoryInsertCacheMut.RLock()
	cache, cached := accountRequestHistoryInsertCache[key]
	accountRequestHistoryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountRequestHistoryColumns,
			accountRequestHistoryColumnsWithDefault,
			accountRequestHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `AccountRequestHistory` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `AccountRequestHistory` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `AccountRequestHistory` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into AccountRequestHistory")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.AccountRequestHistoryID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for AccountRequestHistory")
	}

CacheNoHooks:
	if !cached {
		accountRequestHistoryInsertCacheMut.Lock()
		accountRequestHistoryInsertCache[key] = cache
		accountRequestHistoryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AccountRequestHistory.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AccountRequestHistory) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	accountRequestHistoryUpdateCacheMut.RLock()
	cache, cached := accountRequestHistoryUpdateCache[key]
	accountRequestHistoryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountRequestHistoryColumns,
			accountRequestHistoryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update AccountRequestHistory, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `AccountRequestHistory` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, accountRequestHistoryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, append(wl, accountRequestHistoryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update AccountRequestHistory row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for AccountRequestHistory")
	}

	if !cached {
		accountRequestHistoryUpdateCacheMut.Lock()
		accountRequestHistoryUpdateCache[key] = cache
		accountRequestHistoryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q accountRequestHistoryQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for AccountRequestHistory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for AccountRequestHistory")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountRequestHistorySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountRequestHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `AccountRequestHistory` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountRequestHistoryPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in accountRequestHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all accountRequestHistory")
	}
	return rowsAff, nil
}

var mySQLAccountRequestHistoryUniqueColumns = []string{
	"account_request_history_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AccountRequestHistory) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no AccountRequestHistory provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(accountRequestHistoryColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLAccountRequestHistoryUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountRequestHistoryUpsertCacheMut.RLock()
	cache, cached := accountRequestHistoryUpsertCache[key]
	accountRequestHistoryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			accountRequestHistoryColumns,
			accountRequestHistoryColumnsWithDefault,
			accountRequestHistoryColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			accountRequestHistoryColumns,
			accountRequestHistoryPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert AccountRequestHistory, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "AccountRequestHistory", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `AccountRequestHistory` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for AccountRequestHistory")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(accountRequestHistoryType, accountRequestHistoryMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for AccountRequestHistory")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for AccountRequestHistory")
	}

CacheNoHooks:
	if !cached {
		accountRequestHistoryUpsertCacheMut.Lock()
		accountRequestHistoryUpsertCache[key] = cache
		accountRequestHistoryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AccountRequestHistory record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AccountRequestHistory) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no AccountRequestHistory provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountRequestHistoryPrimaryKeyMapping)
	sql := "DELETE FROM `AccountRequestHistory` WHERE `account_request_history_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from AccountRequestHistory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for AccountRequestHistory")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountRequestHistoryQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no accountRequestHistoryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from AccountRequestHistory")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for AccountRequestHistory")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountRequestHistorySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no AccountRequestHistory slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(accountRequestHistoryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountRequestHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `AccountRequestHistory` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountRequestHistoryPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from accountRequestHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for AccountRequestHistory")
	}

	if len(accountRequestHistoryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AccountRequestHistory) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccountRequestHistory(ctx, exec, o.AccountRequestHistoryID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountRequestHistorySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountRequestHistorySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountRequestHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `AccountRequestHistory`.* FROM `AccountRequestHistory` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, accountRequestHistoryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AccountRequestHistorySlice")
	}

	*o = slice

	return nil
}

// AccountRequestHistoryExists checks if the AccountRequestHistory row exists.
func AccountRequestHistoryExists(ctx context.Context, exec boil.ContextExecutor, accountRequestHistoryID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `AccountRequestHistory` where `account_request_history_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, accountRequestHistoryID)
	}

	row := exec.QueryRowContext(ctx, sql, accountRequestHistoryID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if AccountRequestHistory exists")
	}

	return exists, nil
}
