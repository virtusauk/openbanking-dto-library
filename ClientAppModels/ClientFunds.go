// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package ClientAppModels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// ClientFund is an object representing the database table.
type ClientFund struct {
	ClientFundsID                  int         `boil:"client_funds_id" json:"client_funds_id" toml:"client_funds_id" yaml:"client_funds_id"`
	FundsConsentID                 string      `boil:"funds_consent_id" json:"funds_consent_id" toml:"funds_consent_id" yaml:"funds_consent_id"`
	ClientID                       string      `boil:"client_id" json:"client_id" toml:"client_id" yaml:"client_id"`
	ClientName                     null.String `boil:"client_name" json:"client_name,omitempty" toml:"client_name" yaml:"client_name,omitempty"`
	ReqAccept                      null.String `boil:"req_accept" json:"req_accept,omitempty" toml:"req_accept" yaml:"req_accept,omitempty"`
	ReqAuthorization               null.String `boil:"req_authorization" json:"req_authorization,omitempty" toml:"req_authorization" yaml:"req_authorization,omitempty"`
	ReqXFapiCustomerIPAddress      null.String `boil:"req_x_fapi_customer_ip_address" json:"req_x_fapi_customer_ip_address,omitempty" toml:"req_x_fapi_customer_ip_address" yaml:"req_x_fapi_customer_ip_address,omitempty"`
	ReqXFapiCustomerLastLoggedTime null.String `boil:"req_x_fapi_customer_last_logged_time" json:"req_x_fapi_customer_last_logged_time,omitempty" toml:"req_x_fapi_customer_last_logged_time" yaml:"req_x_fapi_customer_last_logged_time,omitempty"`
	ReqXFapiFinancialID            null.String `boil:"req_x_fapi_financial_id" json:"req_x_fapi_financial_id,omitempty" toml:"req_x_fapi_financial_id" yaml:"req_x_fapi_financial_id,omitempty"`
	ReqXFapiInteractionID          null.String `boil:"req_x_fapi_interaction_id" json:"req_x_fapi_interaction_id,omitempty" toml:"req_x_fapi_interaction_id" yaml:"req_x_fapi_interaction_id,omitempty"`
	ReqXIdempotencyKey             null.String `boil:"req_x_idempotency_key" json:"req_x_idempotency_key,omitempty" toml:"req_x_idempotency_key" yaml:"req_x_idempotency_key,omitempty"`
	ReqXJWSSignature               null.String `boil:"req_x_jws_signature" json:"req_x_jws_signature,omitempty" toml:"req_x_jws_signature" yaml:"req_x_jws_signature,omitempty"`
	HTTPStatus                     null.String `boil:"http_status" json:"http_status,omitempty" toml:"http_status" yaml:"http_status,omitempty"`
	ResponseStatus                 null.String `boil:"response_status" json:"response_status,omitempty" toml:"response_status" yaml:"response_status,omitempty"`
	ResContentType                 null.String `boil:"res_content_type" json:"res_content_type,omitempty" toml:"res_content_type" yaml:"res_content_type,omitempty"`
	ResXFapiInteractionID          null.String `boil:"res_x_fapi_interaction_id" json:"res_x_fapi_interaction_id,omitempty" toml:"res_x_fapi_interaction_id" yaml:"res_x_fapi_interaction_id,omitempty"`
	ResXJWSSignature               null.String `boil:"res_x_jws_signature" json:"res_x_jws_signature,omitempty" toml:"res_x_jws_signature" yaml:"res_x_jws_signature,omitempty"`

	R *clientFundR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L clientFundL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ClientFundColumns = struct {
	ClientFundsID                  string
	FundsConsentID                 string
	ClientID                       string
	ClientName                     string
	ReqAccept                      string
	ReqAuthorization               string
	ReqXFapiCustomerIPAddress      string
	ReqXFapiCustomerLastLoggedTime string
	ReqXFapiFinancialID            string
	ReqXFapiInteractionID          string
	ReqXIdempotencyKey             string
	ReqXJWSSignature               string
	HTTPStatus                     string
	ResponseStatus                 string
	ResContentType                 string
	ResXFapiInteractionID          string
	ResXJWSSignature               string
}{
	ClientFundsID:                  "client_funds_id",
	FundsConsentID:                 "funds_consent_id",
	ClientID:                       "client_id",
	ClientName:                     "client_name",
	ReqAccept:                      "req_accept",
	ReqAuthorization:               "req_authorization",
	ReqXFapiCustomerIPAddress:      "req_x_fapi_customer_ip_address",
	ReqXFapiCustomerLastLoggedTime: "req_x_fapi_customer_last_logged_time",
	ReqXFapiFinancialID:            "req_x_fapi_financial_id",
	ReqXFapiInteractionID:          "req_x_fapi_interaction_id",
	ReqXIdempotencyKey:             "req_x_idempotency_key",
	ReqXJWSSignature:               "req_x_jws_signature",
	HTTPStatus:                     "http_status",
	ResponseStatus:                 "response_status",
	ResContentType:                 "res_content_type",
	ResXFapiInteractionID:          "res_x_fapi_interaction_id",
	ResXJWSSignature:               "res_x_jws_signature",
}

// Generated where

var ClientFundWhere = struct {
	ClientFundsID                  whereHelperint
	FundsConsentID                 whereHelperstring
	ClientID                       whereHelperstring
	ClientName                     whereHelpernull_String
	ReqAccept                      whereHelpernull_String
	ReqAuthorization               whereHelpernull_String
	ReqXFapiCustomerIPAddress      whereHelpernull_String
	ReqXFapiCustomerLastLoggedTime whereHelpernull_String
	ReqXFapiFinancialID            whereHelpernull_String
	ReqXFapiInteractionID          whereHelpernull_String
	ReqXIdempotencyKey             whereHelpernull_String
	ReqXJWSSignature               whereHelpernull_String
	HTTPStatus                     whereHelpernull_String
	ResponseStatus                 whereHelpernull_String
	ResContentType                 whereHelpernull_String
	ResXFapiInteractionID          whereHelpernull_String
	ResXJWSSignature               whereHelpernull_String
}{
	ClientFundsID:                  whereHelperint{field: `client_funds_id`},
	FundsConsentID:                 whereHelperstring{field: `funds_consent_id`},
	ClientID:                       whereHelperstring{field: `client_id`},
	ClientName:                     whereHelpernull_String{field: `client_name`},
	ReqAccept:                      whereHelpernull_String{field: `req_accept`},
	ReqAuthorization:               whereHelpernull_String{field: `req_authorization`},
	ReqXFapiCustomerIPAddress:      whereHelpernull_String{field: `req_x_fapi_customer_ip_address`},
	ReqXFapiCustomerLastLoggedTime: whereHelpernull_String{field: `req_x_fapi_customer_last_logged_time`},
	ReqXFapiFinancialID:            whereHelpernull_String{field: `req_x_fapi_financial_id`},
	ReqXFapiInteractionID:          whereHelpernull_String{field: `req_x_fapi_interaction_id`},
	ReqXIdempotencyKey:             whereHelpernull_String{field: `req_x_idempotency_key`},
	ReqXJWSSignature:               whereHelpernull_String{field: `req_x_jws_signature`},
	HTTPStatus:                     whereHelpernull_String{field: `http_status`},
	ResponseStatus:                 whereHelpernull_String{field: `response_status`},
	ResContentType:                 whereHelpernull_String{field: `res_content_type`},
	ResXFapiInteractionID:          whereHelpernull_String{field: `res_x_fapi_interaction_id`},
	ResXJWSSignature:               whereHelpernull_String{field: `res_x_jws_signature`},
}

// ClientFundRels is where relationship names are stored.
var ClientFundRels = struct {
}{}

// clientFundR is where relationships are stored.
type clientFundR struct {
}

// NewStruct creates a new relationship struct
func (*clientFundR) NewStruct() *clientFundR {
	return &clientFundR{}
}

// clientFundL is where Load methods for each relationship are stored.
type clientFundL struct{}

var (
	clientFundColumns               = []string{"client_funds_id", "funds_consent_id", "client_id", "client_name", "req_accept", "req_authorization", "req_x_fapi_customer_ip_address", "req_x_fapi_customer_last_logged_time", "req_x_fapi_financial_id", "req_x_fapi_interaction_id", "req_x_idempotency_key", "req_x_jws_signature", "http_status", "response_status", "res_content_type", "res_x_fapi_interaction_id", "res_x_jws_signature"}
	clientFundColumnsWithoutDefault = []string{"funds_consent_id", "client_id", "client_name", "req_accept", "req_authorization", "req_x_fapi_customer_ip_address", "req_x_fapi_customer_last_logged_time", "req_x_fapi_financial_id", "req_x_fapi_interaction_id", "req_x_idempotency_key", "req_x_jws_signature", "http_status", "response_status", "res_content_type", "res_x_fapi_interaction_id", "res_x_jws_signature"}
	clientFundColumnsWithDefault    = []string{"client_funds_id"}
	clientFundPrimaryKeyColumns     = []string{"client_funds_id"}
)

type (
	// ClientFundSlice is an alias for a slice of pointers to ClientFund.
	// This should generally be used opposed to []ClientFund.
	ClientFundSlice []*ClientFund
	// ClientFundHook is the signature for custom ClientFund hook methods
	ClientFundHook func(context.Context, boil.ContextExecutor, *ClientFund) error

	clientFundQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	clientFundType                 = reflect.TypeOf(&ClientFund{})
	clientFundMapping              = queries.MakeStructMapping(clientFundType)
	clientFundPrimaryKeyMapping, _ = queries.BindMapping(clientFundType, clientFundMapping, clientFundPrimaryKeyColumns)
	clientFundInsertCacheMut       sync.RWMutex
	clientFundInsertCache          = make(map[string]insertCache)
	clientFundUpdateCacheMut       sync.RWMutex
	clientFundUpdateCache          = make(map[string]updateCache)
	clientFundUpsertCacheMut       sync.RWMutex
	clientFundUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var clientFundBeforeInsertHooks []ClientFundHook
var clientFundBeforeUpdateHooks []ClientFundHook
var clientFundBeforeDeleteHooks []ClientFundHook
var clientFundBeforeUpsertHooks []ClientFundHook

var clientFundAfterInsertHooks []ClientFundHook
var clientFundAfterSelectHooks []ClientFundHook
var clientFundAfterUpdateHooks []ClientFundHook
var clientFundAfterDeleteHooks []ClientFundHook
var clientFundAfterUpsertHooks []ClientFundHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ClientFund) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ClientFund) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ClientFund) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ClientFund) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ClientFund) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ClientFund) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ClientFund) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ClientFund) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ClientFund) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientFundAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddClientFundHook registers your hook function for all future operations.
func AddClientFundHook(hookPoint boil.HookPoint, clientFundHook ClientFundHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		clientFundBeforeInsertHooks = append(clientFundBeforeInsertHooks, clientFundHook)
	case boil.BeforeUpdateHook:
		clientFundBeforeUpdateHooks = append(clientFundBeforeUpdateHooks, clientFundHook)
	case boil.BeforeDeleteHook:
		clientFundBeforeDeleteHooks = append(clientFundBeforeDeleteHooks, clientFundHook)
	case boil.BeforeUpsertHook:
		clientFundBeforeUpsertHooks = append(clientFundBeforeUpsertHooks, clientFundHook)
	case boil.AfterInsertHook:
		clientFundAfterInsertHooks = append(clientFundAfterInsertHooks, clientFundHook)
	case boil.AfterSelectHook:
		clientFundAfterSelectHooks = append(clientFundAfterSelectHooks, clientFundHook)
	case boil.AfterUpdateHook:
		clientFundAfterUpdateHooks = append(clientFundAfterUpdateHooks, clientFundHook)
	case boil.AfterDeleteHook:
		clientFundAfterDeleteHooks = append(clientFundAfterDeleteHooks, clientFundHook)
	case boil.AfterUpsertHook:
		clientFundAfterUpsertHooks = append(clientFundAfterUpsertHooks, clientFundHook)
	}
}

// One returns a single clientFund record from the query.
func (q clientFundQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ClientFund, error) {
	o := &ClientFund{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "ClientAppModels: failed to execute a one query for ClientFunds")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all ClientFund records from the query.
func (q clientFundQuery) All(ctx context.Context, exec boil.ContextExecutor) (ClientFundSlice, error) {
	var o []*ClientFund

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "ClientAppModels: failed to assign all query results to ClientFund slice")
	}

	if len(clientFundAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all ClientFund records in the query.
func (q clientFundQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to count ClientFunds rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q clientFundQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "ClientAppModels: failed to check if ClientFunds exists")
	}

	return count > 0, nil
}

// ClientFunds retrieves all the records using an executor.
func ClientFunds(mods ...qm.QueryMod) clientFundQuery {
	mods = append(mods, qm.From("`ClientFunds`"))
	return clientFundQuery{NewQuery(mods...)}
}

// FindClientFund retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindClientFund(ctx context.Context, exec boil.ContextExecutor, clientFundsID int, selectCols ...string) (*ClientFund, error) {
	clientFundObj := &ClientFund{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `ClientFunds` where `client_funds_id`=?", sel,
	)

	q := queries.Raw(query, clientFundsID)

	err := q.Bind(ctx, exec, clientFundObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "ClientAppModels: unable to select from ClientFunds")
	}

	return clientFundObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ClientFund) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("ClientAppModels: no ClientFunds provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientFundColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	clientFundInsertCacheMut.RLock()
	cache, cached := clientFundInsertCache[key]
	clientFundInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			clientFundColumns,
			clientFundColumnsWithDefault,
			clientFundColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(clientFundType, clientFundMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(clientFundType, clientFundMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `ClientFunds` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `ClientFunds` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `ClientFunds` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, clientFundPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to insert into ClientFunds")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ClientFundsID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == clientFundMapping["ClientFundsID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ClientFundsID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to populate default values for ClientFunds")
	}

CacheNoHooks:
	if !cached {
		clientFundInsertCacheMut.Lock()
		clientFundInsertCache[key] = cache
		clientFundInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the ClientFund.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ClientFund) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	clientFundUpdateCacheMut.RLock()
	cache, cached := clientFundUpdateCache[key]
	clientFundUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			clientFundColumns,
			clientFundPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("ClientAppModels: unable to update ClientFunds, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `ClientFunds` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, clientFundPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(clientFundType, clientFundMapping, append(wl, clientFundPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update ClientFunds row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by update for ClientFunds")
	}

	if !cached {
		clientFundUpdateCacheMut.Lock()
		clientFundUpdateCache[key] = cache
		clientFundUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q clientFundQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update all for ClientFunds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to retrieve rows affected for ClientFunds")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ClientFundSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("ClientAppModels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientFundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `ClientFunds` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientFundPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update all in clientFund slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to retrieve rows affected all in update all clientFund")
	}
	return rowsAff, nil
}

var mySQLClientFundUniqueColumns = []string{
	"client_funds_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ClientFund) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("ClientAppModels: no ClientFunds provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientFundColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLClientFundUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	clientFundUpsertCacheMut.RLock()
	cache, cached := clientFundUpsertCache[key]
	clientFundUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			clientFundColumns,
			clientFundColumnsWithDefault,
			clientFundColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			clientFundColumns,
			clientFundPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("ClientAppModels: unable to upsert ClientFunds, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "ClientFunds", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `ClientFunds` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(clientFundType, clientFundMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(clientFundType, clientFundMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to upsert for ClientFunds")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ClientFundsID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == clientFundMapping["client_funds_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(clientFundType, clientFundMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to retrieve unique values for ClientFunds")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to populate default values for ClientFunds")
	}

CacheNoHooks:
	if !cached {
		clientFundUpsertCacheMut.Lock()
		clientFundUpsertCache[key] = cache
		clientFundUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single ClientFund record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ClientFund) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("ClientAppModels: no ClientFund provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), clientFundPrimaryKeyMapping)
	sql := "DELETE FROM `ClientFunds` WHERE `client_funds_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete from ClientFunds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by delete for ClientFunds")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q clientFundQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("ClientAppModels: no clientFundQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete all from ClientFunds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by deleteall for ClientFunds")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ClientFundSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("ClientAppModels: no ClientFund slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(clientFundBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientFundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `ClientFunds` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientFundPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete all from clientFund slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by deleteall for ClientFunds")
	}

	if len(clientFundAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ClientFund) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindClientFund(ctx, exec, o.ClientFundsID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ClientFundSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ClientFundSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientFundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `ClientFunds`.* FROM `ClientFunds` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientFundPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to reload all in ClientFundSlice")
	}

	*o = slice

	return nil
}

// ClientFundExists checks if the ClientFund row exists.
func ClientFundExists(ctx context.Context, exec boil.ContextExecutor, clientFundsID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `ClientFunds` where `client_funds_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, clientFundsID)
	}

	row := exec.QueryRowContext(ctx, sql, clientFundsID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "ClientAppModels: unable to check if ClientFunds exists")
	}

	return exists, nil
}
