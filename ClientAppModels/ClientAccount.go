// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package ClientAppModels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// ClientAccount is an object representing the database table.
type ClientAccount struct {
	ClientAccountID                int         `boil:"client_account_id" json:"client_account_id" toml:"client_account_id" yaml:"client_account_id"`
	AccountRequestID               string      `boil:"account_request_id" json:"account_request_id" toml:"account_request_id" yaml:"account_request_id"`
	ClientID                       string      `boil:"client_id" json:"client_id" toml:"client_id" yaml:"client_id"`
	ClientName                     null.String `boil:"client_name" json:"client_name,omitempty" toml:"client_name" yaml:"client_name,omitempty"`
	ReqAccept                      null.String `boil:"req_accept" json:"req_accept,omitempty" toml:"req_accept" yaml:"req_accept,omitempty"`
	ReqAuthorization               null.String `boil:"req_authorization" json:"req_authorization,omitempty" toml:"req_authorization" yaml:"req_authorization,omitempty"`
	ReqXFapiCustomerIPAddress      null.String `boil:"req_x_fapi_customer_ip_address" json:"req_x_fapi_customer_ip_address,omitempty" toml:"req_x_fapi_customer_ip_address" yaml:"req_x_fapi_customer_ip_address,omitempty"`
	ReqXFapiCustomerLastLoggedTime null.String `boil:"req_x_fapi_customer_last_logged_time" json:"req_x_fapi_customer_last_logged_time,omitempty" toml:"req_x_fapi_customer_last_logged_time" yaml:"req_x_fapi_customer_last_logged_time,omitempty"`
	ReqXFapiFinancialID            null.String `boil:"req_x_fapi_financial_id" json:"req_x_fapi_financial_id,omitempty" toml:"req_x_fapi_financial_id" yaml:"req_x_fapi_financial_id,omitempty"`
	ReqXFapiInteractionID          null.String `boil:"req_x_fapi_interaction_id" json:"req_x_fapi_interaction_id,omitempty" toml:"req_x_fapi_interaction_id" yaml:"req_x_fapi_interaction_id,omitempty"`
	ReqXIdempotencyKey             null.String `boil:"req_x_idempotency_key" json:"req_x_idempotency_key,omitempty" toml:"req_x_idempotency_key" yaml:"req_x_idempotency_key,omitempty"`
	ReqXJWSSignature               null.String `boil:"req_x_jws_signature" json:"req_x_jws_signature,omitempty" toml:"req_x_jws_signature" yaml:"req_x_jws_signature,omitempty"`
	HTTPStatus                     null.String `boil:"http_status" json:"http_status,omitempty" toml:"http_status" yaml:"http_status,omitempty"`
	ResponseStatus                 null.String `boil:"response_status" json:"response_status,omitempty" toml:"response_status" yaml:"response_status,omitempty"`
	ResContentType                 null.String `boil:"res_content_type" json:"res_content_type,omitempty" toml:"res_content_type" yaml:"res_content_type,omitempty"`
	ResXFapiInteractionID          null.String `boil:"res_x_fapi_interaction_id" json:"res_x_fapi_interaction_id,omitempty" toml:"res_x_fapi_interaction_id" yaml:"res_x_fapi_interaction_id,omitempty"`
	ResXJWSSignature               null.String `boil:"res_x_jws_signature" json:"res_x_jws_signature,omitempty" toml:"res_x_jws_signature" yaml:"res_x_jws_signature,omitempty"`

	R *clientAccountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L clientAccountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ClientAccountColumns = struct {
	ClientAccountID                string
	AccountRequestID               string
	ClientID                       string
	ClientName                     string
	ReqAccept                      string
	ReqAuthorization               string
	ReqXFapiCustomerIPAddress      string
	ReqXFapiCustomerLastLoggedTime string
	ReqXFapiFinancialID            string
	ReqXFapiInteractionID          string
	ReqXIdempotencyKey             string
	ReqXJWSSignature               string
	HTTPStatus                     string
	ResponseStatus                 string
	ResContentType                 string
	ResXFapiInteractionID          string
	ResXJWSSignature               string
}{
	ClientAccountID:                "client_account_id",
	AccountRequestID:               "account_request_id",
	ClientID:                       "client_id",
	ClientName:                     "client_name",
	ReqAccept:                      "req_accept",
	ReqAuthorization:               "req_authorization",
	ReqXFapiCustomerIPAddress:      "req_x_fapi_customer_ip_address",
	ReqXFapiCustomerLastLoggedTime: "req_x_fapi_customer_last_logged_time",
	ReqXFapiFinancialID:            "req_x_fapi_financial_id",
	ReqXFapiInteractionID:          "req_x_fapi_interaction_id",
	ReqXIdempotencyKey:             "req_x_idempotency_key",
	ReqXJWSSignature:               "req_x_jws_signature",
	HTTPStatus:                     "http_status",
	ResponseStatus:                 "response_status",
	ResContentType:                 "res_content_type",
	ResXFapiInteractionID:          "res_x_fapi_interaction_id",
	ResXJWSSignature:               "res_x_jws_signature",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var ClientAccountWhere = struct {
	ClientAccountID                whereHelperint
	AccountRequestID               whereHelperstring
	ClientID                       whereHelperstring
	ClientName                     whereHelpernull_String
	ReqAccept                      whereHelpernull_String
	ReqAuthorization               whereHelpernull_String
	ReqXFapiCustomerIPAddress      whereHelpernull_String
	ReqXFapiCustomerLastLoggedTime whereHelpernull_String
	ReqXFapiFinancialID            whereHelpernull_String
	ReqXFapiInteractionID          whereHelpernull_String
	ReqXIdempotencyKey             whereHelpernull_String
	ReqXJWSSignature               whereHelpernull_String
	HTTPStatus                     whereHelpernull_String
	ResponseStatus                 whereHelpernull_String
	ResContentType                 whereHelpernull_String
	ResXFapiInteractionID          whereHelpernull_String
	ResXJWSSignature               whereHelpernull_String
}{
	ClientAccountID:                whereHelperint{field: `client_account_id`},
	AccountRequestID:               whereHelperstring{field: `account_request_id`},
	ClientID:                       whereHelperstring{field: `client_id`},
	ClientName:                     whereHelpernull_String{field: `client_name`},
	ReqAccept:                      whereHelpernull_String{field: `req_accept`},
	ReqAuthorization:               whereHelpernull_String{field: `req_authorization`},
	ReqXFapiCustomerIPAddress:      whereHelpernull_String{field: `req_x_fapi_customer_ip_address`},
	ReqXFapiCustomerLastLoggedTime: whereHelpernull_String{field: `req_x_fapi_customer_last_logged_time`},
	ReqXFapiFinancialID:            whereHelpernull_String{field: `req_x_fapi_financial_id`},
	ReqXFapiInteractionID:          whereHelpernull_String{field: `req_x_fapi_interaction_id`},
	ReqXIdempotencyKey:             whereHelpernull_String{field: `req_x_idempotency_key`},
	ReqXJWSSignature:               whereHelpernull_String{field: `req_x_jws_signature`},
	HTTPStatus:                     whereHelpernull_String{field: `http_status`},
	ResponseStatus:                 whereHelpernull_String{field: `response_status`},
	ResContentType:                 whereHelpernull_String{field: `res_content_type`},
	ResXFapiInteractionID:          whereHelpernull_String{field: `res_x_fapi_interaction_id`},
	ResXJWSSignature:               whereHelpernull_String{field: `res_x_jws_signature`},
}

// ClientAccountRels is where relationship names are stored.
var ClientAccountRels = struct {
}{}

// clientAccountR is where relationships are stored.
type clientAccountR struct {
}

// NewStruct creates a new relationship struct
func (*clientAccountR) NewStruct() *clientAccountR {
	return &clientAccountR{}
}

// clientAccountL is where Load methods for each relationship are stored.
type clientAccountL struct{}

var (
	clientAccountColumns               = []string{"client_account_id", "account_request_id", "client_id", "client_name", "req_accept", "req_authorization", "req_x_fapi_customer_ip_address", "req_x_fapi_customer_last_logged_time", "req_x_fapi_financial_id", "req_x_fapi_interaction_id", "req_x_idempotency_key", "req_x_jws_signature", "http_status", "response_status", "res_content_type", "res_x_fapi_interaction_id", "res_x_jws_signature"}
	clientAccountColumnsWithoutDefault = []string{"account_request_id", "client_id", "client_name", "req_accept", "req_authorization", "req_x_fapi_customer_ip_address", "req_x_fapi_customer_last_logged_time", "req_x_fapi_financial_id", "req_x_fapi_interaction_id", "req_x_idempotency_key", "req_x_jws_signature", "http_status", "response_status", "res_content_type", "res_x_fapi_interaction_id", "res_x_jws_signature"}
	clientAccountColumnsWithDefault    = []string{"client_account_id"}
	clientAccountPrimaryKeyColumns     = []string{"client_account_id"}
)

type (
	// ClientAccountSlice is an alias for a slice of pointers to ClientAccount.
	// This should generally be used opposed to []ClientAccount.
	ClientAccountSlice []*ClientAccount
	// ClientAccountHook is the signature for custom ClientAccount hook methods
	ClientAccountHook func(context.Context, boil.ContextExecutor, *ClientAccount) error

	clientAccountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	clientAccountType                 = reflect.TypeOf(&ClientAccount{})
	clientAccountMapping              = queries.MakeStructMapping(clientAccountType)
	clientAccountPrimaryKeyMapping, _ = queries.BindMapping(clientAccountType, clientAccountMapping, clientAccountPrimaryKeyColumns)
	clientAccountInsertCacheMut       sync.RWMutex
	clientAccountInsertCache          = make(map[string]insertCache)
	clientAccountUpdateCacheMut       sync.RWMutex
	clientAccountUpdateCache          = make(map[string]updateCache)
	clientAccountUpsertCacheMut       sync.RWMutex
	clientAccountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var clientAccountBeforeInsertHooks []ClientAccountHook
var clientAccountBeforeUpdateHooks []ClientAccountHook
var clientAccountBeforeDeleteHooks []ClientAccountHook
var clientAccountBeforeUpsertHooks []ClientAccountHook

var clientAccountAfterInsertHooks []ClientAccountHook
var clientAccountAfterSelectHooks []ClientAccountHook
var clientAccountAfterUpdateHooks []ClientAccountHook
var clientAccountAfterDeleteHooks []ClientAccountHook
var clientAccountAfterUpsertHooks []ClientAccountHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ClientAccount) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ClientAccount) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ClientAccount) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ClientAccount) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ClientAccount) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ClientAccount) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ClientAccount) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ClientAccount) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ClientAccount) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAccountAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddClientAccountHook registers your hook function for all future operations.
func AddClientAccountHook(hookPoint boil.HookPoint, clientAccountHook ClientAccountHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		clientAccountBeforeInsertHooks = append(clientAccountBeforeInsertHooks, clientAccountHook)
	case boil.BeforeUpdateHook:
		clientAccountBeforeUpdateHooks = append(clientAccountBeforeUpdateHooks, clientAccountHook)
	case boil.BeforeDeleteHook:
		clientAccountBeforeDeleteHooks = append(clientAccountBeforeDeleteHooks, clientAccountHook)
	case boil.BeforeUpsertHook:
		clientAccountBeforeUpsertHooks = append(clientAccountBeforeUpsertHooks, clientAccountHook)
	case boil.AfterInsertHook:
		clientAccountAfterInsertHooks = append(clientAccountAfterInsertHooks, clientAccountHook)
	case boil.AfterSelectHook:
		clientAccountAfterSelectHooks = append(clientAccountAfterSelectHooks, clientAccountHook)
	case boil.AfterUpdateHook:
		clientAccountAfterUpdateHooks = append(clientAccountAfterUpdateHooks, clientAccountHook)
	case boil.AfterDeleteHook:
		clientAccountAfterDeleteHooks = append(clientAccountAfterDeleteHooks, clientAccountHook)
	case boil.AfterUpsertHook:
		clientAccountAfterUpsertHooks = append(clientAccountAfterUpsertHooks, clientAccountHook)
	}
}

// One returns a single clientAccount record from the query.
func (q clientAccountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ClientAccount, error) {
	o := &ClientAccount{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "ClientAppModels: failed to execute a one query for ClientAccount")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all ClientAccount records from the query.
func (q clientAccountQuery) All(ctx context.Context, exec boil.ContextExecutor) (ClientAccountSlice, error) {
	var o []*ClientAccount

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "ClientAppModels: failed to assign all query results to ClientAccount slice")
	}

	if len(clientAccountAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all ClientAccount records in the query.
func (q clientAccountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to count ClientAccount rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q clientAccountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "ClientAppModels: failed to check if ClientAccount exists")
	}

	return count > 0, nil
}

// ClientAccounts retrieves all the records using an executor.
func ClientAccounts(mods ...qm.QueryMod) clientAccountQuery {
	mods = append(mods, qm.From("`ClientAccount`"))
	return clientAccountQuery{NewQuery(mods...)}
}

// FindClientAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindClientAccount(ctx context.Context, exec boil.ContextExecutor, clientAccountID int, selectCols ...string) (*ClientAccount, error) {
	clientAccountObj := &ClientAccount{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `ClientAccount` where `client_account_id`=?", sel,
	)

	q := queries.Raw(query, clientAccountID)

	err := q.Bind(ctx, exec, clientAccountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "ClientAppModels: unable to select from ClientAccount")
	}

	return clientAccountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ClientAccount) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("ClientAppModels: no ClientAccount provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientAccountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	clientAccountInsertCacheMut.RLock()
	cache, cached := clientAccountInsertCache[key]
	clientAccountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			clientAccountColumns,
			clientAccountColumnsWithDefault,
			clientAccountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(clientAccountType, clientAccountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(clientAccountType, clientAccountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `ClientAccount` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `ClientAccount` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `ClientAccount` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, clientAccountPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to insert into ClientAccount")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ClientAccountID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == clientAccountMapping["ClientAccountID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ClientAccountID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to populate default values for ClientAccount")
	}

CacheNoHooks:
	if !cached {
		clientAccountInsertCacheMut.Lock()
		clientAccountInsertCache[key] = cache
		clientAccountInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the ClientAccount.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ClientAccount) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	clientAccountUpdateCacheMut.RLock()
	cache, cached := clientAccountUpdateCache[key]
	clientAccountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			clientAccountColumns,
			clientAccountPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("ClientAppModels: unable to update ClientAccount, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `ClientAccount` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, clientAccountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(clientAccountType, clientAccountMapping, append(wl, clientAccountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update ClientAccount row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by update for ClientAccount")
	}

	if !cached {
		clientAccountUpdateCacheMut.Lock()
		clientAccountUpdateCache[key] = cache
		clientAccountUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q clientAccountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update all for ClientAccount")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to retrieve rows affected for ClientAccount")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ClientAccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("ClientAppModels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `ClientAccount` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientAccountPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to update all in clientAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to retrieve rows affected all in update all clientAccount")
	}
	return rowsAff, nil
}

var mySQLClientAccountUniqueColumns = []string{
	"client_account_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ClientAccount) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("ClientAppModels: no ClientAccount provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientAccountColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLClientAccountUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	clientAccountUpsertCacheMut.RLock()
	cache, cached := clientAccountUpsertCache[key]
	clientAccountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			clientAccountColumns,
			clientAccountColumnsWithDefault,
			clientAccountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			clientAccountColumns,
			clientAccountPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("ClientAppModels: unable to upsert ClientAccount, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "ClientAccount", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `ClientAccount` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(clientAccountType, clientAccountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(clientAccountType, clientAccountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to upsert for ClientAccount")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ClientAccountID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == clientAccountMapping["client_account_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(clientAccountType, clientAccountMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to retrieve unique values for ClientAccount")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to populate default values for ClientAccount")
	}

CacheNoHooks:
	if !cached {
		clientAccountUpsertCacheMut.Lock()
		clientAccountUpsertCache[key] = cache
		clientAccountUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single ClientAccount record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ClientAccount) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("ClientAppModels: no ClientAccount provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), clientAccountPrimaryKeyMapping)
	sql := "DELETE FROM `ClientAccount` WHERE `client_account_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete from ClientAccount")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by delete for ClientAccount")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q clientAccountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("ClientAppModels: no clientAccountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete all from ClientAccount")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by deleteall for ClientAccount")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ClientAccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("ClientAppModels: no ClientAccount slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(clientAccountBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `ClientAccount` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientAccountPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: unable to delete all from clientAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "ClientAppModels: failed to get rows affected by deleteall for ClientAccount")
	}

	if len(clientAccountAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ClientAccount) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindClientAccount(ctx, exec, o.ClientAccountID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ClientAccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ClientAccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `ClientAccount`.* FROM `ClientAccount` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, clientAccountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "ClientAppModels: unable to reload all in ClientAccountSlice")
	}

	*o = slice

	return nil
}

// ClientAccountExists checks if the ClientAccount row exists.
func ClientAccountExists(ctx context.Context, exec boil.ContextExecutor, clientAccountID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `ClientAccount` where `client_account_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, clientAccountID)
	}

	row := exec.QueryRowContext(ctx, sql, clientAccountID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "ClientAppModels: unable to check if ClientAccount exists")
	}

	return exists, nil
}
